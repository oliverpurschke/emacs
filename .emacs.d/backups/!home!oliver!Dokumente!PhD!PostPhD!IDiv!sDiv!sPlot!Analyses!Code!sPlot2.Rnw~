\renewcommand{\sfdefault}{lmss}
\renewcommand{\ttdefault}{lmtt}
\usepackage[T1]{fontenc}
\usepackage{geometry}
\geometry{verbose,tmargin=2.5cm,bmargin=2.5cm,lmargin=2.5cm,rmargin=2.5cm}
\usepackage{url}
\usepackage[authoryear]{natbib}

\makeatletter
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% User specified LaTeX commands.
% \VignetteIndexEntry{An Introduction to knitr}

\makeatother

\begin{document}

\title{Lab report: "Phylogenetic signal in species' co-occurrence"}

\author{Oliver Purschke}

\maketitle

<<show-off>>=

# load packages
library(multitable)
library(knitr)
library(taxize)
library(plyr)
library(vegdata)
library(reshape)
library(reshape2)
library(dplyr)
library(lattice)
library(Hmisc)
library(stringr)
library(rgdal)
library(ggplot2)
library(maptools)
library(pez)
library(Taxonstand)
library(willeerd)
library(curl)

# set paths
path.code.generic <- "/home/oliver/Dokumente/PhD/Code/"
path.code <- "/home/oliver/Dokumente/PhD/PostPhD/IDiv/sDiv/sPlot/Analyses/Code/"
path.data <- "/home/oliver/Dokumente/PhD/PostPhD/IDiv/sDiv/sPlot/Analyses/Data/"

# load additional functions
source(paste(path.code.generic, "OPfunc.R", sep = ""))

## read in sPlot species data
splot.spec <- read.csv(paste(path.data, "Species/sPlot/sPlot_species_27_08_2014woStrata.csv", sep = ""))
splot.loc.schultz <- read.csv(paste(path.data, "Species/sPlot/sPlot_species_26_08_2014.csv", sep = ""))
splot.spec.schultz <- read.csv(paste(path.data, "Species/sPlot/sPlot_species_26_08_2014.csv", sep = ""))

# ! import species list with only vascular plants (group ID > 1) + exclude Austria-Species that are not in Symbiosis (as they contain very many Bryophytes)

splot.spec.vasc <- read.csv(paste(path.data, "Species/sPlot/sPlot_species_29_08_2014Vascular.csv", sep = ""))


## explore data:
dim(splot.spec.vasc)
# 72377 rows
summary(splot.spec.vasc)

head(splot.spec.vasc)

splot.spec.vasc[1:200, c(5, 8)]
sort(unique(splot.spec.vasc[, 5]))[1:20000]

splot.spec.vasc[, 5][duplicated(splot.spec.vasc[, 5])]

length(sort(unique(splot.spec.vasc[, 5])))
# 32188 unique species

###
# data cleaning 
snam <- as.character(splot.spec.vasc[, 5])
snam[1:30]


snam <- gsub(" sp.", " sp", snam, fixed = T)
snam[1:30]

snam <- gsub(" species", " sp", snam)

#snam <- gsub("spcies", " sp", snam)

snam <- gsub(" cf.", " ", snam)
snam[1:30]

#snam <- gsub("x ", "", snam, fixed = T)

snam <- gsub(" x ", " ", snam, fixed = T)
snam <- gsub(" gr. ", " ", snam, fixed = T)
snam <- gsub(" sect. ", " ", snam, fixed = T)
snam <- gsub(" Sec. ", " ", snam, fixed = T)
snam <- gsub(" sectie ", " ", snam)
snam <- gsub("  ", " ", snam)
snam <- gsub("  ", " ", snam)

#snam <- gsub("x ", "", snam)
#snam[1:500]

snam <- tolower(snam)
snam <- capitalize(snam)

sort(unique(snam))[20000:30000]

# indentify names that have just one part:
nam.len <- unlist(lapply(strsplit(snam, " "), FUN=length))
sum(nam.len==1)
snam[nam.len==1]
                                        
                                        # reduce the full species names to just two parts 
# BUT only of those species with more than one name part
snam[nam.len!=1] <- word(snam[nam.len!=1],1,2)


# combine with the rest of the table
### check whether tables have similar lengths
length(snam)
str(snam)

length(splot.spec.vasc[, 5])
str(as.character(splot.spec.vasc[, 5]))

str(splot.spec.vasc)
splot.spec.vasc$TV.name.clean <- snam

names(splot.spec.vasc)

splot.spec.vasc[200:320,c(5,11)]

### remove species that have just on name part (as they do not make sense)
splot.spec.vasc.2 <- splot.spec.vasc[nam.len!=1, ]
length(unique(splot.spec.vasc.2$TV.name.clean))
# 25433

###
# 2) clean the biome species list
###
# ! import species list with only vascular plants (group ID > 1) + exclude Austria-Species that are not in Symbiosis (as they contain very many Bryophytes)

splot.spec.biom.vasc <- read.csv(paste(path.data, "Species/sPlot/sPloty_Species_Schulz_bio_29_08_2014Vascular.csv", sep = ""))
dim(splot.spec.biom.vasc)
summary(splot.spec.biom.vasc)

head(splot.spec.biom.vasc)

###
# data cleaning 
snam <- as.character(splot.spec.biom.vasc[, 5])
snam[1:50]
snam[100:150]
sort(unique(snam))[20000:30000]
length(unique(snam))
# there are now only 30006 instead of >32000 species

snam <- gsub(" sp.", " sp", snam, fixed = T)
snam[1:30]

snam <- gsub(" species", " sp", snam)

#snam <- gsub("spcies", " sp", snam)

snam <- gsub(" cf.", " ", snam)
snam[1:30]

#snam <- gsub("x ", "", snam, fixed = T)

snam <- gsub(" x ", " ", snam, fixed = T)
snam <- gsub(" gr. ", " ", snam, fixed = T)
snam <- gsub(" sect. ", " ", snam, fixed = T)
snam <- gsub(" Sec. ", " ", snam, fixed = T)
snam <- gsub(" sectie ", " ", snam)
snam <- gsub("  ", " ", snam)
snam <- gsub("  ", " ", snam)

# indentify names that have just one part:
nam.len <- unlist(lapply(strsplit(snam, " "), FUN=length))
sum(nam.len==1)
snam[nam.len==1]
                                        
# reduce the full species names to just two parts 
# BUT only of those species with more than one name part
snam[nam.len!=1] <- word(snam[nam.len!=1],1,2)

# combine with the rest of the table
### check whether tables have similar lengths
length(snam)
# 85221
str(snam)

length(splot.spec.biom.vasc[, 5])
str(as.character(splot.spec.biom.vasc[, 5]))

str(splot.spec.biom.vasc)
splot.spec.biom.vasc$TV.name.clean <- snam

names(splot.spec.biom.vasc)

splot.spec.biom.vasc[200:320,c(5,9)]

### remove species that have just on name part (as they do not make sense)
splot.spec.biom.vasc.2 <- splot.spec.biom.vasc[nam.len!=1, ]
dim(splot.spec.biom.vasc.2)
# 85197

length(unique(sPlot.TRY.data$splot.spec.biom.vasc$TV.name.clean))
# 24442

# save the data
sPlot.TRY.data <- list("splot.spec.vasc" = splot.spec.vasc, "splot.spec.biom.vasc" = splot.spec.biom.vasc.2)

sPlot.TRY.data$splot.spec.biom.vasc <- splot.spec.biom.vasc.2

save(sPlot.TRY.data, file = "sPlot.TRY.data.Rdata")

# in "splot.spec.vasc": aggregate "count" and "cover" at the species level
load("sPlot.TRY.data.Rdata")

names(sPlot.TRY.data$splot.spec.vasc)
# [7] "Count"  "Avg_Cover_Perc"      

test <- sPlot.TRY.data$splot.spec.vasc[,c(7,8,11)]
spec.group <- group_by(test, TV.name.clean)
spec.agg <- summarise(spec.group, mean(Count), mean(Avg_Cover_Perc))
dim(spec.agg)

sPlot.TRY.data$splot.spec.vasc.agg <- spec.agg

#### 
# 3) Merge with TRY-Data
####
library(colbycol)

# 3.1)
# for two columns
try.spec <- cbc.read.table("/home/oliver/Dokumente/PhD/PostPhD/IDiv/sDiv/sPlot/Analyses/Data/Species/TRY/Species/AccSpecies.txt", just.read = c(1, 2))
try.spec <- as.data.frame(try.spec)
try.spec[,2] <- as.character(try.spec[,2])

# for one column
try.spec <- read.table("/home/oliver/Dokumente/PhD/PostPhD/IDiv/sDiv/sPlot/Analyses/Data/Species/TRY/Species/AccSpecies_Height.txt")
try.spec[,1] <- as.character(try.spec[,1])
colnames(try.spec) <- "AccSpeciesName"
dim(try.spec)

sPlot.TRY.data$try.height <- try.spec

100*(length(
    sPlot.TRY.data$splot.spec.vasc.agg$TV.name.clean
    [which(sPlot.TRY.data$splot.spec.vasc.agg$TV.name.clean 
           %in% 
           sPlot.TRY.data$try.height$AccSpeciesName)])/
     length(sPlot.TRY.data$splot.spec.vasc.agg$TV.name.clean))

# 55.06483% of the species are covered by traits in TRY
# 44.9666% of the species for which gap-filled traits (of the 100 most common traits in TRY)
# 29.63458% of the species in splot for which height is available
# 25.46562% of the sPlot species, seed mass data is available
# 14.51866% SLA

# create stats for i) the most frequent species, and ii) the most dominant species (with the highest percentage cover)

names(sPlot.TRY.data$splot.spec.vasc.agg)

fac1 <- cut(sPlot.TRY.data$splot.spec.vasc.agg[,2], quantile(sPlot.TRY.data$splot.spec.vasc.agg[,2],(0:3)/3),labels=c("Low","Medium","High"))

#mean(Count):
# quantile(sPlot.TRY.data$splot.spec.vasc.agg[,2]
#   0%   25%   50%   75%  100% 
 #   1     3     9    35 18865 

#mean(Avg_Cover_Perc):
#quantile(sPlot.TRY.data$splot.spec.vasc.agg[,3],(0:3)/3)
#       0% 33.33333% 66.66667%      100% 
#0.010000  2.000000  3.344444 88.000000 

sPlot.TRY.data$splot.spec.vasc.agg$count.fac <- fac1
sPlot.TRY.data$splot.spec.vasc.agg$cover.fac <- fac2

# 3.1) how many of the most common species in sPlot are covered by TRY?
# create single splot species lists for count=high and cover=high

count.high <- sPlot.TRY.data$splot.spec.vasc.agg[which(sPlot.TRY.data$splot.spec.vasc.agg[,4]=="High"), ]

cover.high <- sPlot.TRY.data$splot.spec.vasc.agg[which(sPlot.TRY.data$splot.spec.vasc.agg[,5]=="High"), ]


100*(length(
    cover.high$TV.name.clean
    [which(cover.high$TV.name.clean 
           %in% 
           sPlot.TRY.data$try.see$AccSpeciesName)])/
     length(cover.high$TV.name.clean))

# count.high:
# all: 70.83579
# gap.filled: 62.52505
# height: 48.07262
# seed mass: 40.78746
# sla: 29.50607

# cover.high:
# all: 63.89249
# gap.filled: 55.03949
# height: 40.49275
# seed mass: 35.83638
# sla: 23.47047

####
# 3.2) 
####

dim(sPlot.TRY.data$splot.spec.biom.vasc)

sort(unique(sPlot.TRY.data$splot.spec.biom.vasc$SCHULZ_BIO))

biom.vec <- sPlot.TRY.data$splot.spec.biom.vasc$SCHULZ_BIO
sPlot.biome <- sPlot.TRY.data$splot.spec.biom.vasc

100*(length(
    sPlot.biome$TV.name.clean[biom.vec==1]
    [which(sPlot.biome$TV.name.clean[biom.vec==1]
           %in% 
           sPlot.TRY.data$try.see$AccSpeciesName)])/
     length(unique(sPlot.biome$TV.name.clean[biom.vec==1])))

sPlot.biome$TV.name.clean[biom.vec==1]sPlot.biome$TV.name.clean[biom.vec==1]
    

res.biome.sla <- NA
for (i in 1:9){
res.biome.sla <- c(res.biome.sla, 100*(length(
    unique(sPlot.biome$TV.name.clean[biom.vec==i])
    [which(unique(sPlot.biome$TV.name.clean[biom.vec==i])
           %in% 
           sPlot.TRY.data$try.sla$AccSpeciesName)])/
     length(unique(sPlot.biome$TV.name.clean[biom.vec==i]))))
}
res.biome.sla

results.biomes <- cbind(res.biome.all, res.biome.gap, res.biome.height, res.biome.seed, res.biome.sla)

results.biomes <- results.biomes[-1,]

rownames(results.biomes) <- (c(1:9))

results.biomes <- as.data.frame(results.biomes)


spec.num <- NA
for (i in 1:9){
    spec.num <- c(spec.num, length(unique(sPlot.biome$TV.name.clean[biom.vec==i])))
}

spec.num <- spec.num[-1]
                                        
# add number of species per biome
results.biomes <- cbind(rownames(results.biomes), spec.num, results.biomes)

colnames(results.biomes) <- c("Biome.Schultz", "Spec.num", "TRY.all","Gap.filled","Height","Seed.mass","SLA")

sPlot.TRY.data$Match.sPlot.TRY.Biomes <- results.biomes

# type table for global trait match (+ count, cover)

match.count.cover <- read.csv("/home/oliver/Dokumente/PhD/PostPhD/IDiv/sDiv/sPlot/Analyses/Data/Species/Match.TRY.sPlot.count.cover.csv")

rownames(match.count.cover) <- match.count.cover$X
match.count.cover <- match.count.cover[,-1]
match.count.cover <- t(match.count.cover)

sPlot.TRY.data$Match.sPlot.TRY.Count.Cover <- match.count.cover

write.table(sPlot.TRY.data$Match.sPlot.TRY.Count.Cover, file = "Match.sPlot.TRY.Count.Cover.txt")
write.csv(sPlot.TRY.data$Match.sPlot.TRY.Count.Cover, file = "Match.sPlot.TRY.Count.Cover.csv")

write.table(sPlot.TRY.data$Match.sPlot.TRY.Biomes, file = "Match.sPlot.TRY.Biomes.txt")
write.csv(sPlot.TRY.data$Match.sPlot.TRY.Biomes, file = "Match.sPlot.TRY.Biomes.csv")


######
# create maps (for global)
######

# read in shape file for biomes
### 

library(maptools)
library(shapefiles)

schultzBiomesShape <-readOGR("/home/oliver/Dokumente/PhD/PostPhD/IDiv/sDiv/sPlot/Analyses/Data/GIS/SchulzBiomes","schultzDissolve3")
summary(schultzBiomesShape)
plot(schultzBiomesShape)

# reproject to Robinson
schultzBiomesRobinson <- spTransform(schultzBiomesShape, CRS("+proj=longlat +lon_0=0 +x_0=0 +y_0=0 +ellps=WGS84 +datum=WGS84 +units=m +no_defs"))
summary(schultzBiomesRobinson)  
plot(schultzBiomesRobinson, col = "grey")  

#schultzBiomesShape@data

biome.ggmap <- fortify(schultzBiomesShape, region = "BiomeCode", trait = "Gap_filled")
summary(biome.ggmap)
str(biome.ggmap)

n <- length(unique(biome.ggmap$id)) 
# 9 corresponds to the groups
df <- data.frame(id = unique(biome.ggmap$id),
                 Trait.match_TRY.Gap.filled_Perc= schultzBiomesRobinson@data$Gap_filled,
                 Biome = factor(schultzBiomesRobinson@data$Schulz_Bio))

png(filename="Trait.match.Biome.TRY.gap.filled.png", height = 50, width = 120, pointsize = 12)
#postscript(file = "Trait.match.Biome.TRY.gap.filled.eps", height = 5, width = 12, paper = "special", onefile = FALSE, horizontal = FALSE, pointsize=12)
#pdf("Trait.match.Biome.TRY.gap.filled.pdf", height = 5, width = 12)
ggplot(df, aes(map_id = id)) +
     geom_map(aes(fill = Trait.match_TRY.Gap.filled_Perc, color = Biome), map =biome.ggmap) +
     expand_limits(x = biome.ggmap$long, y = biome.ggmap$lat) +
     scale_fill_gradient(low = "red", high = "blue", guide = "colorbar")
dev.off()

#####
# produce barcharts in ggplot2

biome <- as.data.frame(sPlot.TRY.data$Match.sPlot.TRY.Count.Cover)
biome <- t(biome)
biome <- as.data.frame(biome)
biome$Traits <- factor(rownames(biome), levels=c("TRY.all", "Gap.filled", "Height", "Seed.mass", "SLA"))
colnames(biome)[1:3] <- c("All", "Most Frequent", "Most Dominant")
mdat <- melt(biome, id.vars="Traits")
head(mdat)

postscript(file = "Trait.match.cover.dominance.eps", height = 4, width = 8, paper = "special", onefile = FALSE, horizontal = FALSE, pointsize=12)
#pdf("Trait.match.cover.dominance.pdf", height = 4, width = 8)
ggplot(mdat, aes(variable, value, fill=Traits)) + 
  geom_bar(stat="identity", position="dodge")+
    xlab("Species") +
  ylab("Percentage")+
  ggtitle("Match sPlot - TRY")
dev.off()

## for all biomes

biome2 <- as.data.frame((as.data.frame(sPlot.TRY.data$Match.sPlot.TRY.Biomes)))

biome2 <- biome2[, -c(1:2)]

biome2$Biome <- factor(c("Tropics.with.year-round.rain","Tropics.with.summer.rain","Dry.tropics.and.subtropics","Subtropics.with.winter.rain","Subtrop.with.year-round.rain","Temperate.midlatitudes","Dry.midlatitudes","Boreal.zone","Polar.and.subpolar.zone"), levels=c("Tropics.with.year-round.rain","Tropics.with.summer.rain","Dry.tropics.and.subtropics","Subtropics.with.winter.rain","Subtrop.with.year-round.rain","Temperate.midlatitudes","Dry.midlatitudes","Boreal.zone","Polar.and.subpolar.zone"))

#colnames(biome2)[1:9] <- as.character(schultzBiomesShape@data$Schulz_Bio)

mdat2 <- melt(biome2, id.vars="Biome")
head(mdat2)

#postscript(file = "Trait.match.biomes.eps", height = 4, width = 8, paper = "special", onefile = FALSE, horizontal = FALSE, pointsize=12)
pdf("Trait.match.biomes.pdf", height = 4, width = 8)
ggplot(mdat2, aes(variable, value, fill=Biome)) + 
  geom_bar(stat="identity", position="dodge")+
    xlab("Traits") +
  ylab("Percentage")+
  ggtitle("Match sPlot - TRY")
dev.off()


# change projection of map:
# http://gis.stackexchange.com/questions/44387/use-proj4-to-specify-robinson-projection-with-r-ggmap-and-ggplot2-packages

#############
# phylogeny #
#############

load("sPlot.TRY.data.Rdata")

save(sPlot.TRY.data, file = "sPlot.TRY.data.Rdata")

library(ape)
tank.tree <- read.tree("/home/oliver/Dokumente/PhD/PostPhD/IDiv/sDiv/sPlot/Analyses/Data/Phylogeny/2/PhylogeneticResources/Vascular_Plants_rooted.dated.tre")

pdf("Fagaceae.pdf", width=20, height =30)
plot(extract.clade(tank.tree, "Fagaceae", root.edge = 0, interactive = FALSE))
dev.off()

pdf("Rubiaceae.pdf", width=50, height =120)
plot(extract.clade(tank.tree, "Rubiaceae", root.edge = 0, interactive = FALSE))
dev.off()

length(unique(tank.tree$tip.label))

unique(tank.tree$tip.label) %in% unique(sPlot.TRY.data$splot.spec.vasc$TV.name.clean.2)

str(unique(tank.tree$tip.label)[1:10])
str(unique(sPlot.TRY.data$splot.spec.vasc$TV.name.clean)[1:10])

library(willeerd)
library(Taxonstand)

sPlot.TRY.data$splot.spec.vasc$TV.name.clean.2 <- gsub(" ", "_", sPlot.TRY.data$splot.spec.vasc$TV.name.clean)

# how many splot species are in the tank tree?:
sum(unique(sPlot.TRY.data$splot.spec.vasc$TV.name.clean.2) %in% unique(tank.tree$tip.label))
# 6637

sort(unique(sPlot.TRY.data$splot.spec.vasc$TV.name.clean.2[sPlot.TRY.data$splot.spec.vasc$TV.name.clean.2 %in% tank.tree$tip.label]))

sort(unique(sPlot.TRY.data$splot.spec.vasc$TV.name.clean.2[sPlot.TRY.data$splot.spec.vasc$TV.name.clean.2 %in% tank.tree$tip.label==F]))

# stuff to fix:
# 1) correct genera (using plant list or TNRS)
# e.g.: Elymus -> Leymus

nam <- unique(sPlot.TRY.data$splot.spec.vasc$TV.name.clean)[2000:2020]
nam <- as.vector(nam)
splot.plantlist <- make.clean.taxon.lookup(nam)

# 2) add genera: e.g. Elatine_sp
# consider skipping .sp131

# 3) add missing species to congeners
tree.con <- congeneric.merge(sPlot.TRY.data$splot.spec.vasc$TV.name.clean.2, tank.tree)

length(unique(tree.con$tip.label))

plot(tree.con, "f", cex = .01)

# 4) bind in another tree, e.g. Daphne tree

# what about gymnosperms

# which species missing from the Tank-tree are in GenBank?

# use willeerd to add missing species as congeners:

# use setdiff, intersect, union
                                        
# how many splot species are in the tank tree?:
sum(unique(sPlot.TRY.data$splot.spec.vasc$TV.name.clean.2) %in% unique(tree.con$tip.label))

sPlot.TRY.data$splot.spec.vasc$TV.name.clean.2) %in% unique(tree.con$tip.label)

?prune

phy.splot

?prune.tree
    
uni <- unique(sPlot.TRY.data$splot.spec.vasc$TV.name.clean.2)

uninam <- cbind(uni, uni)

rownames(uninam) <- uninam[,1]

mat <- match.phylo.data(tree.con, uninam)

mat$phy

pdf(file = "Phy.splot.pdf", height = 50, width = 50)
plot(mat$phy, "f", cex = .1)
dev.off()

make.clean.taxon.lookup <- function (species) {
    original <- species
    species <- gsub("_", " ", species)
    species <- gsub("  ", " ", species)
    search <- ldply(species, function(x) TPLck(x))
    lookup <- with(search, data.frame(original = original, clean = ifelse(Plant.Name.Index, 
        paste(New.Genus, New.Species), NA)))
    return(lookup)
}

ptm <- proc.time()

for (i in seq(from =1, to = 25450, 1272)){
nam <- sort(unique(sPlot.TRY.data$splot.spec.vasc$TV.name.clean))[i:(i+1271)]
splot.plantlist <- make.clean.taxon.lookup(nam)
write.csv(splot.plantlist, paste(paste("splotTPL", i), ".csv"))
}


# [2545:3817]
for (i in seq(from =2545, to = 3817, 127)){
nam <- sort(unique(sPlot.TRY.data$splot.spec.vasc$TV.name.clean))[i:(i+126)]
splot.plantlist <- make.clean.taxon.lookup(nam)
write.csv(splot.plantlist, paste(paste("splotTPL", i), ".csv"))
}

# 2545:3816
nam <- sort(unique(sPlot.TRY.data$splot.spec.vasc$TV.name.clean))[2545:3816]
splot.plantlist <- make.clean.taxon.lookup(nam)
splot.plantlist
write.csv(splot.plantlist, paste("splotTPL", "2545.csv"))


proc.time() - ptm

 User       System      verstrichen    
1.508       0.365      26.059 
1.327       0.375      23.627 
1.583       0.508      36.036


sPlot.TRY.data$splot.spec.vasc$TV.name.clean[sPlot.TRY.data$splot.spec.vasc$TV.name.clean == "Astragalus psoraloides"] <- "Astragalus gjunaicus"


# start 13.30 runs till 16.30-18.30

tab1 <- read.csv("/home/oliver/Dokumente/PhD/PostPhD/IDiv/sDiv/sPlot/Analyses/Code/splotTPL 1 .csv", head = T)
head(tab1)

tab <- NA
for (i in seq(from =1, to = 25450, 1272))
{
    tab <- rbind(tab, read.csv(paste(paste("splotTPL", i), ".csv")))
}

tab[,2] <- as.character(tab[,2])
tab[,3] <- as.character(tab[,3])

tab[3000:4000]


length(unique(tab[,2]))
#25451

length(unique(tab[,3]))
#20202

# why are there so much less unique cleaned species:
# 1) ~ 2500 synonyms
# 2) only genus information available e.g. ".sp"
# 3) name does not exist in TPL

sort((tab[,3]))
# 22634


tab[is.na(tab[,3]),2]

# export cleaned list

sPlot.TRY.data$TPLclean <- tab

save(sPlot.TRY.data, file = "sPlot.TRY.data.Rdata")


#################################
# building phylogenetic trees: 
#################################

# match species list from tank tree with 1) the plant list and 2) tnrs:

# tnrs:
mynames <- sort(tank.tree$tip.label)
mynames <- gsub("_"," ", mynames)
tank.tree.tnrs <- tnrs(query = mynames, source = "iPlant_TNRS")#[ , -c(5:7)]
tank.tree.tnrs

# the plant list:
tank.tree.tpl <- tpl_search(mynames, paral = TRUE)

sPlot.TRY.data$tank.tree.tpl <-tank.tree.tpl
sPlot.TRY.data$tank.tree.tnrs <-tank.tree.tnrs

tpl_search("Kosteletzkya buettneri")

tnrs(query = "Crinum glaucum", source = "iPlant_TNRS")

temp <- gnr_resolve(names = "Paronychia kayseriana")

# Three different kinds of trees:

#################
# 1) just based on the cleaned list:
clean <- gsub(" ", "_", unique(sPlot.TRY.data$TPLclean$clean))

tree.congen.clean <- congeneric.merge(clean[-1], tank.tree)
# Number of species in tree before: 6595
# Number of species in tree now:    18748

uninam <- cbind(clean[-1], clean[-1])
rownames(uninam) <- uninam[,1]
library(picante)
mat <- match.phylo.data(tree.congen.clean, uninam)
mat$phy
sPlot.TRY.data$phy.clean.18748 <- mat$phy

# 18748 species

pdf(file = "Phy.splot.clean.pdf", height = 90, width = 90)
plot(mat$phy, "f", cex = .1, edge.width = .3, label.offset = .1)
dev.off()

#################
# 2) cleaned list + species that are not in the cleaned list (but in the original list) but that are in the Tank-tree
tail(sPlot.TRY.data$TPLclean)
# which NA-species in the cleaned list are in the Tank-tree
# 18.50-19.15:
non.clean <- unique(sPlot.TRY.data$TPLclean[is.na(sPlot.TRY.data$TPLclean[,3]),2])[-1]

# 2816 species in the original, non-cleaned list are not in the cleaned list
# which of those species are in the Tank-tree?:
non.clean.unique <- gsub(" ", "_", non.clean)
length(non.clean.unique)
sum(non.clean.unique %in% unique(tank.tree$tip.label))
non.clean.unique <- non.clean.unique[non.clean.unique %in% unique(tank.tree$tip.label)]

uninam.nonclean <- cbind(non.clean.unique, non.clean.unique)
rownames(uninam.nonclean) <- uninam.nonclean[,1]

clean.nonclean <-  rbind(uninam, uninam.nonclean)

mat <- match.phylo.data(tree.congen.clean, clean.nonclean)
mat$phy

sPlot.TRY.data$phy.clean.nonclean.18773 <- mat$phy

pdf(file = "Phy.splot.clean.nonclean.all.18773.pdf", height = 90, width = 90)
plot(mat$phy, "f", cex = .1, edge.width = .3, label.offset = .1)
dev.off()

# try TNRS for non-resolved species
library(taxize)
temp <- gnr_resolve(names = non.clean[3:10])
temp$results[ , -c(1,4)]

mynames <- non.clean[10:20]
tnrs(query = mynames, source = "iPlant_TNRS")#[ , -c(5:7)]

#################
# 3) see 2) but including .sp-species
non.clean.unique <- gsub(" ", "_", non.clean)

uninam.nonclean <- cbind(non.clean.unique, non.clean.unique)
rownames(uninam.nonclean) <- uninam.nonclean[,1]

clean.nonclean.all <-  rbind(clean.nonclean, uninam.nonclean)
# 23042 species

tree.congen.clean.nonclean.all <- congeneric.merge(clean.nonclean.all[,1], tank.tree)
# Number of species in tree before: 6645
# Number of species in tree now:    20817

# continue here:
mat <- match.phylo.data(tree.congen.clean.nonclean.all, clean.nonclean.all)
mat$phy
sPlot.TRY.data$phy.clean.nonclean.all.20792 <- mat$phy

pdf(file = "Phy.splot.clean.nonclean.all.20792.pdf", height = 100, width = 100)
plot(mat$phy, "f", cex = .1, edge.width = .3, label.offset = .1)
dev.off()

##########

# which species from the cleaned species list are in the tank tree

clean.unique <- gsub(" ", "_", unique(tab[,2]))
length(clean.unique)
sum(clean.unique %in% unique(tank.tree$tip.label))
# 6595

sort(unique(sPlot.TRY.data$splot.spec.vasc$TV.name.clean.2[sPlot.TRY.data$splot.spec.vasc$TV.name.clean.2 %in% tank.tree$tip.label]))

sort(unique(sPlot.TRY.data$splot.spec.vasc$TV.name.clean.2[sPlot.TRY.data$splot.spec.vasc$TV.name.clean.2 %in% tank.tree$tip.label==F]))


pdf(file = "Tank.Tree.pdf", height = 150, width = 150)
plot(tank.tree, "f", cex = .1, edge.width = .3, label.offset = .1)
dev.off()

##############################
### read in sPlot database ###
##############################

## this is where the real taxon cleaning of sPlot 1.0 started

path.sPlot <- "/home/oliver/Dokumente/PhD/PostPhD/IDiv/sDiv/sPlot/Analyses/Data/Species/sPlot/sPlot_21_11_2014/"

# read species data (takes ~2 min on my 64bit, 2.5GHz machine)
splot.species <- read.csv(paste(path.sPlot, "sPlot_21_11_2014_species.csv", sep = ""), sep = "\t")
dim(splot.species)
length(unique(splot.species$PlotObservationID))
# 15501064       10
summary(splot.species)
str(splot.species)
colnames(splot.species)
length(unique(splot.species$Turboveg2.concept))

unique(splot.species$Turboveg2.concept)

[3442] Oxalis commutata v. commutata                                
 [3443] Thesium frisea v. frisea                                     
 [3444] Ficinia indica v. indica                                     
 [3445] Cliffortia ruscifolia v. purpurea                            
 [3446] Crassula capensis v. albertiniae                             
 [3447] Pinus radiata                                                
 [3448] Chrysanthemoides monilifera s. canescens                     
 [3449] Babiana striata v. striata                                   
 [3450] Erica sphaeroidea v. sphaeroidea                             
 [3451] Oxalis tenuifolia                                            
 [3452] Hibiscus aethiopicus v. aethiopicus                          
 [3453] Oxalis nidulans v. nidulans                                  
 [3454] Bobartia gladiata s. gladiata                                
 [3455] Stipagrostis zeyheri s. barbata    

[5204]                                                              
 [5205] r                                                            
 [5206] Syzygium rowlandii        

[5309] 1285 Indigofera lange Bl-Stiele*                             
 [5310] 1304 Polygala*                                               
 [5311] Acalypha ciliata                                             
 [5312] Aeollanthus pubescens                                        
 [5313] Amorphophallus abyssinicus                                   
 [5314] Andropogon pseudapricus                                      
 [5315] Aneilema lanceolatum                                         
 [5316] Biophytum umbraculum                                         
 [5317] Brachystelma bingeri                                         
 [5318] Brachystoma africana (gibt es nicht)                         
 [5319] Ctenium sp.                                      

[6300] Floscopa sp.                                                 
 [6301] Kyllinga sp.                                                 
 [6302] Chrysochloa hindsii                                          
 [6303] Kyllinga odorata                                             
 [6304] Goldrute ?*                                                  
 [6305] Fimbristylis debilis                                         
 [6306] Striga cf.aspera*                                            
 [6307] Hibiscus cf. micranthus*                                     
 [6308] Celbel Baleewol ?*                                           
 [6309] Cyperus rotundus                                             
 [6310] Fimbristylis cf. albo-viridis*                               
 [6311] Cucumis sp.        

[6385] AT441 (Euphorbia)*                                           
 [6386] KHH Composite (breite Bl.)*                                  
 [6387] KHH 3037 (Ficus)*                                            
 [6388] KHH 3054 (Ficus cf. iteophylla  Miq.)*                       
 [6389] Dioscorea cf. togoensis*                                     
 [6390] Indigofera cf. colutea*                                      
 [6391] Cyperus cf. sphacelatus*                                     
 [6392] Pandiaka sp.                                                 
 [6393] Sida sp.                                                     
 [6394] Solanum sp.                                                  
 [6395] KHH 3012 (Geophyt, gescheckte Bl, Muscari?)*                 
 [6396] KHH 3025 (Liliaceae, gelbe Blüten, breite Blätter)*     
     
     [6519] ms477 Sida klein*                                            
 [6520] ms507 Commiphora*                                            
 [6521] ms509 Cyperus*                                               
 [6522] Cassia italica                                               
 [6523] ms515 Cyperus flache Ährchen*                                
 [6524] ms521 Sterculiacée*                                          
 [6525] ms525 Brachiaria spitz*                                      
 [6526] ms526 Bulbostylis*                                           
 [6527] ms531 Crotalaria*                                            
 [6528] ms749*                                                       
 [6529] ms741*                                                       
 [6530] Cymbopogon giganteus v. giganteus                            
 [6531] Tephrosia groß schlank rosa                                  
 [6532] Striga weiß                                                  
 [6533] ms757*                                                       
 [6534] Tephrosia groß schlank                                       
 [6535] Ipomoea cf. eriocarpa*                                       
 [6536] ms761*                                                       
 [6537] Cissus cf. populnea*                                         
 [6538] ms770*                                                       
 [6539] Aneilema sp. (Commelina 'Traube')                            
 [6540] ms776*                                                       
 [6541] Cissus polyantha                                             
 [6542] ms781*                                                       
 [6543] ms795*                
     
     [6551] AT435 Cyperaceae fine*                                       
 [6552] AT445 Cyperaceae étoile*                                     
 [6553] AT447 Commelina*                                             
 [6554] AT451 Scrophulariacée à fleurs jaunes*                       
 [6555] AT454 Indigofera deux fruits (geminata?)*                    
 [6556] AT456 Corchorus fascicularis ?*                              
 [6557] AT460 Polygalacée ferrière*                                  
 [6558] AT462 Urginea sp.*                                           
 [6559] AT467 Aristolochia*                                          
 [6560] AT469 Indigofera*                                            
 [6561] AT471 Aspilia fleurs blanches*                               
 [6562] AT473 Composée à fruits picants*                             
 [6563] AT476 Dioscorea feuilles …*                                  
 [6564] AT477 Dioscorea feuilles triangulaires*                      
 [6565] AT479 Striga fleurs blanches*                                
 [6566] AT480 Composée lianescente*                                  
 [6567] AT482 Vigna ressemble à feuilles d’haricot*                  
 [6568] AT483 Hyparrhenia rufa ?*                                    
 [6569] AT498 Euphorbia resembl. À Dioscorea*                        
 [6570] AT501 Sida sp. Fleur blanche grande*                         
 [6571] AT468 Papilionacée collante*                                 
 [6572] KHH Composée feuilles scabreux Nr.???*                       
 [6573] Ipomoea resembl. À Dioscorea Nr.??*                          
 [6574] Grewia cf. barteri*            
     
     
unique(splot.species$Matched.concept)


# read header information
splot.header <- read.csv(paste(path.sPlot, "sPlot_header.csv", sep = ""), sep = "\t")

dim(splot.header)
# 
summary(splot.header)
str(splot.header)
colnames(splot.header)


##############################
#### read in TRY database ####
##############################

path.TRY <- "/home/oliver/Dokumente/PhD/PostPhD/IDiv/sDiv/sPlot/Analyses/Data/Traits/"

# LHS-traits from TRY 2.0 (2012/2013), gapfilled and log-transformed (15 more traits are available, see Shan et al. paper), Einzelmessungen, keine Mittelwerte
TRY.2.0.all.gapfilled.ln <- read.csv(paste(path.TRY, "allPredBackTrans.csv", sep = ""), sep = ",")

dim(TRY.2.0.all.gapfilled.ln)
# 259559      4
summary(TRY.2.0.all.gapfilled.ln)
str(TRY.2.0.all.gapfilled.ln)

length(unique(ID.names$AccSpeciesName))

# link Observation IDs to species names:
# read table that contains and IDs and accepted names 
ID.names <- read.table(paste(path.TRY, "TRY_pmf_DataRelease_cleaned_2012_08_25_SLA_Height_SeedMass.txt", sep = ""), sep = ";", head=T)
str(ID.names)
dim(ID.names)
names(ID.names)

TRY.2.0.all.gapfilled.ln.acc.names <- merge(ID.names[,c(1,7,8,11,13:17)], TRY.2.0.all.gapfilled.ln, by.x = "ObservationID", by.y = "ObservationID")

str(TRY.2.0.all.gapfilled.ln.acc.names)


# 1) create unified lookup table 

# generate combined unique species list for sPlot and TRY species:
spec.list.TRY.sPlot <- sort(unique(c(as.character(splot.species$Turboveg2.concept), as.character(TRY.2.0.LHS.gapfilled.ln.acc.names$AccSpeciesName))))
length(spec.list.TRY.sPlot)
# 81573
write.csv(spec.list.TRY.sPlot, file = "spec.list.TRY.sPlot.csv")

spec.list.TRY.sPlot.2 <- cbind(spec.list.TRY.sPlot, spec.list.TRY.sPlot)
str(spec.list.TRY.sPlot.2)
spec.list.TRY.sPlot.2 <- as.data.frame(spec.list.TRY.sPlot.2)

spec.list.TRY.sPlot.2[,1] <- as.character(spec.list.TRY.sPlot.2[,1])
spec.list.TRY.sPlot.2[,2] <- as.character(spec.list.TRY.sPlot.2[,2])

colnames(spec.list.TRY.sPlot.2) <- c("names.sPlot.TRY", "names.corr.string")
write.csv(spec.list.TRY.sPlot.2, file = "spec.list.TRY.sPlot.2.csv")

############################################################
# read in string-corrected table
#######

spec.list.TRY.sPlot <- read.csv("spec.list.TRY.sPlot.2.csv")
dim(spec.list.TRY.sPlot)
spec.list.TRY.sPlot <- spec.list.TRY.sPlot[, 2:3]
spec.list.TRY.sPlot[,1] <- as.character(spec.list.TRY.sPlot[,1])
spec.list.TRY.sPlot[,2] <- as.character(spec.list.TRY.sPlot[,2])
# correct some species that cause TPL to crash manually:
spec.list.TRY.sPlot[which(spec.list.TRY.sPlot[,2]=="Astragalus psoraloides"),2] <- "Astragalus gjunaicus"
spec.list.TRY.sPlot[which(spec.list.TRY.sPlot[,2]=="Hedysarum mackenzii"),2] <- "Hedysarum dasycarpum"

###########################################################

dim(spec.list.TRY.sPlot)

# check whether now 
# Tetraria burmannii is resolved

tpl.clean <- tpl_search(spec.list.TRY.sPlot[1:100], paral = TRUE)[,c(1,2,6,8,9)]
# runs until ~2pm
# !!! continue here !!!
write.csv(tpl.clean, file = "tpl.clean.csv")

# use Taxonstand:
tpl.clean.sPlot.TRY <- TPL(splist=spec.list.TRY.sPlot[1:200, 2], genus = NULL, species = NULL, infrasp = NULL, infra = TRUE, abbrev = TRUE, corr = TRUE, diffchar = 2, max.distance = 1, version = "1.1", file = "test.csv")
write.csv(tpl.clean.sPlot.TRY, file = "tpl.clean.sPlot.TRY.csv")

## cut into pieces:
#####################################################
for (i in seq(from =1, to = 10000, 1000)){
    nam <- spec.list.TRY.sPlot[i:(i+999),2]
    tpl.clean.sPlot.TRY <- TPL(nam, genus = NULL, species = NULL, infrasp = NULL, infra = T, abbrev = TRUE, corr = TRUE, diffchar = 2, max.distance = 1, version = "1.1", file = "")
    write.csv(tpl.clean.sPlot.TRY, paste(paste("splotTPL", i), ".csv"))
}
######################################################

# correct some species that cause TPL to crash manually:
spec.list.TRY.sPlot[which(spec.list.TRY.sPlot[,2]=="Astragalus psoraloides"),2] <- "Astragalus gjunaicus"
spec.list.TRY.sPlot[which(spec.list.TRY.sPlot[,2]=="Hedysarum mackenzii"),2] <- "Hedysarum dasycarpum"


# to check single species within a set of species
sp1 <- TPL(spec.list.TRY.sPlot[37348,2], genus = NULL, species = NULL, infrasp = NULL, infra = T, abbrev = TRUE, corr = TRUE, diffchar = 2, max.distance = 1, version = "1.1", file = "")
sp1

sp1 <- TPLck("Senecio erucaeformis", corr=TRUE, diffchar = 3, max.distance=3)
sp1

# 1) read in TPL files:

tab <- NA
for (i in seq(from =1, to = 82000, 1000))
{
    tab <- rbind(tab, read.csv(paste(paste("splotTPL", i), ".csv")))
}

str(tab)

tab[81000:82002, c(1,10,11)]

TPL.81573 <- tab
TPL.81573 <- TPL.81573[-1,]

TPL.81573 <- TPL.81573[1:81573, ]

tail(TPL.81573)

# original names from splot and TRY
TPL.81573$names.sPlot.TRY.original <- spec.list.TRY.sPlot[,1]

TPL.81573$names.TPL.combined <- paste(TPL.81573$New.Genus, TPL.81573$New.Species, sep = " ")


TPL.81573 <- TPL.81573[,-c(18:22)]

save(TPL.81573, file = "TPL.81573.Rdata")
write.csv(TPL.81573, file = "TPL.81573.csv")

colnames(TPL.81573)

TPL.81573[1:1000, c(8,16)]

str(TPL.81573$Taxonomic.status)

TPL.81573[,8] <- as.character(TPL.81573[,8])
TPL.81573[,16] <- as.character(TPL.81573[,16])

sum(TPL.81573$Taxonomic.status=="Accepted")
# 56546

sum(TPL.81573$Taxonomic.status=="Synonym")
# 11933

sum(TPL.81573$Taxonomic.status=="Misapplied")
# 6


###################
# to be corrected:
###################

sum(TPL.81573$Taxonomic.status=="Unresolved")
# 5105

sum(TPL.81573$Taxonomic.status=="")
# 7983



# 2) run unresolved against TNRS
mynames <- non.clean[10:20]
tnrs.nonresolved <- tnrs(query = mynames, source = "iPlant_TNRS")#[ , -c(5:7)]

tnrs.nonresolved <- tnrs(query = TPL.81573[TPL.81573$Taxonomic.status=="", c(8,17)][1:100,2], source = "iPlant_TNRS")[,c(1,2,4,5)]

tnrs.nonresolved[ ,1:2]

sum(tnrs.nonresolved[ ,2]!="")
# 27 TPL list

TPL.81573$tnrs.resolve <- NA

TPL.81573$tnrs.submitted <- NA
TPL.81573$tnrs.accepted <- NA
TPL.81573$tnrs.score <- NA
TPL.81573$tnrs.matched <- NA


for (i in which(TPL.81573[10000:81573,]$Taxonomic.status=="Unresolved")){
    TPL.81573[i, 19:22] <- tnrs(query = TPL.81573$names.TPL.combined[i], source = "iPlant_TNRS")[,c(1,2,4,5)]
}

for (i in which(TPL.81573[10008:81573,]$Taxonomic.status=="")){
    TPL.81573[i, 19:22] <- tnrs(query = TPL.81573$names.TPL.combined[i], source = "iPlant_TNRS")[,c(1,2,4,5)]
}

save(TPL.81573, file = "TPL.81573.Rdata")

load("sPlot_TRY_Backbone_v._0.1.Rdata")

### continue here
# start 8.13 with 1000 names
tnrs.nonresolved <- tnrs(query = TPL.81573[TPL.81573$Taxonomic.status=="Unresolved", 17], source = "iPlant_TNRS")[,c(1,2,4,5)]
tnrs.nonresolved[ ,1:2]
sum(tnrs.nonresolved[ ,2]!="")
# 2160
save(tnrs.nonresolved, file = "tnrs.nonresolved.Rdata")
write.csv(tnrs.nonresolved, file = "tnrs.nonresolved.csv")

tnrs.missing <- tnrs(query = TPL.81573[TPL.81573$Taxonomic.status=="", 17], source = "iPlant_TNRS")[,c(1,2,4,5)]
tnrs.missing[ ,1:2]
sum(tnrs.missing[ ,2]!="")

# import TNRS unresolved & missing and TPL.grep unresolved & missing:
load("tnrs.nonresolved.Rdata")
load("tnrs.missing.Rdata")
load("TPL.grep.unresolved.Rdata")
load("TPL.grep.missing.Rdata")

##
length((TPL.81573$names.TPL.combined))
# 81573
length(unique(TPL.81573$names.TPL.combined))
# 63410

# merge tnrs with (taxonomic backbone) TBB
head(tnrs.missing)
str(tnrs.missing)


dim(tnrs.missing[which(tnrs.missing$acceptedname!="" & tnrs.missing$score > .95), ])
# 2160 # where accepted names are available
# 446 ... which scores > 0.95

names(tnrs.missing[which(tnrs.missing$acceptedname!="" & tnrs.missing$score > .95), ])

tnrs.missing.clean <- tnrs.missing[which(tnrs.missing$acceptedname!="" & tnrs.missing$score > .95), 1:2]

write.csv(tnrs.missing.clean, file = "tnrs.missing.clean.csv")

names(tnrs.missing.clean)
names(tnrs.missing.clean)[1] <- "names.TPL.combined"

require(dplyr)
TPL.81573.merge.tnrs <- left_join(TPL.81573, tnrs.missing.clean)
dim(TPL.81573.merge.tnrs)
names(TPL.81573.merge.tnrs)[20] <- "tnrs.miss.accept"

write.csv(TPL.81573.merge.tnrs, "TPL.81573.merge.tnrs.csv")
TPL.81573 <- TPL.81573.merge.tnrs

# create empty columns "Final names 1" and "Final names 2"

TPL.81573$Final.names.1 <- NA
TPL.81573$Final.names.2 <- NA

# fill in final names column 

# Final.names.1: only fully resolved names

table(TPL.81573$Taxonomic.status)

TPL.81573$Final.names.1[which(TPL.81573$Taxonomic.status=="Misapplied")] <- TPL.81573$names.TPL.combined[TPL.81573$Taxonomic.status=="Misapplied"]

names(TPL.81573)

!is.na(TPL.81573$tnrs.miss.accept)

TPL.81573$Final.names.1[!is.na(TPL.81573$tnrs.miss.accept)] <- TPL.81573$tnrs.miss.accept[!is.na(TPL.81573$tnrs.miss.accept)]

sum(!is.na(TPL.81573$Final.names.1))

# Final.names.2: full species list: resolved names and filling gaps with all unmachted (including potentially erroneous and synonymous names from TPL (new.genus & new.species = names.TPL.combined))

TPL.81573$Final.names.2 <- TPL.81573$Final.names.1
TPL.81573$Final.names.2[is.na(TPL.81573$Final.names.1)] <- TPL.81573$names.TPL.combined[is.na(TPL.81573$Final.names.1)]

# Final.names.3: full species list: resolved names and filling gaps with correct genus names from TPL:
TPL.81573$Final.names.3 <- TPL.81573$Final.names.1
TPL.81573$New.Genus <- as.character(TPL.81573$New.Genus)
TPL.81573$Final.names.3[is.na(TPL.81573$Final.names.1)] <- TPL.81573$New.Genus[is.na(TPL.81573$Final.names.1)]

names(TPL.81573)


length(unique(TPL.81573$names.sPlot.TRY.original))

length(unique(TPL.81573$Final.names.1))
# 52226 resolved binomials

length(unique(TPL.81573$Final.names.2))
# 63116 (including non-resolved binomials)

length(unique(TPL.81573$Final.names.3))
# 56584 ()


write.csv(TPL.81573, "TPL.81573.csv")

save(TPL.81573, file = "TPL.81573.Rdata")

##
# import merged file for x-y-coords and biome shape
xy.db <- read.csv(file = "/home/oliver/Dokumente/PhD/PostPhD/IDiv/sDiv/sPlot/Analyses/Data/GIS/SchulzBiomes/Biome_Christian/Oliver_Biome/xycoords.csv")
dim(xy.db)
head(xy.db)

# check whether there are really 700.000 unique lat lon-combinations:
latlon <- NA
latlon <- paste(splot.header$Longitude, splot.header$Latitude, sep = "")
dim(latlon)
head(splot.header)
names(splot.header)
str(splot.header)

# check which rows have messed up coordinates
write.csv(splot.header[,c(1,25:26, 28)], file = "splot.header.xy.csv")

# which plot observ. IDs in the full header are not in the x.y db file?
header.nonmatch.xy <- splot.header[splot.header$PlotObservationID %in% xy.db$PlotObserv == FALSE, ]

head(header.nonmatch.xy)
write.csv(header.nonmatch.xy, file = "header.nonmatch.xy.csv")

######### generate community matrix
library(picante)
data(phylocom)
samp <- matrix2sample(phylocom$sample)

samp <- as.data.frame(samp)

samp2 <- cbind(samp, rnorm((1:48))+2)
names(samp2) <- c("plot", "abund", "spec", "trait")

save(samp2, file = "samp2.Rdata")

mat <- sample2matrix(samp)

###########
# match splot species with new species list based on original species names
# should contain: 

# load backbone
load("/home/oliver/Dokumente/PhD/PostPhD/IDiv/sDiv/sPlot/Analyses/Code/sPlot_TRY_Backbone_v._0.1.Rdata")

# clean splot.species (Helge):


dim(splot.species)
index2 <- match(splot.species$PlotObservationID,splot.header$PlotObservationID)
length(index2) #  15501064
any(is.na(index2)) # T
length(index2[is.na(index2)]) # 2
index2a <- which(is.na(index2))
splot.species$PlotObservationID[index2a] 
#[1] Myrianthus serratus Myrianthus serratus
which(splot.species$PlotObservationID==index2a[1])
length(which(splot.species$PlotObservationID==index2a[1]))
#-> REMOVE these 16 entries
dim(splot.species) # 15501064
splot.species <- splot.species[-which(splot.species$PlotObservationID==index2a[1]),]
dim(splot.species) # 15501048 
length(levels(splot.species$PlotObservationID)) # 705273
splot.species$PlotObservationID <- splot.species$PlotObservationID[,drop=T]
number.plots.total <- length(levels(splot.species$PlotObservationID)) # 705272

# this splot list is cleaned
dim(splot.species)

# simplify splot.species 
names(splot.species)
splot.species.small <- splot.species[,c(1,5,9)]
dim(splot.species.small)
# 15501048        3
str(splot.species.small)

splot.species.small$Turboveg2.concept <- as.character(splot.species.small$Turboveg2.concept)

backbone.small$names.sPlot.TRY.original[backbone.small$names.sPlot.TRY.original %in% splot.species.small$names.sPlot.TRY.original==F]

splot.species.small$names.sPlot.TRY.original[splot.species.small$names.sPlot.TRY.original %in% backbone.small$names.sPlot.TRY.original ==F]

# merge with tax. backbone:
dim(TPL.81573)
names(TPL.81573)

backbone.small <- TPL.81573[,c(18,21:23)]
head(backbone.small)

write.csv(backbone.small, file = "backbone.small.csv")
write.csv(backbone.small, file = "backbone.small.csv")


names(splot.species.small)[2] <- "names.sPlot.TRY.original"

splot.species.stand <- merge(splot.species.small, backbone.small, by.x = "Turboveg2.concept", by.y = "names.sPlot.TRY.original")

which(splot.species.stand$PlotObservationID %in% splot.species$PlotObservationID)

#####
require(plyr)
splot.species.stand <- join(splot.species.small, backbone.small)
dim(splot.species.stand)
head(splot.species.stand)
names(splot.species.stand)

splot.species.stand$names.sPlot.TRY.original <- splot.species.stand$Final.names.3

splot.species.stand <- splot.species.stand[,1:3]
names(splot.species.stand)[2] <- "StandSpeciesName" 

write.csv(splot.species.stand[500000:501000,], file = "splot.merge.csv")

save(splot.species.stand, file = "splot.species.stand.Rdata")

splot.species.stand

# !!!! check again some abundances against the origin 
# why are there more rows in "splot.species.stand" compared to "splot.species"
which(splot.species.stand$PlotObservationID %in% splot.species$PlotObservationID==F)


# next steps: species-trait means
####

names(backbone.small)
names(TRY.2.0.all.gapfilled.ln.acc.names)
dim(TRY.2.0.all.gapfilled.ln.acc.names)
# 259559     21

TRY.2.0.all.gapfilled.ln.acc.names$names.sPlot.TRY.original <- as.character(TRY.2.0.all.gapfilled.ln.acc.names$names.sPlot.TRY.original)

names(TRY.2.0.all.gapfilled.ln.acc.names)[3] <- "names.sPlot.TRY.original"

TRY.all.stand <- join(TRY.2.0.all.gapfilled.ln.acc.names, backbone.small)

dim(TRY.all.stand)

write.csv(TRY.all.stand, file = "TRY.all.stand.csv")

# traits, standardized species names, single observations, log-transformed
TRY.stand.sing <- TRY.all.stand
str(TRY.stand.sing)
names(TRY.stand.sing)

TRY.stand.sing$names.sPlot.TRY.original <- TRY.stand.sing$Final.names.3

TRY.stand.sing <- TRY.stand.sing[,c(3:21)]
str(TRY.stand.sing)
names(TRY.stand.sing)[1] <- "StandSpeciesName"

write.csv(TRY.stand.sing, file = "TRY.stand.sing.csv")

save(TRY.stand.sing, file = "TRY.stand.sing.Rdata")

# calculate species level trait values
library(data.table)

# match TRY with sPlot

TRY.stand.sing$StandSpeciesName <- as.factor(TRY.stand.sing$StandSpeciesName)
names(TRY.stand.sing)[2:19] <- c("SLA", "PlantHeight", "SeedMass", "LDMC", "StemDens", "LeafArea", "LeafN", "LeafP", "LeafNperArea", "Leaffreshmass", "LeafNPratio", "LeafC.perdrymass", "Leaf.delta.15N", "Stem.cond.dens", "Seed.num.rep.unit", "Wood.vessel.length", "Seed.length", "Disp.unit.leng")

TRY.stand.sing.DT <- data.table(TRY.stand.sing[,c(1:19)])
tables()
TRY.mean.sd <-  TRY.stand.sing.DT[, 
                               list(
                               n = length(SLA),
                               SLA.mean = mean(SLA), 
                               PlantHeight.mean = mean(PlantHeight), 
                               SeedMass.mean = mean(SeedMass),
                               LDMC.mean = mean(LDMC),
                               StemDens.mean = mean(StemDens),
                               LeafArea.mean = mean(LeafArea),
                               LeafN.mean = mean(LeafN),
                               LeafP.mean = mean(LeafP),
                               LeafNperArea.mean = mean(LeafNperArea),
                               Leaffreshmass.mean = mean(Leaffreshmass),
                               LeafNPratio.mean = mean(LeafNPratio),
                               LeafC.perdrymass.mean = mean(LeafC.perdrymass),
                               Leaf.delta.15N.mean = mean(Leaf.delta.15N),
                               Stem.cond.dens.mean = mean(Stem.cond.dens),
                               Seed.num.rep.unit.mean = mean(Seed.num.rep.unit),
                               Wood.vessel.length.mean = mean(Wood.vessel.length),
                               Seed.length.mean = mean(Seed.length),
                               Disp.unit.leng.mean = mean(Disp.unit.leng),
                               
                               SLA.sd = sd(SLA), 
                               PlantHeight.sd = sd(PlantHeight), 
                               SeedMass.sd = sd(SeedMass),
                               LDMC.sd = sd(LDMC),
                               StemDens.sd = sd(StemDens),
                               LeafArea.sd = sd(LeafArea),
                               LeafN.sd = sd(LeafN),
                               LeafP.sd = sd(LeafP),
                               LeafNperArea.sd = sd(LeafNperArea),
                               Leaffreshmass.sd = sd(Leaffreshmass),
                               LeafNPratio.sd = sd(LeafNPratio),
                               LeafC.perdrymass.sd = sd(LeafC.perdrymass),
                               Leaf.delta.15N.sd = sd(Leaf.delta.15N),
                               Stem.cond.dens.sd = sd(Stem.cond.dens),
                               Seed.num.rep.unit.sd = sd(Seed.num.rep.unit),
                               Wood.vessel.length.sd = sd(Wood.vessel.length),
                               Seed.length.sd = sd(Seed.length),
                               Disp.unit.leng.sd = sd(Disp.unit.leng)                                                              
                               ),
                               by=StandSpeciesName]

TRY.all.mean.sd <- as.data.frame(TRY.mean.sd)
write.csv(TRY.all.mean.sd, file = "TRY.all.mean.sd.csv")
save(TRY.all.mean.sd, file ="TRY.all.mean.sd.Rdata")

names(TRY.all.mean.sd)

index <- unique(splot.species.stand$StandSpeciesName) %in% TRY.all.mean.sd$StandSpeciesName
sum(index)

100*(length(
    unique(splot.species.stand$StandSpeciesName)
    [which(unique(splot.species.stand$StandSpeciesName)
           %in% 
           TRY.all.mean.sd$StandSpeciesName)])/
     length(unique(splot.species.stand$StandSpeciesName)))


### match between splot and TRY
# 41.02522% of the species for which gap-filled trait in TRY 2.0 based on (2012/2013) is available

splot.species.try <- splot.species.stand[which(splot.species.stand$StandSpeciesName %in% TRY.all.mean.sd$StandSpeciesName), ]
# 12349 species

dim(splot.species.try)
# 13693421        3

save(splot.species.try, file ="splot.species.try.Rdata")

# match TRY to splot
TRY.mean.sd.splot <- TRY.all.mean.sd[which(TRY.all.mean.sd$StandSpeciesName %in% splot.species.stand$StandSpeciesName), ]
dim(TRY.mean.sd.splot)

save(TRY.mean.sd.splot, file = "TRY.mean.sd.splot.Rdata")
write.csv(TRY.mean.sd.splot, file = "TRY.mean.sd.splot.csv")

########################################
########### calculate CWMs #############
########################################

load("splot.species.try.Rdata")
load("TRY.mean.sd.splot.Rdata")

# merge splot with LHS traits
library(dplyr) 
names(splot.species.try)
TRY.mean.sd.splot$StandSpeciesName <- as.character(TRY.mean.sd.splot$StandSpeciesName)
dim(splot.species.try)
names(splot.species.try)
names(TRY.mean.sd.splot)

rm(list = "splot.try")

# 13693421  
splot.try <- left_join(splot.species.try, TRY.mean.sd.splot[,c(1,3:6)])
gc()
dim(splot.try)
head(splot.try)
names(splot.try)

library(data.table)
DT <- data.table(splot.try[,c(1:3)])
head(DT)
gc()
tables()
CWM.splot <-  DT[,list(CWM.SLA = weighted.mean(SLA.mean, Cover..), 
                       CWM.PlantHeight = weighted.mean(PlantHeight.mean, Cover..), 
                       CWM.SeedMass = weighted.mean(SeedMass.mean, Cover..),
                       CWM.LDMC = weighted.mean(LDMC.mean, Cover..),
                       CWM.StemDens = weighted.mean(StemDens.mean, Cover..),
                       CWM.LeafArea = weighted.mean(LeafArea.mean, Cover..),
                       CWM.LeafN = weighted.mean(LeafN.mean, Cover..),
                       CWM.LeafP = weighted.mean(LeafP.mean, Cover..),
                       CWM.LeafNperArea = weighted.mean(LeafNperArea.mean, Cover..),
                       CWM.Leaffreshmass = weighted.mean(Leaffreshmass.mean, Cover..),
                       CWM.LeafNPratio = weighted.mean(LeafNPratio.mean, Cover..),
                       CWM.LeafC.perdrymass = weighted.mean(LeafC.perdrymass.mean, Cover..),
                       CWM.Leaf.delta.15N = weighted.mean(Leaf.delta.15N.mean, Cover..),
                       CWM.Stem.cond.dens = weighted.mean(Stem.cond.dens.mean, Cover..),
                       CWM.Seed.num.rep.unit = weighted.mean(Seed.num.rep.unit.mean, Cover..),
                       CWM.Wood.vessel.length = weighted.mean(Wood.vessel.length.mean, Cover..),
                       CWM.Seed.length = weighted.mean(Seed.length.mean, Cover..),
                       CWM.Disp.unit.leng = weighted.mean(Disp.unit.leng.mean, Cover..)

                       ), 
                 
                 by=PlotObservationID]
str(CWM.splot)
dim(CWM.splot)
CWM.splot <- as.data.frame(CWM.splot)
save(CWM.splot, file = "CWM.splot.Rdata")
write.csv(CWM.splot, file = "CWM.splot.csv")

###############
# trait ranges
##############

Range.splot <-  DT[,list(Range.SLA = diff(range(SLA.mean)), 
                       Range.PlantHeight = diff(range(PlantHeight.mean)),
                       Range.SeedMass = diff(range(SeedMass.mean)),
                       Range.LDMC = diff(range(LDMC.mean)),
                       Range.StemDens = diff(range(StemDens.mean)),
                       Range.LeafArea =diff(range(LeafArea.mean)),
                       Range.LeafN = diff(range(LeafN.mean)),
                       Range.LeafP = diff(range(LeafP.mean)),
                       Range.LeafNperArea = diff(range(LeafNperArea.mean)),
                       Range.Leaffreshmass = diff(range(Leaffreshmass.mean)),
                       Range.LeafNPratio = diff(range(LeafNPratio.mean)),
                       Range.LeafC.perdrymass = diff(range(LeafC.perdrymass.mean)),
                       Range.Leaf.delta.15N = diff(range(Leaf.delta.15N.mean)),
                       Range.Stem.cond.dens = diff(range(Stem.cond.dens.mean)),
                       Range.Seed.num.rep.unit = diff(range(Seed.num.rep.unit.mean)),
                       Range.Wood.vessel.length = diff(range(Wood.vessel.length.mean)),
                       Range.Seed.length = diff(range(Seed.length.mean)),
                       Range.Disp.unit.leng = diff(range(Disp.unit.leng.mean))

                       ), 
                 
                 by=PlotObservationID]
str(Range.splot)
dim(Range.splot)
head(Range.splot)
Range.splot <- as.data.frame(Range.splot)
save(Range.splot, file = "Range.splot.Rdata")
write.csv(Range.splot, file = "Range.splot.csv")

############################
### calculate FD indices ###
############################

# use data.table

# create distance matrix
rownames(TRY.mean.sd.splot) <- TRY.mean.sd.splot$StandSpeciesName
# one NA in TRY species names ()
## !!!! need to remove rows with NA s from 

TRY.mean.sd.splot <- TRY.mean.sd.splot[which(is.na(TRY.mean.sd.splot$StandSpeciesName)==FALSE), ]
dim(TRY.mean.sd.splot)
str(TRY.mean.sd.splot)
save(TRY.mean.sd.splot, file = "TRY.mean.sd.splot.Rdata")

SLA.vec <- TRY.mean.sd.splot[,3]
names(SLA.vec) <- rownames(TRY.mean.sd.splot)
SLA.dist.mat <- as.matrix(dist(SLA.vec))
gc()

# get rid of NAs in splot.species.try
splot.species.try <- splot.species.try[which(is.na(splot.species.try$Cover..)==FALSE), ]
str(splot.species.try)
save(splot.species.try, file = "splot.species.try.Rdata")

# create data.table
library(data.table)
DT <- data.table(splot.species.try)
head(DT)
gc()
tables()

# create small splot.DT
index <- 1:700
DT700 <- DT[which(DT$PlotObservationID %in% index),]
str(DT700)

DTall <- DT[which(DT$PlotObservationID %in% index),]


# test with small splot data set
mpd.phycom <-  DT.phycom[,list(MPD = mpd(t(abund), as.matrix(dist(trait)), abundance.weighted=FALSE)),by=plot]

phycom.mat <- cophenetic(phylocom$phylo)

# problem: no species names associated with abund

# potential solution: need to write a 
mpd(as.data.frame(t(phylocom$sample[1,])), cophenetic(phylocom$phylo), abundance.weighted=TRUE)

# function to assign species names to abundance vectors:
library(picante)
mpd.fun.dt <- function(abu, dis, nam, abundance.weighted){
    abu <- t(abu)
    colnames(abu) <- nam
    res <- mpd(abu, dis, abundance.weighted=abundance.weighted)
    res
}

mntd.fun.dt <- function(abu, dis, nam, abundance.weighted){
    abu <- t(abu)
    colnames(abu) <- nam
    res <- mntd(abu, dis, abundance.weighted=abundance.weighted)
    res
}


system.time(
mntd.sla.no.abu <-  DT[,list(mntd.sla = mntd.fun.dt(Cover.., SLA.dist.mat, StandSpeciesName, abundance.weighted=FALSE)),by=PlotObservationID]
)

system.time(
mntd.sla.no.abu <-  DT[,list(mntd.sla = mntd.fun.dt(Cover.., SLA.dist.mat, StandSpeciesName, abundance.weighted=TRUE)),by=PlotObservationID]
)

system.time(
mntd.sla.no.abu <-  DT[,list(mntd.sla = mntd.fun.dt(Cover.., SLA.dist.mat, StandSpeciesName, abundance.weighted=FALSE)),by=PlotObservationID]
)
system.time(
mntd.sla.no.abu <-  DT[,list(mntd.sla = mntd.fun.dt(Cover.., SLA.dist.mat, StandSpeciesName, abundance.weighted=TRUE)),by=PlotObservationID]
)



colnames(sla.mpd.mntd)[2:5] <- c("mpd.sla.no.abu", "mpd.sla.abu", "mntd.sla.no.abu", "mntd.sla.abu")

head(sla.mpd.mntd)

save(sla.mpd.mntd, file = "sla.mpd.mntd.Rdata")
write.csv(sla.mpd.mntd, file = "sla.mpd.mntd.csv")


#


# MPD #

# 1) either provide full distance matrix
# 2) recalculate distances for each set

# test with small data set across 100 sites
mpd100 <-  mpd(phylocom$sample, cophenetic(phylocom$phylo), abundance.weighted=FALSE)

CWM1 <-  DT[,list(CWM = sd(Cover..)*mean(Cover..)),by=PlotObservationID]


# system.time()

CWM1 <-  DT[,list(CWM = sd(Cover..)*mean(Cover..)),by=PlotObservationID]

DT %>% 
    group_by(PlotObservationID) %>% 
    summarise(mittel=sd(Cover..)*mean(Cover..),.parallel=TRUE)

ddply(data=DT, .(PlotObservationID), summarise(mittel=sd(Cover..)*mean(Cover..)), .parallel=TRUE)
#############

str(dummy$abun)

trait <- as.data.frame(dummy$trait[,2])
rownames(trait) <- rownames(dummy$trait)

abun <- t(as.data.frame(dummy$abun[1,]))[]
abun[1,] <- 1:8

test <- dbFD(dummy$trait, abun, stand.x = TRUE,
         ord = c("podani", "metric"), asym.bin = NULL,
         corr = c("sqrt", "cailliez", "lingoes", "none"),
         calc.FRic = TRUE, m = "max", stand.FRic = FALSE,
         scale.RaoQ = FALSE, calc.FGR = FALSE, clust.type = "ward",
         km.inf.gr = 2, km.sup.gr = nrow(x) - 1, km.iter = 100,
         km.crit = c("calinski", "ssi"), calc.CWM = FALSE,
         CWM.type = c("dom", "all"), calc.FDiv = TRUE, dist.bin = 2, 
         print.pco = FALSE, messages = TRUE)
test

#######
dim(TRY.mean.sd.splot)

LHS.dist.mat <- as.matrix(dist(TRY.mean.sd.splot[,3:5]))
gc()

save(mat, file = "mat.Rdata")


## span functional distance for the 3 single LHS traits and the three LHS traits together
    # save this matrices and use it for i) dendrogram construction and ii) to calculate mpd, etc.

# run on FD (dendrogram-based) - possibly span distance matrix server
    # (use PD function and create dendrogram according my approach in my PD-paper)

# mpd and mntd
  data(phylocom)
    test <- mntd(phylocom$sample[, 1:10], cophenetic(phylocom$phylo), abundance.weighted=TRUE)
 
# 
################





tnrs.missing$score <- as.numeric(tnrs.missing$score)

tnrs.missing.greater.0.95 <- tnrs.missing[tnrs.missing$score > .95, ]
str(tnrs.missing.greater.0.95)

names(TPL.81573)

TPL.81573 <- TPL.81573.merge.tnrs

tnrs.nonresolved.greater.0.95$submittedname %in% TPL.81573$names.TPL.combined

TPL.81573.merge.tnrs <- merge(TPL.81573, tnrs.nonresolved.greater.0.95, by.x = "names.TPL.combined", by.y = "submittedname", all = TRUE, all.x = TRUE, all.y = FALSE)

#### continue here, try match based on COMMON field
require(dplyr)
TPL.81573.merge.tnrs <- left_join(TPL.81573, tnrs.nonresolved.greater.0.95, by = c("names.TPL.combined", "submittedname"))

dim(TPL.81573.merge.tnrs)
str(TPL.81573.merge.tnrs)
names(TPL.81573.merge.tnrs)
write.csv(TPL.81573.merge.tnrs, file = "TPL.81573.merge.tnrs.csv")

names(TPL.81573.merge.tnrs)[19:21] <- c("tnrs.miss.accept", "tnrs.miss.score", "tnrs.miss.matched")

##
table(TPL.grep.missing$Taxonomic.status)

TPL.grep.missing <- cbind(paste(TPL.grep.missing$Genus, TPL.grep.missing$Species, sep = " "), TPL.grep.missing[,c(7)], (paste(TPL.grep.missing$New.Genus, TPL.grep.missing$New.Species, sep = " ")))

TPL.grep.missing <- as.data.frame(TPL.grep.missing)
TPL.grep.missing[,2] <- as.character(TPL.grep.missing[,2])
TPL.grep.missing[,1] <- as.character(TPL.grep.missing[,1])
TPL.grep.missing[,3] <- as.character(TPL.grep.missing[,3])

which(TPL.grep.missing[,2]=="Accepted")


TPL.81573.merge.tnrs <- merge(TPL.81573, TPL.grep.missing, by.x = "names.TPL.combined.1", by.y = "V1", all = TRUE, all.x = TRUE, all.y = FALSE)
dim(TPL.81573.merge.tnrs)
str(TPL.81573.merge.tnrs)
names(TPL.81573.merge.tnrs)

names(TPL.81573.merge.tnrs)[30:31] <- c("TPL.grep.status.miss", "TPL.grep.names.miss")

write.csv(TPL.81573.merge.tnrs, file = "TPL.81573.merge.tnrs.csv")

########
TPL.81573 <- read.csv("TPL.81573.csv")
TPL.81573$Taxonomic.status <- as.character(TPL.81573$Taxonomic.status)
TPL.81573$names.sPlot.TRY.original <- as.character(TPL.81573$names.sPlot.TRY.original)
TPL.81573$names.TPL.combined <- as.character(TPL.81573$names.TPL.combined)

# unified list next steps:
# 1) read in all 80+ files from TPL ! check whether there are 81573 rows
# 2) run unresolved against TNRS
# 3) run missing against TNRS
# 4) run still unmatched (unresolved + missing) species with appropriate grepping against TPL (diffchar = 3, max.distance = 3)
# 5) merge with huge tax.backbone

############################
# To Do (note to myself): #
############################

# 1) create unified lookup table for species names (taxonomic backbone) based on TPL (TNRS is erroneous), ask Florian Jansen regarding unresolved species names
# clean taxonomy in TRY and sPlot
# 2) calculate species-level traits means, sd & n
# !!! put everything in a multitable object
# 3) calculate community-levels mean traits (with and without abundance-weighting), range and higher moments of the trait distribution (variance, skewness, kurtosis)
# 4) evtl. calculate more FD indices, FEve, FDis, Rao, MPD etc.
# 5) assign biomes to plots (intersect x-y coords and biome-shape, ask Gunnar)
# 6) link plot data to env. data (i.e. bioclim, FAO-soil, etc.), ask Gunnar, and temporal variability (Miguel)

# other crucial steps:
# filter grassland and forest plots
# know

## ... more advanced analysis:
# standardized effect sizes within biomes
# functional turnover within between biomes, env. and spatial distance decay within and among biomes
# .... etc.... 


############################
# New summary statistics on TRY-splot match across biomes #
############################

# (a) wie viele Plots (absolut) haben wir pro Biom
# (b) wie hoch ist die Plotdichte (plots pro 100 km²) in jedem der Biome
# (c) wie viele Arten haben wir in den Plots der Biome
# (d) wie ist die Trait-Abdeckung der Arten pro Biom


# kick out erroneous plotIDs:

err <-  c(464754,464845,464867,464930,465053,465109,465124,465125,465126
,465193,465283,465287,465339,465340,465341,465432,465438,465473
,465482,465576,465604,465612,465623,465630,465678,465721,465729
,465770,465793,465845,465905,465925,466043,466097,466098,466099
,466100,466101,466327,466347,466348,466477,466508,466509,466510
,466511,466602,466603,466641,466687,466688,466689,466690,466692
,466694,466695,466696,466915,466938,466999,467008,467093,467094
,467121,467122,467123,467124,467125,467126,467127,467128,467129
,467143,467214,467215,467236,467340,467363,467533,467612,467613
,467614,467667,467668,467679,467743,467758,467769,467804,467809
,467852,467990,468036,468205,468306,468324,468462,468491,468533
,468543,468567,468568,468627,468656,468727,468779,468780,468805
,468866,468896,468918,469016,469058,469306,469312,469699,469700
,469701,469702,469703,469711,469756,469757,469767,469768)

err <- as.factor(err)

# test: how many plots in old CWM file:

load("/home/oliver/Dropbox/sPlot_Analysis/FD/MPD_MNTD/SLA.mpd.mntd.Rdata")

##

# (a) wie viele Plots (absolut) haben wir pro Biom

load("splot.species.try.Rdata")
load("TRY.mean.sd.splot.Rdata")

# load whole sPlot:
load("splot.species.stand.Rdata")
length(unique(splot.species.stand$PlotObservationID))

splot.species.try <- splot.species.try[which((splot.species.try$PlotObservationID %in% err)==FALSE), ]
save(splot.species.try, file = "splot.species.try.Rdata")

# 13693419
splot.species.stand <- splot.species.stand[which((splot.species.stand$PlotObservationID %in% err)==FALSE), ]
save(splot.species.stand, file = "splot.species.stand.Rdata")


# and exclude abund=NA:
splot.species.stand <- splot.species.stand[which(is.na(splot.species.stand$Cover..)==FALSE), ]
save(splot.species.stand, file = "splot.species.stand.Rdata")

## 
load("biome.xy.Rdata")
head(biome.xy)
which((biome.xy$PlotObserv %in% err)==TRUE)
plot(biome.xy$Longitude, biome.xy$Latitude)

# 

# 
100*(length(
    unique(splot.species.stand$StandSpeciesName)
    [which(unique(splot.species.stand$StandSpeciesName)
           %in% 
           TRY.mean.sd.splot$StandSpeciesName)])/
     length(unique(splot.species.stand$StandSpeciesName)))

# for 41.02598% of the species in splot gap-filled trait in TRY 2.0 based on (2012/2013) is available

length(unique(splot.species.stand$StandSpeciesName))
# after taxonomic standardization there are now 30099 unique species names in splot

length(unique(TRY.all.mean.sd$StandSpeciesName))
# after taxonomic standardization there are 38831 unique species names in TRY 2.0

length(unique(TRY.mean.sd.splot$StandSpeciesName))
# joining the two cleaned species list from TRY and sPlot yielded in 12348 species


# load entire TRY
load("TRY.all.mean.sd.Rdata")

# how many of the species Try are in splot?:
100*(length(
    unique(TRY.all.mean.sd$StandSpeciesName)
    [which(unique(TRY.all.mean.sd$StandSpeciesName)
           %in% 
           splot.species.stand$StandSpeciesName)])/
     length(unique(TRY.all.mean.sd$StandSpeciesName)))

# 31.79934% of all TRY species are in sPlot

#####################################################
# (a) wie viele Plots (absolut) haben wir pro Biom
#####################################################

# read Plot biome x-y table:

load("biome.xy.Rdata")
str(biome.xy)
biome.xy$PlotObserv <- as.factor(biome.xy$PlotObserv)

dim(biome.xy)

biome.xy <- biome.xy[which((biome.xy$PlotObserv %in% err)==FALSE), ]

save(biome.xy, file = "biome.xy.Rdata")

names(biome.xy)

length(unique(biome.xy$PlotObserv))

# 705813

# count number of plots within each biomes

library(data.table)
DTbiome <- data.table(biome.xy[,c(3:5,8)])
no.plots.biome <-  DTbiome[,list(No.plots = length(PlotObserv)), by=Schulz_Bio]                      #                        Schulz_Bio No.plots
#1:  1 Tropics with year-round rain     1470
#2:      2 Tropics with summer rain     5407
#3:    3 Dry tropics and subtropics     9998
#4:   4 Subtropics with winter rain    73185
#5: 5 Subtrop. with year-round rain    12179
#6:        6 Temperate midlatitudes   588419
#7:              7 Dry midlatitudes     5644
#8:                   8 Boreal zone     8133
#9:       9 Polar and subpolar zone     1378

write.csv(no.plots.biome, file = "no.plots.biome.csv")

library(dplyr)
library(reshape2)
no.plots.biome <- as.data.frame(no.plots.biome)
mdat2 <- melt(no.plots.biome, id.vars="Schulz_Bio")
head(mdat2)

library(ggplot2)

postscript(file = "NumberPlotsBiomeLog.eps", height = 4, width = 7, paper = "special", onefile = FALSE, horizontal = FALSE, pointsize=12)
#pdf("NumberSpeciesBiome.pdf", height = 4, width = 8)
ggplot(mdat2, aes(variable, log(value), fill=Schulz_Bio)) + 
  geom_bar(stat="identity", position="dodge")+
    xlab("Biomes") +
  ylab("log(Number of plots)")+
  ggtitle("Number of species per biome")
dev.off()

library(scales)

postscript(file = "NumberPlotsBiome.eps", height = 4, width = 7, paper = "special", onefile = FALSE, horizontal = FALSE, pointsize=12)
#pdf("NumberSpeciesBiome.pdf", height = 4, width = 8)
ggplot(mdat2, aes(variable, value, fill=Schulz_Bio)) + 
  geom_bar(stat="identity", position="dodge")+
      scale_y_continuous(name="Number of plots", labels = comma) +
  scale_x_discrete(name="Biomes") +
ggtitle("Number of plots per biome") 
dev.off()
                                        
# (b) wie hoch ist die Plotdichte (plots pro 100 km²) in jedem der Biome
# 

biome.area <- read.csv("/home/oliver/Dokumente/PhD/PostPhD/IDiv/sDiv/sPlot/Analyses/Data/GIS/SchulzBiomes/biome.area.csv")

str(biome.area)

DTarea <- data.table(biome.area)
area.biome <-  DTarea[,list(Area = sum(Area.N.19.11)), by=Schulz_Bio.C.31]

no.plots.biome$Area <- area.biome$Area

no.plots.biome
                        Schulz_Bio No.plots         Area
#1:  1 Tropics with year-round rain     1470 7.393349e+13
#2:      2 Tropics with summer rain     5407 5.529372e+13
#3:    3 Dry tropics and subtropics     9998 1.434031e+14
#4:   4 Subtropics with winter rain    73185 2.594170e+13
#5: 5 Subtrop. with year-round rain    12179 3.432313e+13
#6:        6 Temperate midlatitudes   588419 6.463106e+13
#7:              7 Dry midlatitudes     5644 1.565747e+13
#8:                   8 Boreal zone     8133 2.331021e+13
#9:       9 Polar and subpolar zone     1378 6.264147e+13

no.plots.biome$plot.dens <- no.plots.biome$No.plots/no.plots.biome$Area

no.plots.biome <- as.data.frame(no.plots.biome)

library(dplyr)
arrange(no.plots.biome, Area)

# (c) wie viele Arten haben wir in den Plots der Biome
# join splot with biomes
names(biome.xy)[3] <- "PlotObservationID"
biome.xy$PlotObservationID <- as.character(biome.xy$PlotObservationID)
splot.species.stand$PlotObservationID <- as.character(splot.species.stand$PlotObservationID)

any(is.na(splot.species.stand$PlotObservationID))

splot.biome <- left_join(splot.species.stand, biome.xy[,c(3:5,8)])

# export coordinates for julia joswig:
splot.xy <- biome.xy[,c(3:5)]
save(splot.xy, file = "splot.xy.Rdata")
###

DTsplot <- data.table(splot.biome)

species.biome <-  DTsplot[,list(No.spec = length(unique(StandSpeciesName))), by=Schulz_Bio]
species.biome

species.biome <- as.data.frame(species.biome)

mdat2 <- melt(species.biome, id.vars="Schulz_Bio")
head(mdat2)

postscript(file = "NumberSpeciesBiome.eps", height = 4, width = 7, paper = "special", onefile = FALSE, horizontal = FALSE, pointsize=12)
#pdf("NumberSpeciesBiome.pdf", height = 4, width = 8)
ggplot(mdat2, aes(variable, value, fill=Schulz_Bio)) + 
  geom_bar(stat="identity", position="dodge")+
    xlab("Biomes") +
  ylab("Number of species")+
  ggtitle("Number of species per biome")
dev.off()


# (d) wie ist die Trait-Abdeckung der Arten pro Biom

# number of all species within plots:
splot.biome <- left_join(splot.species.stand, biome.xy[,c(3:5,8)])
DTsplot <- data.table(splot.biome)
species.biome <-  DTsplot[,list(No.spec = length(unique(StandSpeciesName))), by=Schulz_Bio]
species.biome

# number of TRY species within plots:

splot.biome.try <- left_join(splot.species.try, biome.xy[,c(3:5,8)])
DTsplot <- data.table(splot.biome.try)
species.biome.try <-  DTsplot[,list(No.spec = length(unique(StandSpeciesName))), by=Schulz_Bio]
species.biome.try

species.biome.all.try <- cbind(species.biome, species.biome.try)
species.biome.all.try <- as.data.frame(species.biome.all.try)
species.biome.all.try <- species.biome.all.try[,-3]

names(species.biome.all.try)[2:3] <- c("no.spec.all", "no.spec.try")
species.biome.all.try$match <- 100*(species.biome.all.try$no.spec.try/species.biome.all.try$no.spec.all)

write.csv(species.biome.all.try, file = "species.biome.all.try.csv")

mdat2 <- melt(species.biome.all.try[, c(1,4)], id.vars="Schulz_Bio")
head(mdat2)

postscript(file = "TraitMatchBiome.eps", height = 4, width = 7, paper = "special", onefile = FALSE, horizontal = FALSE, pointsize=12)
#pdf("NumberSpeciesBiome.pdf", height = 4, width = 8)
ggplot(mdat2, aes(variable, value, fill=Schulz_Bio)) + 
  geom_bar(stat="identity", position="dodge")+
    xlab("Biomes") +
  ylab("Percentage match")+
  ggtitle("Match sPlot and TRY")
dev.off()

## phylogeny for splot
# load tank.tree:

library(ape)
tank.tree <- read.tree("/home/oliver/Dokumente/PhD/PostPhD/IDiv/sDiv/sPlot/Analyses/Data/Phylogeny/2/PhylogeneticResources/Vascular_Plants_rooted.dated.tre")
tank.tree$tip.label[1:10]

# prune the tree to the species in splot:
load("splot.species.stand.Rdata")
str(splot.species.stand)
length(unique(splot.species.stand$StandSpeciesName))
nam.splot <- unique(splot.species.stand$StandSpeciesName)
nam.splot[1:10]
# identify the species in splot which are not in the tank tree
# add those species are congeners

nam.splot <- gsub(" ", "_", nam.splot)
length(nam.splot) 
nam.splot[1:10]

index <- which(nam.splot %in% tank.tree$tip.label)
nam.splot[index]

index <- which(tank.tree$tip.label %in% nam.splot)

tank.tree.splot <- tank.tree[tank.tree$tip.label[index]]
str(tank.tree.splot)

tips <- 
    
tree.con <- congeneric.merge(nam.splot[20000:30000], tank.tree)
tree.con2 <- congeneric.merge(nam.splot[10000:20000], tree.con)
tree.con3 <- congeneric.merge(nam.splot[8000:10000], tree.con2)
tree.con4 <- congeneric.merge(nam.splot[6000:8000], tree.con3)


tree.con4 <- congeneric.merge(nam.splot[30011:30030], tree.con3)



tree.con4 <- congeneric.merge(nam.splot[6000:8000], tree.con3)


any(is.na(nam.splot))
length(nam.splot)


# tree grafting function by brody:
#For each species in kew, check to see if it's on the tree. If it is not,
    #graft it next to a random congener, if one exists

    #In case there's an effect of the order things are grafted, probably wise
    #to randomly reorder the i index each time
    gtree = tank.tree
spList <- nam.splot[6000:8000]
    for(i in sample(1:length(spList),length(spList),replace = F))
        {
        #Update the genus list, because new tips should be graftable onto previous new tips
        gtreeGenera = unlist(lapply(strsplit(gtree$tip,"_"),function(i){i[[1]]}))
        
        #If the species isn't on the tree but a congener is
        if(!spList[i] %in% gtree$tip & strsplit(spList[i],"_")[[1]][1] %in% gtreeGenera)
            {
            branchName = gtree$tip[resample(which(gtreeGenera == strsplit(spList[i],"_")[[1]][1]),1)]
            newtree = rtree(2)
            newtree$tip.label = c(branchName,spList[i])
           
            edgeL = gtree$edge.length[which.edge(gtree,branchName)]
           
            #Splice in at a random depth between 0 and 1
            depth = runif(1,0,1)
            newtree$edge.length = depth*newtree$edge.length*edgeL/max(newtree$edge.length)

            whereToGraft = which(gtree$tip == branchName)
            gtree = bind.tree(gtree,newtree,where = whereToGraft,position = edgeL*depth)

            #The grafting process duplicates the branchName tip. Drop one of them.
            gtree = drop.tip(gtree, which(gtree$tip == branchName)[1])

            #Just to make sure things look good throughout
            #print(paste(spList[i]," with ",branchName))
            }
        }

    # store the gtree for safety
    store = gtree

resample <- function(x, ...) x[sample.int(length(x), ...)]
###################

# CWM covariation across biomes
# load x-y coords biomes
load("biome.xy.Rdata")

dim(biome.xy)
str(biome.xy)
names(biome.xy)[3] <- "PlotObservationID"

# load CWMs
load("CWM.splot.Rdata")
str(CWM.splot)
names(CWM.splot)

library(dplyr)
biome.xy.cwm <- left_join(biome.xy[,c(3:5,8)], CWM.splot[,c(1:4)])
names(biome.xy.cwm)

library(data.table)
DTbiome <- data.table(biome.xy.cwm[,c(1,4:7)])
mean.sla.biome <-  DTbiome[,list(mean.sla.cwm = mean(CWM.SLA, na.rm=TRUE)), by=Schulz_Bio]               
mean.sla.biome

# plot covariation 
library(reshape2)
mdat2 <- melt(biome.xy.cwm[,c(4,6)], id.vars="Schulz_Bio")
mdat3 <- melt(biome.xy.cwm[,c(4,7)], id.vars="Schulz_Bio")
mat2.3 <- cbind(mdat2[,c(1,3)], mdat3[,3])
names(mat2.3)[2:3] <- c("PlantHeight", "SeedMass")
head(mat2.3)

library(ggplot2)

postscript(file = "PlantHeightSeedMassBiome.eps", height = 2.3, width = 15, paper = "special", onefile = FALSE, horizontal = FALSE, pointsize=12)
qplot(PlantHeight, SeedMass, data=mat2.3, facets = . ~ Schulz_Bio) + geom_smooth()
dev.off()

# load bioclim

library(colbycol)
bioclim <- cbc.read.table("/home/oliver/Dokumente/PhD/PostPhD/IDiv/sDiv/sPlot/Analyses/Data/Environment/Bioclim/sPlot_bioClim.csv", just.read = c(1:3))
bioclim <- as.data.frame(bioclim)

bioclim <- read.csv("/home/oliver/Dokumente/PhD/PostPhD/IDiv/sDiv/sPlot/Analyses/Data/Environment/Bioclim/sPlot_bioClim.csv", head=T)
str(bioclim)

str(biome.xy.cwm)
biome.xy.cwm$PlotObservationID <- as.factor(biome.xy.cwm$PlotObservationID)
bioclim$PlotObservationID <- as.factor(bioclim$PlotObservationID)
biome.xy.cwm <- left_join(biome.xy.cwm, bioclim[,c(1,29)])
names(biomes)
biome.xy.cwm$BIO_1 <- as.numeric(biome.xy.cwm$BIO_1)

mdat2 <- melt(biome.xy.cwm[,c(4,6)], id.vars="Schulz_Bio")
mdat3 <- melt(biome.xy.cwm[,c(4,8)], id.vars="Schulz_Bio")
mat2.3 <- cbind(mdat2[,c(1,3)], mdat3[,3])
names(mat2.3)[2:3] <- c("CWM.SLA", "MAT")
head(mat2.3)

postscript(file = "CWM.SLA.MATBiome.eps", height = 2.3, width = 15, paper = "special", onefile = FALSE, horizontal = FALSE, pointsize=12)
qplot(MAT, CWM.SLA, data=mat2.3, facets = . ~ Schulz_Bio) + geom_smooth()
dev.off()

names(mat2.3)
hist(mat2.3$MAT)

# plot phylogeny:
phylo.splot.try <- read.tree("/home/oliver/Dokumente/PhD/PostPhD/IDiv/sDiv/sPlot/Analyses/Data/Phylogeny/sPlotPhylo/phylo.tree.splot.try.11870.tre")

pdf(file = "phylo.splot.try.11870.pdf", height = 90, width = 90)
plot(phylo.splot.try, "f", cex = .1, edge.width = .3, label.offset = .1)
dev.off()

##
phylo.splot.stand <- read.tree("/home/oliver/Dokumente/PhD/PostPhD/IDiv/sDiv/sPlot/Analyses/Data/Phylogeny/sPlotPhylo/phylo.tree.splot.stand.26426.tre")

pdf(file = "phylo.tree.splot.stand.26426.pdf", height = 90, width = 90)
plot(phylo.splot.stand, "f", cex = .1, edge.width = .3, label.offset = .1)
dev.off()


################################################
# get families for the 12000 species
names(TRY.2.0.all.gapfilled.ln.acc.names)
names(TRY.2.0.all.gapfilled.ln.acc.names)

try.spec.fam <- TRY.2.0.all.gapfilled.ln.acc.names[,c(3,4)]
head(try.spec.fam) 
str(try.spec.fam) 

try.spec.fam[,1] <- as.character(try.spec.fam[,1])
try.spec.fam[,2] <- as.character(try.spec.fam[,2])

# join with backbone:

# taxonomic backbone to TRY:
backbone.small <- read.csv("backbone.small.csv")
head(backbone.small)

backbone.small$names.sPlot.TRY.original <- as.character(backbone.small$names.sPlot.TRY.original)
backbone.small$Final.names.3 <- as.character(backbone.small$Final.names.3)

str(try.spec.fam)

names(try.spec.fam)[1] <- "names.sPlot.TRY.original"

try.fam <- left_join(try.spec.fam, backbone.small)
str(try.fam)
# take try.fam[,5] # final.names.3

# merge with splot.species.try
load("splot.species.try.Rdata")
head(splot.species.try)
str(splot.species.try)

# join try.fam on unique.splot.names based on standardized names


names(splot.species.try)[2] <- "Final.names.3"
splot.species.try$Final.names.3 <- as.character(splot.species.try$Final.names.3)

str(splot.species.try)

splot.try.nam <- as.data.frame(unique(splot.species.try$Final.names.3))

names(splot.try.nam)[1] <- "Final.names.3"
splot.try.nam$Final.names.3 <- as.character(splot.try.nam$Final.names.3)

splot.try.fam <- plyr::join(splot.try.nam, splot.species.stand[,c(2,6)], match = "first")

str(splot.try.fam)
splot.try.fam[1:100,1]
head(splot.try.fam)

save(splot.try.fam, file = "splot.try.fam.Rdata")

###################
# linking TRY plant growth forms:

names(ID.names)[13:17]
unique(ID.names$LeafType) 
unique(ID.names$PlantGrowthForm) 
unique(ID.names$LeafPhenology) 
unique(ID.names$PhotosyntheticPathway) 
unique(ID.names$Woodiness) 


TRY.2.0.all.gapfilled.ln.acc.names$AccSpeciesName <- as.character(TRY.2.0.all.gapfilled.ln.acc.names$AccSpeciesName)

# just select the categorical traits
try.obs.lifeform <- TRY.2.0.all.gapfilled.ln.acc.names[, c(3,5:9)]

names(try.obs.lifeform)[1] <- "Final.names.3"

splot.try.nam2 <- cbind(splot.try.nam, splot.try.nam)


try.obs.lifeform.stand <- left_join(try.obs.lifeform, splot.try.nam)
str(try.obs.lifeform.stand)



#merge to stand.names
try.spec.cat.traits <- TRY.2.0.all.gapfilled.ln.acc.names[,c(3,5:9)]
head(try.spec.cat.traits) 
str(try.spec.cat.traits) 

names(try.spec.cat.traits)[1] <- "names.sPlot.TRY.original"

try.spec.cat.traits.stand <- left_join(try.spec.cat.traits, backbone.small)
str(try.spec.cat.traits.stand)

try.growth.stand <- try.spec.cat.traits.stand[,c(10,2)]

try.growth.stand.tab <- as.data.frame.matrix(table(try.growth.stand[,c(1,2)]))
head(try.growth.stand.tab)
str(try.growth.stand.tab)

try.growth.stand.tab$names <- rownames(try.growth.stand.tab)

# match it with the species that occur in splot and TRY:

nam.splot.try <- unique(splot.species.try$Final.names.3)
length(nam.splot.try)

nam.splot.try <- cbind(nam.splot.try, nam.splot.try)
nam.splot.try <- as.data.frame(nam.splot.try)
str(nam.splot.try)
names(nam.splot.try)[2] <- "names"
nam.splot.try$names <- as.character(nam.splot.try$names)


splot.try.gro <- left_join(nam.splot.try, try.growth.stand.tab)
str(splot.try.gro)
splot.try.gro[1:5,1:5]

splot.try.gro <- splot.try.gro[,-1]
head(splot.try.gro)
splot.try.gro[, c(1:3)]
splot.try.growthform <- splot.try.gro

save(splot.try.growthform, file = "splot.try.growthform.Rdata")


# extract TRY woodyness information
# (and for other categorical traits)

try.woody.stand <- try.spec.cat.traits.stand[,c(10,6)]
str(try.woody.stand)
unique(try.woody.stand$Woodiness)

index.na <- which(try.woody.stand$Woodiness=="")
try.woody.stand$Woodiness[index.na] <- NA

try.woody.stand$Woodiness <- as.character(try.woody.stand$Woodiness)

index.non.woody <- which(try.woody.stand$Woodiness=="non-woody/woody rootstock")
try.woody.stand$Woodiness[index.non.woody] <- "non.woody"
unique(try.woody.stand$Woodiness)
head(try.woody.stand)

names(try.woody.stand)[1] <- "names.sPlot.TRY.original"
summary(try.woody.stand)
str(try.woody.stand)

try.spec.woody.traits.stand <- try.woody.stand
# merge with sPlot-species list:
try.spec.woody.traits.stand <- left_join(try.spec.woody.traits.stand, backbone.small)
str(try.spec.woody.traits.stand)

try.woody.stand <- try.spec.woody.traits.stand[,c(6,2)]
str(try.woody.stand)

# match it with the species that occur in splot and TRY:

nam.splot.try <- unique(splot.species.try$Final.names.3)
length(nam.splot.try)

nam.splot.try <- cbind(nam.splot.try, nam.splot.try)
nam.splot.try <- as.data.frame(nam.splot.try)
str(nam.splot.try)
names(nam.splot.try)[2] <- "names"
nam.splot.try$names <- as.character(nam.splot.try$names)

head(nam.splot.try)
str(nam.splot.try)


names(nam.splot.try)[2] <- "Final.names.3"
splot.try.wood <- plyr::join(nam.splot.try, try.woody.stand, match = "first")

str(splot.try.wood)
head(splot.try.wood)

# create two splot files: 
# 1) splot.woody
# 2) splot.non.woody

str(splot.species.try)

# woody
index.splot.wood <- which(splot.species.try$Final.names.3 %in% splot.try.wood$Final.names.3[splot.try.wood$Woodiness == "woody"])
length(index.splot.wood)

splot.species.try.woody <- splot.species.try[index.splot.wood, ]
head(splot.species.try.woody)

save(splot.species.try.woody, file = "splot.species.try.woody.Rdata")


# non.woody
index.splot.non.wood <- which(splot.species.try$Final.names.3 %in% splot.try.wood$Final.names.3[splot.try.wood$Woodiness == "non.woody"])
length(index.splot.non.wood)

splot.species.try.non.woody <- splot.species.try[index.splot.non.wood, ]
head(splot.species.try.non.woody)

save(splot.species.try.non.woody, file = "splot.species.try.non.woody.Rdata")

# 3) percentage of woody species in a plot

##  to do

# 13693421  
load("TRY.mean.sd.splot.Rdata")
load("splot.species.try.non.woody.Rdata")
dim(TRY.mean.sd.splot)
str(splot.species.try.non.woody)
names(splot.species.try.non.woody)[2] <- "StandSpeciesName"

library(dplyr)
splot.try <- left_join(splot.species.try.non.woody, TRY.mean.sd.splot[,c(1,3:20)])
gc()
dim(splot.try)
head(splot.try)
names(splot.try)

library(data.table)
DT <- data.table(splot.try[,c(1,3:21)])
head(DT)
gc()
tables()

CWM.splot.non.woody <-  DT[,list(CWM.SLA.non.woody = weighted.mean(SLA.mean, Cover..), 
                       CWM.PlantHeight.non.woody = weighted.mean(PlantHeight.mean, Cover..), 
                       CWM.SeedMass.non.woody = weighted.mean(SeedMass.mean, Cover..),
                       CWM.LDMC.non.woody = weighted.mean(LDMC.mean, Cover..),
                       CWM.StemDens.non.woody = weighted.mean(StemDens.mean, Cover..),
                       CWM.LeafArea.non.woody = weighted.mean(LeafArea.mean, Cover..),
                       CWM.LeafN.non.woody = weighted.mean(LeafN.mean, Cover..),
                       CWM.LeafP.non.woody = weighted.mean(LeafP.mean, Cover..),
                       CWM.LeafNperArea.non.woody = weighted.mean(LeafNperArea.mean, Cover..),
                       CWM.Leaffreshmass.non.woody = weighted.mean(Leaffreshmass.mean, Cover..),
                       CWM.LeafNPratio.non.woody = weighted.mean(LeafNPratio.mean, Cover..),
                       CWM.LeafC.perdrymass.non.woody = weighted.mean(LeafC.perdrymass.mean, Cover..),
                       CWM.Leaf.delta.15N.non.woody = weighted.mean(Leaf.delta.15N.mean, Cover..),
                       CWM.Stem.cond.dens.non.woody.non.woody = weighted.mean(Stem.cond.dens.mean, Cover..),
                       CWM.Seed.num.rep.unit.non.woody = weighted.mean(Seed.num.rep.unit.mean, Cover..),
                       CWM.Wood.vessel.length.non.woody = weighted.mean(Wood.vessel.length.mean, Cover..),
                       CWM.Seed.length.non.woody = weighted.mean(Seed.length.mean, Cover..),
                       CWM.Disp.unit.leng.non.woody = weighted.mean(Disp.unit.leng.mean, Cover..)

                       ), 
                 
                 by=PlotObservationID]


str(CWM.splot.non.woody)
dim(CWM.splot.non.woody)
CWM.splot.non.woody <- as.data.frame(CWM.splot.non.woody)
save(CWM.splot.non.woody, file = "CWM.splot.non.woody.Rdata")
write.csv(CWM.splot.non.woody, file = "CWM.splot.non.woody.csv")


# join splot.try with woody.non.woody CWM
# seperate file for bioclim for the same plots:
load("CWM.splot.woody.Rdata")
load("CWM.splot.non.woody.Rdata")
load("CWM.splot.Rdata")

load("splot.species.try.Rdata")
load("TRY.mean.sd.splot.Rdata")

names(splot.species.try)
names(TRY.mean.sd.splot)
names(CWM.splot)
dim(CWM.splot)

dim(splot.species.try)

gc()
library(dplyr)
CWM.wood <- left_join(CWM.splot[,c(1:2)], CWM.splot.woody)
dim(CWM.wood)

CWM.wood.non.wood <- left_join(CWM.wood, CWM.splot.non.woody)
gc()

CWM.wood.non.wood <- CWM.wood.non.wood[,c(-2)]
save(CWM.wood.non.wood, file = "CWM.wood.non.wood.Rdata")


dim(CWM.wood.non.wood)
names(CWM.wood.non.wood)
CWM.wood.non.wood


# match bioclim to woody-non.woody:

bioclim <- read.csv("/home/oliver/Dokumente/PhD/PostPhD/IDiv/sDiv/sPlot/Analyses/Data/Environment/Bioclim/sPlot_bioClim_temp_prec.csv", sep ="\t")
str(bioclim)
dim(bioclim)
bioclim$PLOTOBSERV <- as.character(bioclim$PLOTOBSERV)

names(bioclim)[1] <- "PlotObservationID"

index <- which(bioclim$PlotObservationID %in% CWM.wood.non.wood$PlotObservationID)

bioclim.woody.non.woody <- bioclim[index, ]
dim(bioclim.woody.non.woody)

save(bioclim.woody.non.woody, file = "bioclim.woody.non.woody.Rdata")
load("bioclim.woody.non.woody.Rdata")
names(bioclim.woody.non.woody)


## sPlot 2.0 
library(data.table)
path.sPlot <- "/home/oliver/Dokumente/PhD/PostPhD/IDiv/sDiv/sPlot/Analyses/Data/Species/sPlot/sPlot_14_04_2015/"

# read species data (takes ~2 min on my 64bit, 2.5GHz machine)

splot.species.DT <- fread("/home/oliver/Dokumente/PhD/PostPhD/IDiv/sDiv/sPlot/Analyses/Data/Species/sPlot/sPlot_14_04_2015/sPlot_14_4_2015_species.csv", sep )
dim(splot.species.DT)
head(splot.species.DT)

splot.species <- read.csv(paste(path.sPlot, "sPlot_14_4_2015_species.csv", sep = ""), sep = "\t")
gc()
dim(splot.species)
length(unique(splot.species$PlotObservationID))
# 24.241.941       11

# old
# 24.235.008
summary(splot.species)
str(splot.species)

colnames(splot.species)
length(unique(splot.species$Turboveg2.concept))
# 93917
length(unique(splot.species$Matched.concept))
# 87424

splot.species$Turboveg2.concept <- as.character(splot.species$Turboveg2.concept)
splot.species$Matched.concept<- as.character(splot.species$Matched.concept)



Match.conc.unique <- cbind(sort(unique(splot.species$Matched.concept)), unique(splot.species$Matched.concept))

colnames(Match.conc.unique) <- c("Match.conc.sort", "Match.conc")

head(Match.conc.unique)
dim(Match.conc.unique)

write.csv(Match.conc.unique, file = "Match.conc.unique.csv")

# in european data, check for differences between TV.2 names and matched concept:

paste(unique(splot.species$Taxonomy)[62:89], sep = "")


splot.species.euro <- splot.species[which(splot.species$Taxonomy %in% unique(splot.species$Taxonomy)[62:89]), ]

splot.eur.sample <- splot.species.euro[sample(1:20159421, 100000), c(2,5,6)]


write.csv(splot.eur.sample, file = "splot.eur.sample.csv")


dim(splot.species.euro)

colnames(splot.species.euro)


# extract excerpt from sPlot Europe:

Europe                      
[63] Austria                      Balkan                      
[65] Euskadi                      Floranld_2013               
[67] Britain                      Bulgaria                    
[69] Croatia                      C_Europe_Croatia            
[71] Czechia_slovakia_2010        Europe_lenoir               
[73] France_sophy                 Germansl 1.2                
[75] Greece                       Natura                      
[77] C_Europe_Hungary             Italy_conti                 
[79] Latvia                       Lithuania                   
[81] C_Europe_Macedonia           Poland                      
[83] Romania                      C_Europe_Serbia             
[85] Slovenia                     Spain_sivim                 
[87] Switzerland                  Turkey                      
[89] Vegitaly       

# import "weird species" list:

weird.names <- read.csv("/home/oliver/Dokumente/PhD/PostPhD/IDiv/sDiv/sPlot/Analyses/Code/Weird.names.match.conc.csv", colClasses = "character")

weird.names.unique <- unique(weird.names)

write.csv(weird.names.unique, file = "splot.weird.names.csv")

dim(weird.names.unique)
str(weird.names.unique)

splot.species.weird <- splot.species[which(splot.species$Matched.concept %in% weird.names.unique$weird.names), c(1,2,6,9)]

head(splot.species.weird)
tail(splot.species.weird)

dim(splot.species.weird)


splot.species.weird[1:100,1:3]

write.csv(splot.species.weird, file = "splot.species.weird.csv")

splot.species[c(675115,675145,675192), c(1,2,6,9)]


#####################  


### load header data:

path.sPlot <- "/home/oliver/Dokumente/PhD/PostPhD/IDiv/sDiv/sPlot/Analyses/Data/Species/sPlot/sPlot_14_04_2015/"

# read species data (takes ~2 min on my 64bit, 2.5GHz machine)
splot.header <- read.csv(paste(path.sPlot, "sPlot_header_no_locality.csv", sep = ""), sep = "\t", quote = "")

splot.header.DT <- fread(paste(path.sPlot, "sPlot_header_no_locality.csv", sep = ""))
                      
dim(splot.header.DT)
                  
gc()
                      
dim(splot.header)
length(unique(splot.header$PlotObservationID))
# 24.241.941       11

# old
# 24.235.008
summary(splot.header)
str(splot.header)
colnames(splot.header)

library(colbycol)

splot.header <- cbc.read.table("/home/oliver/Dokumente/PhD/PostPhD/IDiv/sDiv/sPlot/Analyses/Data/Species/sPlot/sPlot_13_04_2015/sPlot_13_04_2015_header.csv", just.read = c(1,2))
splot.header <- as.data.frame(splot.header)
dim(splot.header)


require(data.table)
DT <- fread("/home/oliver/Dokumente/PhD/PostPhD/IDiv/sDiv/sPlot/Analyses/Data/Species/sPlot/sPlot_14_04_2015/sPlot_14_04_2015_header.csv")


test <- read.csv2(file("/home/oliver/Dokumente/PhD/PostPhD/IDiv/sDiv/sPlot/Analyses/Data/Species/sPlot/sPlot_14_04_2015/sPlot_14_04_2015_header.csv", encoding="UTF-8"), sep = "\t")

dim(test)


## Stephan's header import test

library(data.table)
path.sPlot <- "/home/oliver/Dokumente/PhD/PostPhD/IDiv/sDiv/sPlot/Analyses/Data/Species/sPlot/sPlot_14_04_2015/"
splot.header <- fread(paste(path.sPlot, "sPlot_header.csv", sep = "", sep2 = ""))
nrow(splot.header)

system.time(
splot.header <- read.csv(paste(path.sPlot, "sPlot_header.csv", sep = ""), sep = "\t", na.strings=c("","NA"), fileEncoding = "UTF-8", quote = "")
    )
nrow(splot.header)


###########################################################
## generate taxonomic backbone for sPlot 2.0 and TRY 3.0
##

# 1) combine unique names lists of species in sPlot 2.0 and TRY 3.0:combine unique names lists of species in sPlot 2.0 and TRY 3.0:
# first check whether some of the weird names can be resolved -> no, not really

splot.species <- read.csv(paste(path.sPlot, "sPlot_14_4_2015_species.csv", sep = ""), sep = "\t")
gc()

dim(splot.species)
length(unique(splot.species$PlotObservationID))
# 24.241.941       11

# old
# 24.235.008
summary(splot.species)
str(splot.species)

colnames(splot.species)
length(unique(splot.species$Turboveg2.concept))
# 93917
length(unique(splot.species$Matched.concept))
# 87424

splot.species$Turboveg2.concept <- as.character(splot.species$Turboveg2.concept)
splot.species$Matched.concept<- as.character(splot.species$Matched.concept)

# read in TRY 3.0 species list
try3.species <- read.csv("/home/oliver/Dokumente/PhD/PostPhD/IDiv/sDiv/sPlot/Analyses/Data/Species/TRY/Species/TRY30_Gapfilling2015_Species.csv")
str(try3.species)
try3.species$Species <- as.character(try3.species$Species)

# combine species lists into one unified species list:
spec.list.TRY.sPlot <- sort(unique(c(as.character(splot.species$Matched.concept), as.character(try3.species$Species))))
length(spec.list.TRY.sPlot)
# 122901

spec.list.TRY.sPlot.2 <- cbind(spec.list.TRY.sPlot, spec.list.TRY.sPlot, spec.list.TRY.sPlot)
str(spec.list.TRY.sPlot.2)
dim(spec.list.TRY.sPlot.2)
spec.list.TRY.sPlot.2 <- as.data.frame(spec.list.TRY.sPlot.2)

spec.list.TRY.sPlot.2[,1] <- as.character(spec.list.TRY.sPlot.2[,1])
spec.list.TRY.sPlot.2[,2] <- as.character(spec.list.TRY.sPlot.2[,2])
spec.list.TRY.sPlot.2[,3] <- as.character(spec.list.TRY.sPlot.2[,3])

colnames(spec.list.TRY.sPlot.2) <- c("names.sPlot.TRY", "names.corr.string", "sPlot.TRY")
write.csv(spec.list.TRY.sPlot.2, file = "spec.list.TRY3.sPlot2.csv")

# 2) add information on whether names come from sPlot (1), TRY (0) or both (2)

# which species are in sPlot 2.0
spec.list.TRY.sPlot.2$sPlot.TRY[which(spec.list.TRY.sPlot.2$names.sPlot.TRY %in% unique(splot.species$Matched.concept))] <- "S"

# which species are in TRY 3.0
spec.list.TRY.sPlot.2$sPlot.TRY[which(spec.list.TRY.sPlot.2$names.sPlot.TRY %in% unique(try3.species$Species))] <- "T"

# which species are in sPlot 2.0 and TRY 3.0

spec.list.TRY.sPlot.2$sPlot.TRY[which(spec.list.TRY.sPlot.2$names.sPlot.TRY %in% unique(try3.species$Species) & spec.list.TRY.sPlot.2$names.sPlot.TRY %in% unique(splot.species$Matched.concept))] <- "ST"

table(spec.list.TRY.sPlot.2$sPlot.TRY)

#   S    ST     T 
# 62628 24796 35477 

write.csv(spec.list.TRY.sPlot.2, file = "spec.list.TRY3.sPlot2.csv")

spec.list.TRY.sPlot.2 <- read.csv("spec.list.TRY3.sPlot2.csv")

# 3) do some rough a-priori cleaning
# also check Florian's files again on weird species names: does it take care of:
# - voucher species (contain)
# - cf. species
# - species with strange brackets and special characters

# some code from Florian Jansen:
# check for weird.names.csv first
splot.weird.names <- read.csv("/home/oliver/Dokumente/PhD/PostPhD/IDiv/sDiv/sPlot/Analyses/Code/splot.weird.names.csv")
str(splot.weird.names)

OriginalNames <- as.character(spec.list.TRY.sPlot.2$names.sPlot.TRY)
OriginalNames <- as.character(splot.weird.names$weird.names)
####
# get the non-matching species for sPlot July 2015 that do not match with the backbone for April 2015:
####
miss <- read.csv("/home/oliver/Dokumente/PhD/PostPhD/IDiv/sDiv/sPlot/Analyses/Code/Mismatches_29_07_2015.csv")
miss.new <- read.csv("/home/oliver/Dokumente/PhD/PostPhD/IDiv/sDiv/sPlot/Analyses/Code/Mismatches_29_07_2015_new.csv")

# check again mismatches with old backbone: (14:50-15.15):
library(data.table)
splot.species <- fread("/home/oliver/Dokumente/PhD/PostPhD/IDiv/sDiv/sPlot/Analyses/Data/Species/sPlot/sPlot_29_07_2015/sPlot_2015_07_29_species.csv")
dim(splot.species) # 23586216 entries
str(splot.species)
colnames(splot.species)[6] <- "Matched_concept"
length(unique(splot.species$PlotObservationID)) # 1121244 plots

splot.species <- fread("/home/oliver/Dokumente/PhD/PostPhD/IDiv/sDiv/sPlot/Analyses/Data/Species/sPlot/sPlot_29_07_2015/sPlot_2015_07_29_species.csv")

# read in header data:
splot.header <- fread("/home/oliver/Dokumente/PhD/PostPhD/IDiv/sDiv/sPlot/Analyses/Data/Species/sPlot/sPlot_29_07_2015/sPlot_2015_07_29_header.csv")
dim(splot.header)
colnames(splot.header)
# 
splot.header <- as.data.frame(splot.header)
splot_29_07_2015_coords <- splot.header[,c(2,40,41)]
head(splot_29_07_2015_coords)

write.csv(splot_29_07_2015_coords, file = "splot_29_07_2015_coords.csv")

# get backbone:
load("/home/oliver/Dokumente/PhD/PostPhD/IDiv/sDiv/sPlot/Analyses/Data/Data_Helge/backbone.v.2.splot.try3.Rdata")
str(backbone.splot.try3)


missing <- splot.species$Matched_concept[splot.species$Matched_concept %in% backbone.splot.try3$names.sPlot.TRY==F]
miss.new <- (unique(missing))

OriginalNames <- miss.new


str(miss)
dim(miss)
OriginalNames <- as.character(miss.new$x)

source('tax_add.r')
source('TPLck.r')
source('gbif_parse.r')
require(pbapply)
options(stringsAsFactors=FALSE)

## Name cleaning (spelling of ranks, name additions etc.)
OriginalNames <- gsub('*', '', OriginalNames, fixed=TRUE)
OriginalNames <- gsub('cf. ', '', OriginalNames, fixed=TRUE)
OriginalNames <- gsub('Cf. ', '', OriginalNames, fixed=TRUE)
OriginalNames <- gsub('[', '', OriginalNames, fixed=TRUE)
OriginalNames <- gsub(']', '', OriginalNames, fixed=TRUE)
OriginalNames <- gsub(' x ', ' ', OriginalNames, fixed=TRUE)
OriginalNames <- gsub('Ã—', '', OriginalNames, fixed=TRUE)
OriginalNames <- gsub('aff ', '', OriginalNames, fixed=TRUE)
OriginalNames <- gsub('(', '', OriginalNames, fixed=TRUE)
OriginalNames <- gsub(')', '', OriginalNames, fixed=TRUE)
OriginalNames <- gsub(' cf ', ' ', OriginalNames, fixed=TRUE)
OriginalNames <- gsub(' aff. ', ' ', OriginalNames, fixed=TRUE)
OriginalNames <- gsub('c‚e', 'ceae', OriginalNames, fixed=TRUE)
OriginalNames <- gsub('    ', ' ', OriginalNames, fixed=TRUE)
OriginalNames <- gsub('   ', ' ', OriginalNames, fixed=TRUE)
OriginalNames <- gsub('  ', ' ', OriginalNames, fixed=TRUE)
OriginalNames <- gsub('x-', '', OriginalNames, fixed=TRUE)
OriginalNames <- gsub('X-', '', OriginalNames, fixed=TRUE)
OriginalNames <- gsub('like ', '', OriginalNames, fixed=TRUE)  
OriginalNames <- gsub(',', '', OriginalNames, fixed=TRUE)  


library(stringr)
firstWordWithNumbers <- grepl('[0-9]', word(OriginalNames, 1))
numberOfWords <- sapply(gregexpr("\\W+", OriginalNames), length) + 1
OriginalNames[firstWordWithNumbers & numberOfWords > 1] <- sapply(OriginalNames[firstWordWithNumbers & numberOfWords > 1], function(x) substr(x, start=regexpr(pattern =' ', text=x)+1, stop=nchar(x)))

write.csv(CleanedNames[1:4000], file = "CleanedNames1.csv")
write.csv(CleanedNames[4001:7701], file = "CleanedNames2.csv")
# CleanedNames[5942] # "\"Herzblatt"
CleanedNames[5942] <- "Herzblatt"
write.csv(CleanedNames, file = "CleanedNames.csv")

CleanedNames <- taxname.abbr(OriginalNames)

dup <- duplicated(CleanedNames)
sum(dup)

noDup <- iconv(CleanedNames[!dup], 'UTF-8', 'UTF-8', sub='')
## Name parsing by GBif name parser (http://www.gbif.org/developer/species#parser)
# ParsedNames <- gbif_parse(noDup[1:length(noDup)])
ParsedNames1 <- gbif_parse(noDup[1:40000])
ParsedNames2 <- gbif_parse(noDup[40001:length(noDup)])
intersect <- c("scientificName", "type", "authorsParsed","canonicalName", "canonicalNameWithMarker", "canonicalNameComplete","genusOrAbove","specificEpithet", "infraSpecificEpithet", "rankMarker", "notho", "sensu", "authorship", "infraGeneric","cultivarEpithet")
ParsedNames <- rbind(ParsedNames1[,intersect], ParsedNames2[,intersect])
write.csv(ParsedNames, file='ParsedNames.csv')
# write.csv(ParsedNames1, file='ParsedNames.csv')


table(ParsedNames$type)
## Fuzzy name matching by GBIF name matching for not wellformed
notwellformed <- ParsedNames$type != 'WELLFORMED'

matchednames <- gbif_match(ParsedNames$scientificName[notwellformed])

ParsedNames3 <- gbif_parse(matchednames)

combined <- ParsedNames
combined[notwellformed,] <- ParsedNames3[notwellformed,]
GBIF_Names <- cbind(OriginalNames[!dup], CleanedNames[!dup], combined)
GBIF_Names <- GBIF_Names[GBIF_Names$OriginalNames[!dup] != '',]
write.csv(GBIF_Names, file='GBIF_Names.csv')
# there is a problem here, species and genus names do not match up

GBIF_Names <- read.csv('GBIF_Names.csv')
genus = as.character(GBIF_Names$genusOrAbove)
species = as.character(GBIF_Names$specificEpithet[!is.na(GBIF_Names$specificEpithet)])
# infrasp = as.character(ParsedNames$infraSpecificEpithet) ## no infraspecific differenciation
genus = as.character(ParsedNames$genusOrAbove)
species = as.character(ParsedNames$specificEpithet)

# here comes the TPL bit
d <- paste(genus, species)
tpl <- do.call("rbind", pblapply(d, TPLck, corr = FALSE, diffchar = 2, max.distance = 1, infra = FALSE, version = '1.1', encoding = "UTF-8"))

table(tpl$Plant.Name.Index)

# Friday:
# test whether TNRS (and associated probabilies) can be taken instead of all the GBIF cleaning steps above
# ! it seems that sending a "string-cleaned" to TNRS does a much better job than doing the single GBIF cleaning steps above

# correct some species that cause TPL to crash manually:
spec.list.TRY.sPlot[which(spec.list.TRY.sPlot[,2]=="Astragalus psoraloides"),2] <- "Astragalus gjunaicus"
spec.list.TRY.sPlot[which(spec.list.TRY.sPlot[,2]=="Hedysarum mackenzii"),2] <- "Hedysarum dasycarpum"

# run TNRS


##
CleanedNames[which(CleanedNames=="Astragalus psoraloides")] <- "Astragalus gjunaicus"
CleanedNames[which(CleanedNames=="Hedysarum mackenzii")] <- "Hedysarum dasycarpum"

save(CleanedNames, file = "CleanedNames.Rdata")
write.csv(CleanedNames, file = "CleanedNames.csv")

# slice CleanedNames into chunks for TNRS:
# for 10,000 species
seq1 <- seq(from =1, to = 120001, 10000)
seq2 <- seq(from =10000, to = 130000, 10000)

# for 5000 species
seq1 <- seq(from =1, to = 120001, 5000)
seq2 <- seq(from =5000, to = 125000, 5000)

cbind(seq1,seq2)

# cbind(seq1, seq2)
library(foreach)

for(i in 1:length(seq1)) {
    write.csv(TNRS.TPL.2$TNRS.Name_submitted[seq1[i]:seq2[i]], file = paste(paste("tnrs_submit", seq1[i], sep = "_"), "csv", sep = "."))
}

# read in TNRS tables 

library(doParallel)
# Find out how many cores are available (if you don't already know)
detectCores()
# Create cluster with desired number of cores
cl <- makeCluster(3)

# Register cluster
registerDoParallel(cl)

# Find out how many cores are being used
getDoParWorkers()

# based on all sources
setwd("/home/oliver/Downloads/")

library(data.table)
x <- foreach(i = 1:length(seq1), .combine = rbind) %dopar% {
  read.table(paste(paste("tnrs.tpl", seq1[1], sep = "."), "txt", sep = "."))
}

library(data.table)

system.time(
    x <- foreach(i = 1:length(seq1), .combine = rbind) %dopar% {
    read.csv(paste(paste("/home/oliver/Downloads/tnrs.tpl", seq1[i], sep = "."), "csv", sep = "."), sep = ",", stringsAsFactors = FALSE, skip = 0, head = T)[-1, ]
}
    )

tnrs.tpl <- x

x <- read.csv(paste(paste("/home/oliver/Downloads/tnrs.tpl", seq1[24], sep = "."), "csv", sep = "."), sep = ",", stringsAsFactors = FALSE, skip = 0, head = T)[-1, ]
dim(x)
names(x)
x[1:10, c(2,37)]

write.csv(tnrs.tpl, file = "tnrs.tpl.csv")
save(tnrs.tpl, file = "tnrs.tpl.Rdata")

load("tnrs.tpl.Rdata")

###
# tpl output for non-matching species in 29_7_2015 output
###

tnrs.tpl.new <- read.csv("/home/oliver/Downloads/missing_tpl.txt", sep = "\t", stringsAsFactors = FALSE, skip = 0, head = T)[-1, ]
str(tnrs.tpl.new)

# check whether the submitted list for all sources 


##
#################################
library(taxize)
library(Taxonstand)

load("CleanedNames.Rdata")

str(CleanedNames)

system.time(
tnrs1 <- tnrs(query = CleanedNames[1:20000], source = "iPlant_TNRS")#[ , -c(5:7)]
    )
write.csv(tnrs1[ , c(1,2,4,5)], file = "tnrs1.csv")

###################################

system.time(
tnrs2 <- tnrs(query = CleanedNames[20001:40000], source = "iPlant_TNRS")#[ , -c(5:7)]
    )
write.csv(tnrs2[ , c(1,2,4,5)], file = "tnrs2.csv")

###################################
system.time(
    tnrs3 <- tnrs(query = CleanedNames[40001:60000], source = "iPlant_TNRS")#[ , -c(5:7)]
    )
write.csv(tnrs3[ , c(1,2,4,5)], file = "tnrs3.csv")
            
###################################
system.time(
    tnrs4 <- tnrs(query = CleanedNames[60001:80000], source = "iPlant_TNRS")#[ , -c(5:7)]
    )
write.csv(tnrs4[ , c(1,2,4,5)], file = "tnrs4.csv")

###################################
system.time(
    tnrs5 <- tnrs(query = CleanedNames[80001:100000], source = "iPlant_TNRS")#[ , -c(5:7)]
    )
write.csv(tnrs5[ , c(1,2,4,5)], file = "tnrs5.csv")
    
###################################
system.time(
    tnrs6 <- tnrs(query = CleanedNames[100001:122901], source = "iPlant_TNRS")#[ , -c(5:7)]
    )
write.csv(tnrs6[ , c(1,2,4,5)], file = "tnrs6.csv")

###################################

##
sp1 <- TPLck("Liliopsida", corr=TRUE, diffchar = 1, max.distance=1)
sp1


# what about species names that cannot be resolved by TNRS but that can be resolved by TPL?
# (e.g. Potentilla rhenana or Potentilla ikonokovii)
# in that case (where TNRS reduces and valid or mispelled name to a genus taxon), we need to run "CleanedNames" again against TPL

# error in tnrs2 and tnrs3 -> run in chunks of 1000

#####################################################

library(taxize)
library(Taxonstand)

load("CleanedNames.Rdata")

tnrs <- tnrs(query = CleanedNames[1:100], source = "iPlant_TNRS")[ , c(1,2,4,5)]

for (i in seq(from =50001, to = 60000, 1000)){
    nam <- CleanedNames[i:(i+999)]
    tnrs <- tnrs(query = nam, source = "iPlant_TNRS")[ , c(1,2,4,5)]
    write.csv(tnrs, paste(paste("tnrs.chunk", i), ".csv"))
}

######################################################

# 4) read in and combine tnrs tables (17.30-17.45)

tab <- NA
for (i in seq(from =20001, to = 59001, 1000))
{
    tab <- rbind(tab, read.csv(paste(paste("tnrs.chunk", i), ".csv")))
}

tnrs1 <- read.csv("tnrs1.csv")
tnrs4 <- read.csv("tnrs4.csv")
tnrs5 <- read.csv("tnrs5.csv")
tnrs6 <- read.csv("tnrs6.csv")

tab2 <- rbind(tnrs1, tab, tnrs4, tnrs5, tnrs6)

head(tab2)
str(tab2)
dim(tab2)

tab2$submittedname <- as.character(tab2$submittedname)
tab2$acceptedname <- as.character(tab2$acceptedname)
tab2$matchedname <- as.character(tab2$matchedname)

# 5) link cleaned names to backbone (cbind) check whether dataframes match

length(CleanedNames)
str(CleanedNames)

CleanedNames.df <- as.data.frame(CleanedNames, stringsAsFactors=FALSE)

spec.list.TRY.sPlot.2 <- read.csv("spec.list.TRY3.sPlot2.csv")
str(spec.list.TRY.sPlot.2)

spec.list.TRY.sPlot.3 <- cbind(spec.list.TRY.sPlot.2, CleanedNames.df)
dim(spec.list.TRY.sPlot.3)
# 122901
head(spec.list.TRY.sPlot.3)

spec.list.TRY.sPlot.3 <- spec.list.TRY.sPlot.3[,c(2,4,5)]
spec.list.TRY.sPlot.3[1100:1120,]

spec.list.TRY.sPlot.3$names.sPlot.TRY <- as.character(spec.list.TRY.sPlot.3$names.sPlot.TRY)

# 6) link TNRS names to cleaned names in backbone
# give informative colnames
colnames(tab2)[2] <- "CleanedNames"

library(dplyr)

spec.list.TRY.sPlot.TNRS <- anti_join(spec.list.TRY.sPlot.3, tab2)
dim(spec.list.TRY.sPlot.TNRS)

spec.list.TRY.sPlot.TNRS[1000:1100,c(1,3)]

# 122901 CleanedNames in the backbone
# of the 122901 submitted cleaned names 118471 were returned when running against TNRS
# what about the 4430 non-returned species? (check which of the submitted CleanedNames are not in the TNRS output?)

tab2$CleanedNames[which(tab2$CleanedNames %in% spec.list.TRY.sPlot.3$CleanedNames==F)]

# why are there 600 species names in 

# also, after merging, why are there 122499 in the merged (or inner_join) dataset (check which species are missing)

# Are all 

# Check whether all  

# 7) run "matched" TNRS names against TPL


# Monday: 
# - because TNRS does not names for all submitted, run TNRS on those that were not matched
# - further checking and cleaning
# - add family information
#  Leontodonhispidulus
# ABIESNORDMANNIANA


# check why tnrs function cannot connect to server

############################################################
## TNRS for the non-resolved names (maybe better to turn TPL and TNRS around)

# to do: sent in 100 species on 6 cores (later try 12 cores)

library(RCurl)
library(RJSONIO)

#noTPL.names <- paste(d, collapse=',')
noTPL.names <- paste(CleanedNames[20100:20200], collapse=',')
noTPL.names <- noTPL.names[!is.na(noTPL.names)]
#The string needs to be URL-encoded
noTPL.names <- curlEscape(noTPL.names)
#Send a request to the TNRS service
tnrs.api <- 'http://tnrs.iplantc.org/tnrsm-svc'
url <- paste(tnrs.api,'/matchNames?retrieve=best&names=', noTPL.names, sep='')
tnrs.json <- getURL(url)
# The response needs to be converted from JSON
tnrs.results <- fromJSON(tnrs.json)

dim(tnrs.results$items)
write.csv(tnrs.results$items, file = "tnrs.test300.csv")

# The corrected names are extracted from the response
names <- sapply(tnrs.results[[1]], function(x) c(x$nameSubmitted, x$acceptedName))

## try on 3 cores:

library(taxize)
library(Taxonstand)

load("CleanedNames.Rdata")
length(CleanedNames)

# try to run code on multiple cores
library(doParallel)
# Find out how many cores are available (if you don't already know)
detectCores()
# Create cluster with desired number of cores
cl <- makeCluster(3)

# Register cluster
registerDoParallel(cl)

# Find out how many cores are being used
getDoParWorkers()

# Use the rbind function to combine results

seq1 <- seq(from =1, to = 122901, 100)
seq2 <- seq(from =100, to = 123000, 100)

cbind(seq1, seq2)

## script partly borrowed by Florian Jansen

library(RCurl)
library(RJSONIO)

tnrs.api <- 'http://tnrs.iplantc.org/tnrsm-svc'
url <- paste(tnrs.api,'/matchNames?retrieve=best&names=', names, sep='')
tnrs.json <- getURL(url)

x <- foreach(i = 3:4, .combine = rbind) %dopar% { 
  require(RCurl)
  require(RJSONIO)                                         
  names <- paste(CleanedNames[seq1[i]:seq2[i]], collapse=',')
  names <- RCurl::curlEscape(names)
  tnrs.api <- 'http://tnrs.iplantc.org/tnrsm-svc'
  url <- paste(tnrs.api,'/matchNames?retrieve=best&names=', names, sep='')
  tnrs.json <- RCurl::getURL(url)
  tnrs.results <- jsonlite::fromJSON(tnrs.json)
  tnrs.results <- as.data.frame(tnrs.results$items[,c(2,4)])
  #return(as.data.frame(tnrs.results$items[,c(2,4)])) 
}

tnrs <- tnrs(query = CleanedNames[1:10], source = "iPlant_TNRS")[ , c(1,2,4,5)]


###  proper taxonomic backbone (final steps):
# TNRS crashed, check again 2pm
# 1) generate new cleaned list, one with and one without number as first word

# make sure that if the first word contains a number, append this word in []

# check whether strings got messed up in Jürgen's corrected names file:
weird.correct <- read.csv("weird.names_JD.csv")
weird.correct[1250:1253,]

OriginalNames[OriginalNames=="[ms644 Gentianac‚e schwach rosa]"]

OriginalNames[76578]

#OriginalNames.small <- OriginalNames[c(3:6, 100:105, 76484:76490)]

library(stringr)

# identify the orginal names that contain a number in their first word:
firstWordWithNumbers <- grepl('[0-9]', word(OriginalNames, 1))
# count the number of words:
numberOfWords <- sapply(gregexpr("\\W+", OriginalNames), length) + 1
# if first word has numbers put it in [] after the full names
OriginalNames[firstWordWithNumbers & numberOfWords > 1] <- paste(OriginalNames[firstWordWithNumbers & numberOfWords > 1],  " [", word(OriginalNames[firstWordWithNumbers & numberOfWords > 1], 1), "]", sep = "")

# for original names that have a number in their first word and which word count exceeds 1, only keep stuff that comes after that number:
OriginalNames[firstWordWithNumbers & numberOfWords > 1] <- sapply(OriginalNames[firstWordWithNumbers & numberOfWords > 1], function(x) substr(x, start=regexpr(pattern =' ', text=x)+1, stop=nchar(x)))

CleanedNames <- taxname.abbr(OriginalNames)
dup <- duplicated(CleanedNames)
sum(dup)

# rename some species that caused problems with TPL earlier
CleanedNames[which(CleanedNames=="Astragalus psoraloides")] <- "Astragalus gjunaicus"
CleanedNames[which(CleanedNames=="Hedysarum mackenzii")] <- "Hedysarum dasycarpum"

save(CleanedNames, file = "CleanedNames.Rdata")
write.csv(CleanedNames, file = "CleanedNames.csv")

# 2) substitute some of Jürgen's corrected names
# ! correct some messed up strings (encoding issue) from Jürgen's csv import manually in excel
# Thursday evening: 
# 1) match new cleaned list to original list -> save everything as Rdata; 
CleanedNames.df <- as.data.frame(CleanedNames, stringsAsFactors=FALSE)

spec.list.TRY.sPlot.3 <- cbind(spec.list.TRY.sPlot.2[,c(1,2,4)], CleanedNames.df, CleanedNames.df)
dim(spec.list.TRY.sPlot.3)
# 122901
head(spec.list.TRY.sPlot.3)
colnames(spec.list.TRY.sPlot.3) <- c("index","original.names.sPlot.TRY","sPlot.TRY","CleanedNames","CleanedNames.Juergen")

Tax_Back_sPlot2_TRY3 <- spec.list.TRY.sPlot.3

save(Tax_Back_sPlot2_TRY3, file = "Tax_Back_sPlot2_TRY3.Rdata")
load("Tax_Back_sPlot2_TRY3.Rdata")

str(Tax_Back_sPlot2_TRY3)

# 2) substitute some cleaned names with Jürgens corrected names 
weird.JD <- read.csv("weird.names_JD_string_correct.csv")
str(weird.JD)
head(weird.JD)
# 4093 names

sum(weird.JD$weird.names %in% Tax_Back_sPlot2_TRY3$original.names.sPlot.TRY)
# all 4093 names present in TB

# check 
write.csv(Tax_Back_sPlot2_TRY3, file = "Tax_Back_sPlot2_TRY3.csv")

index <- match(weird.JD$weird.names, Tax_Back_sPlot2_TRY3$original.names.sPlot.TRY)

# use syntax similar to that on for matching


# splot.species <- splot.species[-which(splot.species$PlotObservationID==index2a[1]),]  


Tax_Back_sPlot2_TRY3$CleanedNames.Juergen[index] <- weird.JD$Name.corrected

# 3) run cleaned names against TRNS (use six cores max), save chunks as csv-files to see where there are misspelled names


### do some more cleaning on "CleanedNames.Juergen"


CleanedNames.Juergen <- Tax_Back_sPlot2_TRY3$CleanedNames.Juergen


CleanedNames.Juergen <- gsub('*', '', CleanedNames.Juergen, fixed=TRUE)
CleanedNames.Juergen <- gsub('cf. ', '', CleanedNames.Juergen, fixed=TRUE)
CleanedNames.Juergen <- gsub('Cf. ', '', CleanedNames.Juergen, fixed=TRUE)
#CleanedNames.Juergen <- gsub('[', '', CleanedNames.Juergen, fixed=TRUE)
#CleanedNames.Juergen <- gsub(']', '', CleanedNames.Juergen, fixed=TRUE)
CleanedNames.Juergen <- gsub(' x ', ' ', CleanedNames.Juergen, fixed=TRUE)
CleanedNames.Juergen <- gsub('Ã—', '', CleanedNames.Juergen, fixed=TRUE)
CleanedNames.Juergen <- gsub('aff ', '', CleanedNames.Juergen, fixed=TRUE)
CleanedNames.Juergen <- gsub('(', '', CleanedNames.Juergen, fixed=TRUE)
CleanedNames.Juergen <- gsub(')', '', CleanedNames.Juergen, fixed=TRUE)
CleanedNames.Juergen <- gsub(' cf ', ' ', CleanedNames.Juergen, fixed=TRUE)
CleanedNames.Juergen <- gsub(' aff. ', ' ', CleanedNames.Juergen, fixed=TRUE)
CleanedNames.Juergen <- gsub('c‚e', 'ceae', CleanedNames.Juergen, fixed=TRUE)
CleanedNames.Juergen <- gsub('    ', ' ', CleanedNames.Juergen, fixed=TRUE)
CleanedNames.Juergen <- gsub('   ', ' ', CleanedNames.Juergen, fixed=TRUE)
CleanedNames.Juergen <- gsub('  ', ' ', CleanedNames.Juergen, fixed=TRUE)
CleanedNames.Juergen <- gsub('x-', '', CleanedNames.Juergen, fixed=TRUE)
CleanedNames.Juergen <- gsub('X-', '', CleanedNames.Juergen, fixed=TRUE)
CleanedNames.Juergen <- gsub('like ', '', CleanedNames.Juergen, fixed=TRUE)  
CleanedNames.Juergen <- gsub(',', '', CleanedNames.Juergen, fixed=TRUE)  
CleanedNames.Juergen <- gsub(',', '', CleanedNames.Juergen, fixed=TRUE)  
CleanedNames.Juergen <- gsub('=', ' ', CleanedNames.Juergen, fixed=TRUE)
CleanedNames.Juergen <- gsub('   ', '  ', CleanedNames.Juergen, fixed=TRUE)
CleanedNames.Juergen <- gsub('  ', ' ', CleanedNames.Juergen, fixed=TRUE)

write.csv(CleanedNames.Juergen, file = "CleanedNames.Juergen.csv")

Tax_Back_sPlot2_TRY3$CleanedNames.Juergen[Tax_Back_sPlot2_TRY3$CleanedNames.Juergen == "Agrostis x mercieri"]

CleanedNames[CleanedNames == "Agrostis x mercieri"]

Tax_Back_sPlot2_TRY3$CleanedNames.Juergen <- CleanedNames.Juergen

save(Tax_Back_sPlot2_TRY3, file = "Tax_Back_sPlot2_TRY3.Rdata")

# slice CleanedNames into chunks for TNRS:
# 
seq1 <- seq(from =1, to = 120001, 10000)
seq2 <- seq(from =10000, to = 130000, 10000)

# cbind(seq1, seq2)
library(foreach)

for(i in 1:length(seq1)) {
    write.csv(Tax_Back_sPlot2_TRY3$CleanedNames.Juergen[seq1[i]:seq2[i]], file = paste(paste("tnrs_submit", seq1[i], sep = "_"), "csv", sep = "."))
}


# identify species that are not matching (or have low prob. and are not Spermatophyta sp.)
# load 10000 species test data


tnrs.test <- read.csv("/home/oliver/Dokumente/PhD/PostPhD/IDiv/sDiv/sPlot/Analyses/Code/tnrs_retrieve_70001.csv")
dim(tnrs.test)

tnrs.test[1:5, ]
str(tnrs.test)

# 1) read in TNRS tables:
x <- foreach(i = 1:length(seq1), .combine = rbind) %dopar% {
  taxize::tnrs(query = CleanedNames[seq1[i]:seq2[i]], source = "iPlant_TNRS")
}



library(doParallel)
# Find out how many cores are available (if you don't already know)
detectCores()
# Create cluster with desired number of cores
cl <- makeCluster(2)

# Register cluster
registerDoParallel(cl)

# Find out how many cores are being used
getDoParWorkers()

# Use the rbind function to combine results

seq1 <- seq(from =1, to = 122901, 10000)

library(foreach)

tnrs.all <- NA

for(i in seq1) {
  tnrs.all <- rbind(tnrs.all, read.csv(paste(paste("/home/oliver/Dokumente/PhD/PostPhD/IDiv/sDiv/sPlot/Analyses/Code/tnrs.retrieve", i, sep = "."), "csv", sep = "."), stringsAsFactors=F))
}

TNRS.all <- tnrs.all[-1,]
dim(TNRS.all)
str(TNRS.all)
colnames(TNRS.all)

TNRS.all[1:10,36:37]


write.csv(TNRS.all[,-c(7,9,10,24,35:37)], file = "TNRS.all.csv")

# 2) merge with original names

load("Tax_Back_sPlot2_TRY3.Rdata")
names(Tax_Back_sPlot2_TRY3)

TNRS.all.2 <- cbind(Tax_Back_sPlot2_TRY3[,2], TNRS.all)
dim(TNRS.all.2)
names(TNRS.all.2)[1] <- "original.names.sPlot.TRY"
TNRS.all.2[1000:1100, c(1,5)]
TNRS.all.2[,1] <- as.character(TNRS.all.2[,1])

TNRS.all.2$Name_matched[1:100]

# select non-matched species:
library(stringr)
word("Spermatophyta sp. [Barleria lanceolata]", 1)

nonmatch <- TNRS.all.2$Name_submitted[which(TNRS.all.2$Name_matched == "No suitable matches found." & word(TNRS.all.2$Name_submitted, 1) != "Spermatophyta")]

length(nonmatch)

write.csv(nonmatch, file = "nonmatch.csv") # resolve this list again in TNRS and merge it with TNRS.all (~50 more species resolved)

nonmatch <- read.csv("nonmatch.csv", stringsAsFactors=F)
# match with TNRS.all 
TNRS.all[which(TNRS.all$Name_matched == "No suitable matches found." & word(TNRS.all$Name_submitted, 1) != "Spermatophyta") , ] <- nonmatch

TNRS.all.2[10:20, c(1:5)]

save(TNRS.all.2, file = "TNRS.all.2.Rdata")
write.csv(TNRS.all.2, file = "TNRS.all.2.csv")

# 3) run names matched against TPL
# to do Saturday: write script for server: multicore, 1000 species chunks, write chunks

# 4) resolve more species with gnr (taxize)

# 5) for poorly resolved TNRS species, run TPL on "submitted names"



library(Taxonstand)

TPL.test <- TPL(TNRS.all.2$Name_matched[100:200], genus = NULL, species = NULL, infrasp = NULL, infra = T, abbrev = TRUE, corr = TRUE, diffchar = 2, max.distance = 1, version = "1.1", file = "")

TPL.test[,c(1,2,6,8,10,12,16)]

colnames(TPL.test)

list1 <- c(1,2,3,4,5,)
list2 <- c(1,2,3,3,4,5)

identical(list1,list2)
all.equal(list1,list2)

# combine TNRS and TPL names check whether submitted names match
setwd("/home/oliver/Dokumente/PhD/PostPhD/IDiv/sDiv/sPlot/Analyses/Code/")
load("TNRS.all.2.Rdata")
load("TPL.all.Rdata")

str(TNRS.all.2)
str(TPL.all)

TNRS.all.3 <- TNRS.all.2[,c(1,3,4,5,6,7,12,13,14,15,16,17,18,26,27,28,30,32,33,35,36)]
colnames(TNRS.all.3)[2:21] <- paste("TNRS",colnames(TNRS.all.3)[2:21], sep = ".")

TPL.all.2 <- TPL.all[,c(1,2,3,4,6,8,9,10,12,13,16)]
colnames(TPL.all.2) <- paste("TPL",colnames(TPL.all.2), sep = ".")

# combine the two lists
TNRS.TPL <- cbind(Tax_Back_sPlot2_TRY3[,c(1,3)], TNRS.all.3, TPL.all.2)
names(TNRS.TPL)

save(TNRS.TPL, file = "TNRS.TPL.Rdata")
write.csv(TNRS.TPL, file = "TNRS.TPL.csv")
load("TNRS.TPL.Rdata")

str(TNRS.TPL)
sum(TNRS.TPL$TPL.Plant.Name.Index==F)
# 21993 names do not have a plant index

#### To do
names(TNRS.TPL)

# select uncertain
TNRS.TPL.uncertain <- TNRS.TPL[which(TNRS.TPL$TNRS.Overall_score<0.98 & TNRS.TPL$TNRS.Genus_score<0.8& TNRS.TPL$TNRS.Specific_epithet_score!=1),]
dim(TNRS.TPL.uncertain)

save(TNRS.TPL.uncertain, file = "TNRS.TPL.uncertain.Rdata")
write.csv(TNRS.TPL.uncertain, file = "TNRS.TPL.uncertain.csv")

TNRS.TPL.uncertain <- read.csv("TNRS.TPL.uncertain.csv")
head(TNRS.TPL.uncertain)
TNRS.TPL.uncertain[10:20,1:5]

# exclude word that start with "Spermatophyta"
firstWordSperm <- grepl('Spermatophyta', word(TNRS.TPL.uncertain$TNRS.Name_submitted, 1))
sum(firstWordSperm)
TNRS.TPL.uncertain.2 <- TNRS.TPL.uncertain[firstWordSperm,]
TNRS.TPL.uncertain.3 <- TNRS.TPL.uncertain[firstWordSperm==F,]
write.csv(TNRS.TPL.uncertain.2, file = "TNRS.TPL.uncertain.2.csv")
write.csv(TNRS.TPL.uncertain.3, file = "TNRS.TPL.uncertain.3.csv")

TNRS.TPL.uncertain.3 <- read.csv("TNRS.TPL.uncertain.3.csv")

save(TNRS.TPL.uncertain.3, file = "TNRS.TPL.uncertain.3.Rdata")

# run against TPL (13.00 - 13.30) (on cluster)
load("TNRS.TPL.Rdata")
load("uncertain.655.TPL.Rdata")
load("TNRS.TPL.uncertain.3.Rdata")
uncertain.655.TPL <- x
str(uncertain.655.TPL)
str(TNRS.TPL.uncertain.3)

uncertain.655.TPL.index <- cbind(TNRS.TPL.uncertain.3[,3:5], uncertain.655.TPL)

# merge uncertain.list with TNRS.TPL list
TNRS.TPL.2 <- TNRS.TPL

# continue here !!!!! check whether same columns are selected
TNRS.TPL.2[uncertain.655.TPL.index$index, c(1,2,3, 24,25,26,27,28:34)] <- uncertain.655.TPL.index[,-c(8,10,14,17,18,20)]
str(TNRS.TPL.2)
names(TNRS.TPL.2)
head(TNRS.TPL.2)
save(TNRS.TPL.2, file = "TNRS.TPL.2.Rdata")

write.csv(TNRS.TPL.2, file = "TNRS.TPL.2.csv")


str(uncertain.655.TPL.index)
'data.frame':	655 obs. of  20 variables:
 $ index                   : int  55 129 1526 1527 1543 1838 3542 4849 4854 4855 ...
 $ sPlot.TRY               : Factor w/ 3 levels "S","ST","T": 3 3 3 3 3 3 1 1 1 1 ...
 $ original.names.sPlot.TRY: Factor w/ 655 levels "ABDILOBARANA sp",..: 1 2 4 5 6 7 8 10 11 12 ...
 $ Genus                   : chr  "ABDILOBARANA" "ABIES" "ACARIQUARANA" "ACARIQUARA" ...
 $ Species                 : chr  NA "nordmanniana" NA NA ...
 $ Abbrev                  : chr  NA NA NA NA ...
 $ Infraspecific           : chr  "" "" "" "" ...
 $ ID                      : chr  "" "kew-2609993" "" "" ...
 $ Plant.Name.Index        : logi  FALSE TRUE FALSE FALSE FALSE FALSE ...
 $ TPL_version             : chr  "1.1" "1.1" "1.1" "1.1" ...
 $ Taxonomic.status        : chr  "" "Accepted" "" "" ...
 $ Family                  : chr  "" "Pinaceae" "" "" ...
 $ New.Genus               : chr  "ABDILOBARANA" "Abies" "ACARIQUARANA" "ACARIQUARA" ...
 $ New.Hybrid.marker       : chr  "" "" "" "" ...
 $ New.Species             : chr  NA "nordmanniana" NA NA ...
 $ New.Infraspecific       : chr  "" "" "" "" ...
 $ Authority               : chr  "" "(Steven) Spach" "" "" ...
 $ New.ID                  : chr  "" "kew-2609993" "" "" ...
 $ Typo                    : logi  FALSE FALSE FALSE FALSE FALSE FALSE ...
 $ WFormat                 : logi  FALSE FALSE FALSE FALSE FALSE FALSE ...

# convert factors into characters:
uncertain.655.TPL.index[,2] <- as.character(uncertain.655.TPL.index[,2])
uncertain.655.TPL.index[,3] <- as.character(uncertain.655.TPL.index[,3])


# which "TPL.Plant.Name.Index" == FALSE
TNRS.TPL.index.FALSE <- TNRS.TPL.2[which(TNRS.TPL.2$TPL.Plant.Name.Index==FALSE),]
str(TNRS.TPL.index.FALSE)
save(TNRS.TPL.index.FALSE, file = "TNRS.TPL.index.FALSE.Rdata")
write.csv(TNRS.TPL.index.FALSE, file = "TNRS.TPL.index.FALSE.csv")

# run non-matched names against "gnr_resolve"
load("TNRS.TPL.index.FALSE.Rdata")
str(TNRS.TPL.index.FALSE)

# Problem: some species that have no TPL.ID cannot be resolved with "gnr.resolve":
# e.g. Antylis barba-jovis .. -> in that case take the matched name from TNRS (if name score is >0.9)
# or species names is excluded, and just the genus name remains: e.g. Archangelica tympanodes
# -> in that case keep the full matched name from TNRS if probability is high
# Arcypteris
# Baikaea insignis
# Baphia keckii
# Benstonea monticola

# species name is pruned to genus 
# Bombacopsis flaviflora -> Bombacopsis (according to TNRS: Pachira)
# -> in this case take accepted name from TNRS

# there are still some cutoff names:
# Apium graveo subsp. butronensis

# make sure not assign family and higher-order information to genus after TPL scrubbing

# assign "Spermatophyta" MOST non-assigned species, BUT manually check for liliopsida, fungi, lichen, moss, pteridophyta, dicots ...

# extra columns for classification:

# extra column: level taxonomic information (species, genus, family ... order etc)


##  some testing strange names:
sp1 <- TPLck("Jutai acu", corr=TRUE, diffchar = 2, max.distance=2)
sp1

sp1 <- TPL(missing.2, corr=TRUE, diffchar = 2, max.distance=2)
sp1

missing.2 <- gsub("_", " ", missing)


library(taxize)
library(foreach)
library(doParallel)

detectCores()
cl <- makeCluster(3)
registerDoParallel(cl)
getDoParWorkers()

spec <- c("Poa annua","Verbena","Chenopodioideae","adsfa","Dacryodes 1","Cyperales","Davenportia davenportia")

spec <- TNRS.TPL.index.FALSE$TNRS.Name_submitted

# gnr_resolve changes order of plant names in a submitted list ... therefore needs to ran in a foreach-loop
# (test run time for subset of 100 species, on 12 cores)

system.time(
    x <- foreach(i = 4350:4355, .combine = rbind) %dopar% {
        taxize::gnr_resolve(names = spec[i], resolve_once = TRUE, highestscore = TRUE, stripauthority = TRUE, best_match_only = F, data_source_ids = c(1,2,3,4,5,9,10,12,13,15,16,20,28,31), preferred_data_sources = c(1,2,3,4,5,9,10,12,13,15,16,20,28,31))$results[1,]
    }
    )
x

write.csv(sources, file = "sources.csv")

taxize::gnr_resolve(names = "Hepatophyta", resolve_once = T, highestscore = T, stripauthority = TRUE, best_match_only = F, data_source_ids = c(1,2,3,4,5,6,7,9,10,11,13,15,16,20,28,31,108,147,150,165,167,176), preferred_data_sources = c(1,2,3,4,5,9,10,12,13,15,16,20,28,31))

spec[1002]: "Anonaceae sp1 UNA1"
spec[1018]: "Anthocephalus"

gnr_resolve(names = "Jutai acu")

taxize::gnr_resolve(names = "Hypnales Slaapmossen - Feather mosses | Hypnales Slaa", resolve_once = T, highestscore = T, stripauthority = TRUE, best_match_only = T)

lookup_table("Trentepohlia", missing_action = "NA")


temp <- gnr_resolve(names = "JM Karin K Polygala micrantha Perr. & Guill.", resolve_once = TRUE, highestscore = TRUE, best_match_only = TRUE)$results[1,]
temp$results

# read in gnr.resolve.list (has been generated on RStudio-Server)
# create "matched_name3" column

FALSE.gnr <- read.csv("TNRS.TPL.index.FALSE.gnr.csv")
str(FALSE.gnr)

FALSE.gnr$matched_name2 <- as.character(FALSE.gnr$matched_name2)
FALSE.gnr$submitted_name <- as.character(FALSE.gnr$submitted_name)

FALSE.gnr$matched_name3 <- FALSE.gnr$matched_name2

FALSE.gnr$matched_name3[which(is.na(FALSE.gnr$score))] <- FALSE.gnr$submitted_name[which(is.na(FALSE.gnr$score))]

# substitute "one-word" names with the full names
library(stringr)
numberOfWords <- str_count(FALSE.gnr$matched_name2, "\\S+")
str(numberOfWords)

FALSE.gnr$matched_name3[which(numberOfWords<2)] <- FALSE.gnr$submitted_name[which(numberOfWords<2)]

# re-run "matched_name3" against TPL
save(FALSE.gnr, file = "FALSE.gnr.Rdata")
     
# merge FALSE.gnr.TPL with 
load("FALSE.gnr.TPL.Rdata")
load("FALSE.gnr.Rdata")
str(FALSE.gnr)
str(FALSE.gnr.TPL)

# continue here
FALSE.gnr.TPL.ID <- cbind(FALSE.gnr[,c(2,3)], FALSE.gnr.TPL)
head(FALSE.gnr.TPL.ID)

FALSE.gnr.TPL.ID[,2] <- as.character(FALSE.gnr.TPL.ID[,2])

# continue here
TNRS.TPL.2[FALSE.gnr.TPL.ID$index, c(1,2, 24,25,26,27,28:34)] <- FALSE.gnr.TPL.ID[,c(1:6,8,10,11,12,14,15,18)]

str(FALSE.gnr.TPL.ID[,-c(8,10,14,17,18,20)])
names(FALSE.gnr.TPL.ID[,c(1:6,8,10,11,12,14,15,18)])
str(TNRS.TPL.2[FALSE.gnr.TPL.ID$index, c(1,2, 24,25,26,27,28:34)])
names(TNRS.TPL.2[FALSE.gnr.TPL.ID$index, c(1,2, 24,25,26,27,28:34)])

save(TNRS.TPL.2, file = "TNRS.TPL.2.Rdata")
load("TNRS.TPL.2.Rdata")
write.csv(TNRS.TPL.2, file = "TNRS.TPL.2.csv")
names(TNRS.TPL.2)

sum(TNRS.TPL.2$TPL.Plant.Name.Index!=T)
sum(TNRS.TPL.2$TPL.Plant.Name.Index==T)

# which TPL.index==FALSE, TNRS.accepted 
TNRS.accept.TPL.index.false <- TNRS.TPL.2[which(TNRS.TPL.2$TPL.Plant.Name.Index==FALSE & TNRS.TPL.2$TNRS.Taxonomic_status=="Accepted"),]
dim(TNRS.accept.TPL.index.false)
write.csv(TNRS.accept.TPL.index.false, file = "TNRS.accept.TPL.index.false.csv")


# which typo=TRUE and number of strings <6:
dim(TNRS.TPL.2)
sum(TNRS.TPL.2$TPL.Typo)
# 1259

# write script for classification (for genus or higher order information)
out <- classification(c("Hepatophyta"), return_id=FALSE, db = c("itis"))
cbind(out)


spec.2 <- x$matched_name2

x <- foreach(i = 1:length(spec.2), .combine = dplyr::bind_rows) %dopar% {
    as.data.frame(cbind(classification(spec.2[i], return_id=FALSE, db = c("itis"))))
}

a <- cbind(classification(spec.2[1], return_id=FALSE, db = c("itis")))
b <- cbind(classification(spec.2[2], return_id=FALSE, db = c("itis")))
c <- as.data.frame(cbind(classification(spec.2[7], return_id=FALSE, db = c("itis"))))
d <- as.data.frame(cbind(classification(spec.2[4], return_id=FALSE, db = c("itis"))))

library(dplyr)
bind_rows(a,b,c)


#######################
### classfication #
#######################

 (out <- get_ids(names=c("Laricifomes"), db = c("itis","ncbi"))) # Laricifomes officinalis
     (cl <- classification(out))
     rbind(cl)
     ## cbind with so many names results in some messy data
     cbind(cl)
     ## so you can turn off return_id
     cbind(classification(out, return_id=FALSE))

     write.csv(cbind( classification(out, return_id=FALSE)), file = "class.csv")
########

library(stringr)

w <- data.frame(c("a;b","a;b"))
w[,1] <- as.character(w[,1])


new <- apply(w, 1, FUN=function(x){cbind(unlist(strsplit(x,";")))})


names <- paste("Polygonum longisetum", collapse=',')
  names <- RCurl::curlEscape(names)
  tnrs.api <- 'http://tnrs.iplantc.org/tnrsm-svc'
  url <- paste(tnrs.api,'/matchNames?retrieve=best&names=', names, sep='')
  tnrs.json <- RCurl::getURL(url)
  tnrs.results <- jsonlite::fromJSON(tnrs.json)
  tnrs.results

Tax_Back_sPlot2_TRY3$CleanedNames.Juergen[Tax_Back_sPlot2_TRY3$CleanedNames.Juergen == "Spinus pinus"]

library(TaxonLookup)
lookup_table(c("Fuscospora"), missing_action = "NA")

synonyms("Fuscospora", db=c("itis"))

tnrs(query = "Verbena urticafolium", source = "NCBI,MSW3,iPlant_TNRS", code = "ICN,ICNB,ICBN,ICNCP")

########################################################
######################################
# name resolution using new TNRS (September 2015):
######################################
##########################################
# check whether submitted names match with cleaned names:

####
## for the new non-matching species in the July version:
###

# load new match from oct. 2016:
tnrs.tpl.1 <- read.csv("/home/oliver/Downloads/tnrs.tpl.1.txt", sep = "\t")[-1,]
str(tnrs.tpl.1)

tnrs.tpl.2 <- read.csv("/home/oliver/Downloads/tnrs.tpl.2.csv")
str(tnrs.tpl.2)
# "Herzblatt had to be corrected (line 1943)

tnrs.tpl.3 <- read.csv("/home/oliver/Downloads/tnrs.tpl.3.txt", sep = "\t")
str(tnrs.tpl.3)

tnrs.tpl.4 <- read.csv("/home/oliver/Downloads/tnrs.tpl.4.txt", sep = "\t")
str(tnrs.tpl.4)

tnrs.tpl <- rbind(tnrs.tpl.1[,-37], tnrs.tpl.2, tnrs.tpl.3, tnrs.tpl.4)
dim(tnrs.tpl)
str(tnrs.tpl)

write.csv(tnrs.tpl, file = "tnrs.tpl.csv")

tnrs.tpl <- read.csv("tnrs.tpl.csv")

# merge them with "cleaned names list and with the original names"
head(miss.clean)

colnames(miss.clean) <- c("names.sPlot.TRY", "names.corr.string")

###

str(tnrs.tpl.new)
tnrs.tpl <- tnrs.tpl.new
#####



TNRS.TPL.2$TNRS.Name_submitted[TNRS.TPL.2$TNRS.Name_submitted %in% tnrs.trop$Name_submitted == F]
# all match instead of three species:
# [1] "Antimima sp. [kahnf\"\"rmig]"                        
# [2] "Spermatophyta sp. [Geophyt sternf\"\"rmig]"          
# [3] "Spermatophyta sp. [Strauch \"\"Oraniquelocarpus\"\"]"

which(TNRS.TPL.2$TNRS.Name_submitted %in% tnrs.trop$Name_submitted == F)
TNRS.TPL.2$TNRS.Name_submitted[c(8349 , 51560, 110472)]
tnrs.trop$Name_submitted[c(8349 , 51560, 110472)]

write.csv(table(tnrs.tpl$Taxonomic_status), file = "tab_tax.stat_tnrs.tpl.csv")
write.csv(table(tnrs.all$Taxonomic_status), file = "tab_tax.stat_tnrs.all.csv")
write.csv(table(tnrs.trop$Taxonomic_status), file = "tab_tax.stat_tnrs.trop.csv")

# stats for "name_matched_rank"
write.csv(table(tnrs.tpl$Name_matched_rank), file = "tab_name.rank_tnrs.tpl.csv")
write.csv(table(tnrs.all$Name_matched_rank), file = "tab_name.rank_tnrs.all.csv")
write.csv(table(tnrs.trop$Name_matched_rank), file = "tab_name.rank_tnrs.trop.csv")

# start consolidating:
# 1. inspect in the excel table:
# sort according to: Name_matched_rank (==Family), Taxonomic_status (==Accepted, Synomyn), Family_score (>0.9)
# create "index.family"
# 13.40-14.00

# assign index to first column:
tnrs.tpl$Name_number <- 1:length(tnrs.tpl$Name_number)

tnrs.tpl <- tnrs.tpl[,-1]

index.family <- tnrs.tpl[which(tnrs.tpl$Name_matched_rank == "family" & (tnrs.tpl$Taxonomic_status == "Accepted" | tnrs.tpl$Taxonomic_status == "Synonym") & tnrs.tpl$Family_score > 0.88), 1]
length(index.family)

# 2. repeat selection for Name_matched_rank "forma" "genus" "infraspecies" ... change selection "score", e.g. lower (strong) threshold for species, higher (or no) threshold for infraspec., variety, ... (identify threshold by looking at the excel-table)
# create respective index
# 
# 14.00-15.00
index.forma <- tnrs.tpl[which(tnrs.tpl$Name_matched_rank == "forma"), 1]
length(index.forma)

###############
## continue here:
###############

index.genus <- tnrs.tpl[which(tnrs.tpl$Name_matched_rank == "genus" & tnrs.tpl$Taxonomic_status == "Accepted" & tnrs.tpl$Genus_score > 0.83), 1]
length(index.genus)

# Genus: Problem: the following stuff is cut down to genus-level
# Andropogon sp. [capillipes + glaucopsis + glomeratus]
# Antennaria angustata/glabrata
# Aragoa perez.arbelaeziana
# Capsella bursa.pastoris
# !! possible solution: removing ".", "/", "[]" (! do this after index based on all sources is created)

index.infraspec <- tnrs.tpl[which(tnrs.tpl$Name_matched_rank == "infraspecies"), 1]
length(index.infraspec)

index.species <- tnrs.tpl[which(tnrs.tpl$Name_matched_rank == "species" & (tnrs.tpl$Taxonomic_status == "Accepted" | tnrs.tpl$Taxonomic_status == "Synonym") & tnrs.tpl$Genus_score > 0.78 & tnrs.tpl$Name_score > 0.93), 1]
length(index.species1)

index.species <- tnrs.tpl[which(tnrs.tpl$Name_matched_rank == "species" & (tnrs.tpl$Taxonomic_status == "Accepted" | tnrs.tpl$Taxonomic_status == "Synonym") & tnrs.tpl$Specific_epithet_score > 0.78), 1]
length(index.species2)

index.species <- unique(c(index.species1, index.species2))
length(index.species)

index.subspec <- tnrs.tpl[which(tnrs.tpl$Name_matched_rank == "subspecies" & (tnrs.tpl$Taxonomic_status == "Accepted" | tnrs.tpl$Taxonomic_status == "Synonym")), 1]
length(index.subspec)

index.variety <- tnrs.tpl[which(tnrs.tpl$Name_matched_rank == "variety" & (tnrs.tpl$Taxonomic_status == "Accepted" | tnrs.tpl$Taxonomic_status == "Synonym")), 1]
length(index.variety)

# additional step: identifying "non-matched" species that are spermatophyta
index.spermatophyt <- tnrs.tpl[which(tnrs.tpl$Name_matched == "No suitable matches found." & word(tnrs.tpl$Name_submitted, 1) == "Spermatophyta"), 1]
length(index.spermatophyt)

# !! later on: resolve 


# 3. identify those species that do not fulfill the search criteria
# 15.00-15.15
index.tpl <- c(index.family, index.forma, index.genus, index.species, index.subspec, index.variety, index.spermatophyt)
length((index.tpl))

tnrs.tpl.certain <- tnrs.tpl[index.tpl,]
dim(tnrs.tpl.certain)
save(tnrs.tpl.certain, file = "tnrs.tpl.certain.Rdata")
write.csv(tnrs.tpl.certain, file = "tnrs.tpl.certain.csv")

tnrs.tpl.uncertain <- tnrs.tpl[tnrs.tpl$Name_number %in% index.tpl == F, ]
dim(tnrs.tpl.uncertain)
save(tnrs.tpl.uncertain, file = "tnrs.tpl.uncertain.Rdata")
write.csv(tnrs.tpl.uncertain, file = "tnrs.tpl.uncertain.csv")

write.csv(tnrs.tpl.uncertain[,2], file = "tnrs.tpl.uncertain.upload.csv")

### continue here: Thursday 20th Oct

tnrs.trop <- read.csv("/home/oliver/Downloads/tnrs.trop.txt", sep = "\t")
str(tnrs.trop)

#######

# 4. take table from 3. repeat steps 1.-3. for "tnrs.all" "and tnrs.trop"
# 15.15-17.00
# tpl.all:
str(tnrs.trop)
tnrs.trop$Name_number <- 1:length(tnrs.trop$Name_number)
# reduce to the uncertain species from tnrs.tpl
tnrs.trop.small <- tnrs.trop[tnrs.trop$Name_number %in% index.tpl == F, ]
str(tnrs.trop.small)

save(tnrs.trop.small, file = "tnrs.trop.small.Rdata")
write.csv(tnrs.trop.small, file = "tnrs.trop.small.csv")

index.family <- tnrs.trop.small[which(tnrs.trop.small$Name_matched_rank == "family" & (tnrs.trop.small$Taxonomic_status == "Accepted"| tnrs.trop.small$Taxonomic_status == "No opinion")), 1]
length(index.family)

index.forma <- tnrs.trop.small[which(tnrs.trop.small$Name_matched_rank == "forma" & (tnrs.trop.small$Taxonomic_status == "Accepted" | tnrs.trop.small$Taxonomic_status == "Synonym")), 1]
length(index.forma)
##

index.genus <- tnrs.trop.small[which(tnrs.trop.small$Name_matched_rank == "genus" & (tnrs.trop.small$Taxonomic_status == "Accepted" | tnrs.trop.small$Taxonomic_status == "Synonym" | tnrs.trop.small$Taxonomic_status == "No opinion") & tnrs.trop.small$Genus_score > 0.83), 1]
length(index.genus)

# continue here:
index.species <- tnrs.trop.small[which(tnrs.trop.small$Name_matched_rank == "species" & (tnrs.trop.small$Taxonomic_status == "Accepted" | tnrs.trop.small$Taxonomic_status == "Synonym" | tnrs.trop.small$Taxonomic_status == "No opinion") & tnrs.trop.small$Specific_epithet_score > 0.77), 1]
length(index.species)

index.species2 <- tnrs.trop.small[which(tnrs.trop.small$Name_matched_rank == "species" & (tnrs.trop.small$Taxonomic_status == "Accepted" | tnrs.trop.small$Taxonomic_status == "Synonym") & tnrs.trop.small$Genus_score > 0.88 & tnrs.trop.small$Name_score > 0.49), 1]
length(index.species2)

index.species <- unique(c(index.species1, index.species2))
length(index.species)

index.subspec <- tnrs.trop.small[which(tnrs.trop.small$Name_matched_rank == "subspecies"), 1]
length(index.subspec)

index.subvariety <- tnrs.trop.small[which(tnrs.trop.small$Name_matched_rank == "subvariety"), 1]
length(index.subvariety)

index.variety <- tnrs.trop.small[which(tnrs.trop.small$Name_matched_rank == "variety" & tnrs.trop.small$Taxonomic_status == "No opinion"), 1]
length(index.variety)

##
index.all <- c(index.family, index.genus, index.species, index.subspec, index.variety, index.subvariety)
length((index.all))

##
tnrs.trop.small.certain <- tnrs.trop.small[tnrs.trop.small$Name_number %in% index.all == T,]
dim(tnrs.trop.small.certain)
save(tnrs.trop.small.certain, file = "tnrs.trop.small.certain.Rdata")
write.csv(tnrs.trop.small.certain, file = "tnrs.trop.small.certain.csv")

tnrs.trop.small.uncertain <- tnrs.trop.small[tnrs.trop.small$Name_number %in% index.all == F, ]
dim(tnrs.trop.small.uncertain)
save(tnrs.trop.small.uncertain, file = "tnrs.trop.small.uncertain.Rdata")
write.csv(tnrs.trop.small.uncertain, file = "tnrs.trop.small.uncertain.csv")

#### just for Oct. 2016 backbone update:

backbone.tpl.trop.certain <- rbind(tnrs.tpl.certain, tnrs.trop.small.certain)
str(backbone.tpl.trop.certain)

# kick out some columns that should not be in teh final backbone:
backbone.tpl.trop.certain.2 <- backbone.tpl.trop.certain[ ,c(1:6,12:17,25:35)]
colnames(backbone.tpl.trop.certain.2)
# add extra columns to match the old backbone:

backbone.tpl.trop.certain.2$Manual.matching <- NA
backbone.tpl.trop.certain.2$Status.correct <- NA
backbone.tpl.trop.certain.2$name.correct <- NA
backbone.tpl.trop.certain.2$rank.correct <- NA
backbone.tpl.trop.certain.2$family.correct <- NA
backbone.tpl.trop.certain.2$name.short.correct <- NA
backbone.tpl.trop.certain.2$rank.short.correct <- NA

backbone.tpl.trop.certain.2$names.sPlot.TRY <- NA
backbone.tpl.trop.certain.2$names.corr.string <- NA
backbone.tpl.trop.certain.2$sPlot.TRY <- NA

# bring names in the same order as in the old backbone:
backbone.tpl.trop.certain.3 <- backbone.tpl.trop.certain.2[,c(1,31:33,2:30)]
match(colnames(backbone.tpl.trop.certain.3), colnames(backbone.splot.try3))
identical(colnames(backbone.tpl.trop.certain.3), colnames(backbone.splot.try3)) # TRUE


# fill in emptly columns:
# Status.correct
backbone.tpl.trop.certain.3$Status.correct <- backbone.tpl.trop.certain.3$Taxonomic_status
index <- which(backbone.tpl.trop.certain.3$Name_matched == "No suitable matches found.")
backbone.tpl.trop.certain.3$Status.correct[index] <- "No suitable matches found."
# rename no.oppinion into unresolved
index <- which(backbone.tpl.trop.certain.3$Status.correct == "No opinion")
backbone.tpl.trop.certain.3$Status.correct[index] <- "Unresolved"

# name.correct (use "Accepted name", if unresolved take "Name_matched")
backbone.tpl.trop.certain.3$name.correct <- backbone.tpl.trop.certain.3$Accepted_name
index <- which(backbone.tpl.trop.certain.3$Taxonomic_status != "Accepted" | backbone.tpl.trop.certain.3$Taxonomic_status != "Synonym")
backbone.tpl.trop.certain.3$name.correct[index] <- backbone.tpl.trop.certain.3$Name_matched[index]
index <- which(backbone.tpl.trop.certain.3$Name_matched == "No suitable matches found.")
backbone.tpl.trop.certain.3$name.correct[index] <- "No suitable matches found."

# rank.correct
backbone.tpl.trop.certain.3$rank.correct <- backbone.tpl.trop.certain.3$Accepted_name_rank
index <- which(backbone.tpl.trop.certain.3$Taxonomic_status != "Accepted" | backbone.tpl.trop.certain.3$Taxonomic_status != "Synonym")
backbone.tpl.trop.certain.3$rank.correct[index] <- backbone.tpl.trop.certain.3$Name_matched_rank[index]
index <- which(backbone.tpl.trop.certain.3$Name_matched == "No suitable matches found.")
backbone.tpl.trop.certain.3$rank.correct[index] <- NA

# family.correct
backbone.tpl.trop.certain.3$family.correct <- backbone.tpl.trop.certain.3$Accepted_name_family
index <- which(backbone.tpl.trop.certain.3$Taxonomic_status != "Accepted" | backbone.tpl.trop.certain.3$Taxonomic_status != "Synonym")
backbone.tpl.trop.certain.3$family.correct[index] <- backbone.tpl.trop.certain.3$Name_matched_accepted_family[index]
index <- which(backbone.tpl.trop.certain.3$Name_matched == "No suitable matches found.")
backbone.tpl.trop.certain.3$family.correct[index] <- NA

# name.short.correct
backbone.tpl.trop.certain.3$name.short.correct <- backbone.tpl.trop.certain.3$name.correct

index <- which(backbone.tpl.trop.certain.3$rank.correct == "subspecies" | backbone.tpl.trop.certain.3$rank.correct == "variety" | backbone.tpl.trop.certain.3$rank.correct == "forma"| backbone.tpl.trop.certain.3$rank.correct == "subvariety" | backbone.tpl.trop.certain.3$Name_matched_rank == "subspecies" | backbone.tpl.trop.certain.3$Name_matched_rank == "variety")

library(stringr)
backbone.tpl.trop.certain.3$name.short.correct[index] <- word(string = backbone.tpl.trop.certain.3$name.short.correct[index], start = 1, end = 2)

# rank.short.correct
backbone.tpl.trop.certain.3$rank.short.correct <- backbone.tpl.trop.certain.3$rank.correct

index <- which(backbone.tpl.trop.certain.3$rank.correct == "subspecies" | backbone.tpl.trop.certain.3$rank.correct == "variety" | backbone.tpl.trop.certain.3$rank.correct == "forma"| backbone.tpl.trop.certain.3$rank.correct == "subvariety")

backbone.tpl.trop.certain.3$rank.short.correct[index] <- "species"

#########
# fill in the columns in trop.small.uncertain
####
tnrs.trop.small.uncertain

# kick out some columns that should not be in teh final backbone:
tnrs.trop.small.uncertain.2 <- tnrs.trop.small.uncertain[ ,c(1:6,12:17,25:35)]
colnames(tnrs.trop.small.uncertain.2)
# add extra columns to match the old backbone:

tnrs.trop.small.uncertain.2$Manual.matching <- NA
tnrs.trop.small.uncertain.2$Status.correct <- NA
tnrs.trop.small.uncertain.2$name.correct <- NA
tnrs.trop.small.uncertain.2$rank.correct <- NA
tnrs.trop.small.uncertain.2$family.correct <- NA
tnrs.trop.small.uncertain.2$name.short.correct <- NA
tnrs.trop.small.uncertain.2$rank.short.correct <- NA

tnrs.trop.small.uncertain.2$names.sPlot.TRY <- NA
tnrs.trop.small.uncertain.2$names.corr.string <- NA
tnrs.trop.small.uncertain.2$sPlot.TRY <- NA

# bring names in the same order as in the old backbone:
tnrs.trop.small.uncertain.3 <- tnrs.trop.small.uncertain.2[,c(1,31:33,2:30)]
match(colnames(tnrs.trop.small.uncertain.3), colnames(backbone.splot.try3))
identical(colnames(tnrs.trop.small.uncertain.3), colnames(backbone.splot.try3)) # TRUE

tnrs.trop.small.uncertain.3[,c(28:29)] <- "No suitable matches found."

# merge with backbone for certain species:
backbone.tpl.trop <- rbind(backbone.tpl.trop.certain.3, tnrs.trop.small.uncertain.3)
head(backbone.tpl.trop)
dim(backbone.tpl.trop)

write.csv(backbone.tpl.trop, file = "backbone.tpl.trop.csv")

backbone.tpl.trop <- read.csv("backbone.tpl.trop.csv")

## fill in remaining first three columns
backbone.tpl.trop$sPlot.TRY <- "S"
backbone.tpl.trop$Manual.matching <- "sPlot2b"

library(plyr)
miss.clean.2 <- cbind(1:length(miss.clean[,1]), as.data.frame(miss.clean))
colnames(miss.clean.2)[1] <- "Name_number"

backbone.tpl.trop <- left_join(miss.clean.2, backbone.tpl.trop, by = "Name_number")
head(backbone.tpl.trop)

colnames(backbone.tpl.trop)

backbone.tpl.trop.2 <- backbone.tpl.trop[,-c(4:6)]

colnames(backbone.tpl.trop.2)[2:3] <- c("names.sPlot.TRY", "names.corr.string")
match(colnames(backbone.tpl.trop.2), colnames(backbone.splot.try3))
identical(colnames(backbone.tpl.trop.2), colnames(backbone.splot.try3))

write.csv(backbone.tpl.trop.2, file = "backbone.tpl.trop.2.csv")
save(backbone.tpl.trop.2, file = "backbone.tpl.trop.2.Rdata")

# merge with the big old backbone:
backbone.splot2b.try3 <- rbind(backbone.splot.try3, backbone.tpl.trop.2)
dim(backbone.splot2b.try3)

## see whether the new backbone matches the sPlot2b species data
str(splot.species)

length(unique(splot.species$Matched_concept))

which(unique(splot.species$Matched_concept) %in% backbone.splot2b.try3$names.sPlot.TRY == F)


backbone.splot2.1.try3 <- backbone.splot2b.try3
write.csv(backbone.splot2.1.try3, file = "backbone.splot2.1.try3.csv")
save(backbone.splot2.1.try3, file = "backbone.splot2.1.try3.Rdata")


###############################################################################################
###########################################################################################
########################################################################################################

##############
# tnrs.trop:
str(tnrs.trop)
tnrs.trop$Name_number <- 1:length(tnrs.trop$Name_number)
# reduce to the uncertain species from tnrs.tpl
tnrs.trop.small <- tnrs.trop[tnrs.all.small.uncertain$Name_number, ]
str(tnrs.trop.small)

save(tnrs.trop.small, file = "tnrs.trop.small.Rdata")
write.csv(tnrs.trop.small, file = "tnrs.trop.small.csv")

###
index.family <- tnrs.trop.small[which(tnrs.trop.small$Name_matched_rank == "family" & (tnrs.trop.small$Taxonomic_status == "Accepted"| tnrs.trop.small$Taxonomic_status == "Synonym")), 1]
length(index.family)

index.forma <- tnrs.trop.small[which(tnrs.trop.small$Name_matched_rank == "forma" & (tnrs.trop.small$Taxonomic_status == "Accepted" | tnrs.trop.small$Taxonomic_status == "Synonym")), 1]
length(index.forma)

index.genus <- tnrs.trop.small[which(tnrs.trop.small$Name_matched_rank == "genus" & (tnrs.trop.small$Taxonomic_status == "Accepted" | tnrs.trop.small$Taxonomic_status == "Synonym") & tnrs.trop.small$Genus_score > 0.83 & tnrs.trop.small$Name_score > 0.5), 1]
length(index.genus)

# continue here:
index.species1 <- tnrs.trop.small[which(tnrs.trop.small$Name_matched_rank == "species" & (tnrs.trop.small$Taxonomic_status == "Accepted" | tnrs.trop.small$Taxonomic_status == "Synonym") & tnrs.trop.small$Genus_score > 0.88 & tnrs.trop.small$Name_score > 0.9), 1]
length(index.species1)

index.species2 <- tnrs.trop.small[which(tnrs.trop.small$Name_matched_rank == "species" & (tnrs.trop.small$Taxonomic_status == "Accepted" | tnrs.trop.small$Taxonomic_status == "Synonym") & tnrs.trop.small$Genus_score > 0.78 & tnrs.trop.small$Name_score > 0.94), 1]
length(index.species1)

index.species3 <- tnrs.trop.small[which(tnrs.trop.small$Name_matched_rank == "species" & (tnrs.trop.small$Taxonomic_status == "Accepted" | tnrs.trop.small$Taxonomic_status == "Synonym") & tnrs.trop.small$Genus_score > 0.88 & tnrs.trop.small$Name_score > 0.49), 1]
length(index.species3)

index.species <- unique(c(index.species1, index.species2, index.species3))
length(index.species)


index.subspec <- tnrs.trop.small[which(tnrs.trop.small$Name_matched_rank == "subspecies" & (tnrs.trop.small$Taxonomic_status == "Accepted" | tnrs.trop.small$Taxonomic_status == "Synonym")), 1]
length(index.subspec)

index.variety <- tnrs.trop.small[which(tnrs.trop.small$Name_matched_rank == "variety" & (tnrs.trop.small$Taxonomic_status == "Accepted" | tnrs.trop.small$Taxonomic_status == "Synonym")), 1]
length(index.variety)

index.trop <- c(index.family, index.forma, index.genus, index.species, index.subspec, index.variety)
length((index.trop))

##
tnrs.trop.small.certain <- tnrs.trop.small[tnrs.trop.small$Name_number %in% index.trop == T,]
dim(tnrs.trop.small.certain)
save(tnrs.trop.small.certain, file = "tnrs.trop.small.certain.Rdata")
write.csv(tnrs.trop.small.certain, file = "tnrs.trop.small.certain.csv")

tnrs.trop.small.uncertain <- tnrs.trop.small[tnrs.trop.small$Name_number %in% index.trop == F, ]
dim(tnrs.trop.small.uncertain)
save(tnrs.trop.small.uncertain, file = "tnrs.trop.small.uncertain.Rdata")
write.csv(tnrs.trop.small.uncertain, file = "tnrs.trop.small.uncertain.csv")

### run against NCBI
write.csv(tnrs.trop.small.uncertain$Name_submitted[1:5000], file = "trop.uncert.1.csv")
write.csv(tnrs.trop.small.uncertain$Name_submitted[5001:9641], file = "trop.uncert.5001.csv")


# 5. identify unresolved species (excluding "Spermatophyta...") from 1.-4. (which were not indexed according to my procedure above) and run against TPL again (using six sources BUT take NCBI first)

# 
tnrs.ncbi.1 <- read.csv("/home/oliver/Downloads/tnrs.trop.uncert.1.csv", stringsAsFactors = FALSE)[-1,]
tnrs.ncbi.2 <- read.csv("/home/oliver/Downloads/tnrs.trop.uncert.5001.csv", stringsAsFactors = FALSE)[-1,]

tnrs.ncbi <- rbind(tnrs.ncbi.1, tnrs.ncbi.2)
str(tnrs.ncbi)
range(tnrs.trop.small.uncertain$Name_number)
# give index:
tnrs.ncbi$Name_number <- tnrs.trop.small.uncertain$Name_number
range(tnrs.ncbi$Name_number)

save(tnrs.ncbi, file = "tnrs.ncbi.Rdata")
write.csv(tnrs.ncbi, file = "tnrs.ncbi.csv")

# for tnrs.ncbi, identify certain and uncertain species:
index.family <- tnrs.ncbi[which(tnrs.ncbi$Name_matched_rank == "family" & (tnrs.ncbi$Taxonomic_status == "Accepted"| tnrs.ncbi$Taxonomic_status == "Synonym") & tnrs.ncbi$Family_score > 0.85), 1]
length(index.family)

index.genus.1 <- tnrs.ncbi[which(tnrs.ncbi$Name_matched_rank == "genus" & (tnrs.ncbi$Taxonomic_status == "Accepted" | tnrs.ncbi$Taxonomic_status == "Synonym") & tnrs.ncbi$Genus_score > 0.89 & tnrs.ncbi$Name_score > 0.49), 1]
length(index.genus.1)

index.genus.2 <- tnrs.ncbi[which(tnrs.ncbi$Name_matched_rank == "genus" & (tnrs.ncbi$Taxonomic_status == "Accepted" | tnrs.ncbi$Taxonomic_status == "Synonym") & tnrs.ncbi$Genus_score > 0.99 & tnrs.ncbi$Name_score > 0.2), 1]
length(index.genus.2)

index.genus.3 <- tnrs.ncbi[which(tnrs.ncbi$Name_matched_rank == "genus" & tnrs.ncbi$Taxonomic_status == "No opinion" & tnrs.ncbi$Genus_score > 0.88 & tnrs.ncbi$Name_score > 0.49), 1]
length(index.genus.3)

index.genus <- unique(c(index.genus.1, index.genus.2, index.genus.3))
length(index.genus)

###
index.species.1 <- tnrs.ncbi[which(tnrs.ncbi$Name_matched_rank == "species" & (tnrs.ncbi$Taxonomic_status == "Accepted" | tnrs.ncbi$Taxonomic_status == "Synonym") & tnrs.ncbi$Name_score > 0.94), 1]
length(index.species.1)

index.species.2 <- tnrs.ncbi[which(tnrs.ncbi$Name_matched_rank == "species" & (tnrs.ncbi$Taxonomic_status == "Accepted" | tnrs.ncbi$Taxonomic_status == "Synonym") & tnrs.ncbi$Genus_score > 0.81 & tnrs.ncbi$Name_score > 0.51), 1]
length(index.species.2)

index.species.3 <- tnrs.ncbi[which(tnrs.ncbi$Name_matched_rank == "species" & tnrs.ncbi$Taxonomic_status == "No opinion"  & tnrs.ncbi$Genus_score > 0.7 & tnrs.ncbi$Specific_epithet_score > 0.75), 1]
length(index.species.3)

index.species <- unique(c(index.species.1, index.species.2, index.species.3))
length(index.species)

index.var <- tnrs.ncbi[which((tnrs.ncbi$Name_matched_rank == "subspecies" | tnrs.ncbi$Name_matched_rank == "unknown" | tnrs.ncbi$Name_matched_rank == "variety") & (tnrs.ncbi$Taxonomic_status == "Accepted" | tnrs.ncbi$Taxonomic_status == "No opinion" | tnrs.ncbi$Taxonomic_status == "Synonym")), 1]
length(index.var)

index.ncbi <- c(index.family, index.genus, index.species, index.var)
length((index.ncbi))

# identify certain and uncertain species:
tnrs.ncbi.certain <- tnrs.ncbi[tnrs.ncbi$Name_number %in% index.ncbi == T,]
dim(tnrs.ncbi.certain)
save(tnrs.ncbi.certain, file = "tnrs.ncbi.certain.Rdata")
write.csv(tnrs.ncbi.certain, file = "tnrs.ncbi.certain.csv")

tnrs.ncbi.uncertain <- tnrs.ncbi[tnrs.ncbi$Name_number %in% index.ncbi == F, ]
dim(tnrs.ncbi.uncertain)
save(tnrs.ncbi.uncertain, file = "tnrs.ncbi.uncertain.Rdata")
write.csv(tnrs.ncbi.uncertain, file = "tnrs.ncbi.uncertain.csv")

# in "ncbi uncertain":
# ... that are 

# identify species in "ncbi certain":
# ... that are potentially proper species that are pruned down to genus level and run them against TPL

# continue here: send corrected list to Jürgen:
# continue checking "uncertain" that were not sent to Jürgen

# for Jürgens list 

TPL("Nothofagus cliffortioides ", corr=T, diffchar = 9, max.distance = 9)

# select "Accepted_name" for "no opinion", "invalid", "illegitimate" -> run against TPL (using TNRS) (+ the five other sources)

# run again taxonstand::TPL
tpl.upload <- read.csv("TPLupload.csv", stringsAsFactors = F, head = F)
str(tpl.upload)

tpl.test <- TPL(tpl.upload[,1], corr = F)
write.csv(tpl.test, file = "tpl.test.csv")


# 6. identify non-matched and uncertain species list based on scores

# 7. run through list in 6 and correct some obvious misspellings (e.g. ABIESNORD., ..xboris.. etc. spec1 ...) + resolve some names according to 2.

# 8. run list from 7. against TPL (all sources)

# 9. select "No opinion" (e.g. for "subspecies" and "infraspec." levels and run against just "mtached genus" and "matched epithet" against the TPL and later tropicos etc...)

# do some final filtering to resolve stuff like:
# Polygala lila 132782	0.76	Polygala limae

# 10. at the very end, run everything that was matched against sources other than TPL, GCC or ILDIS against these three sources, to resolve some of the remaining synonyms

###################################################################
###################################################################
## May 2017: updated stats on taxonomic backbone for sPlot paper: #
###################################################################
###################################################################

# to get the updated stats, I need to reconstruct every single step:

# 13:45-14:15 - get new stats
load("backbone.splot2.1.try3.is.vascular.Rdata")

str(backbone.splot2.1.try3)
dim(backbone.splot2.1.try3)
summary(backbone.splot2.1.try3)
colnames(backbone.splot2.1.try3)
table(backbone.splot2.1.try3$is.vascular.species)

# how many unique names
length(unique(backbone.splot2.1.try3$names.sPlot.TRY))
# 130602 unique (uncleaned) names in splot and try together
length(unique(backbone.splot2.1.try3$Name_submitted))
# 120895 unique names were submitted after first cleaning

table(backbone.splot2.1.try3$is.vascular.species)
# 94.63% (123589) of all names in sPlot2.1 are vascular plants, 5.37% (7013) are non-vasular

# species in splot vs. try
table(backbone.splot2.1.try3$sPlot.TRY)
#    S    ST     T 
# 70329 24796 35477 

table(backbone.splot2.1.try3$Manual.matching)

# sPlot2b       x 
   7701    1675 

# how many accepted names, synonyms, .. 
table(backbone.splot2.1.try3$Status.correct)
                  Accepted No suitable matches found. 
                    102183                       2113 
                   Synonym                 Unresolved 
                     21383                       4923 

### damn! for getting the exact stats, I need to exactly reconstruct the workflow which 

###################################################################
###################################################################
# taxonomic standardization procedure, step by step:
######################################################################################
################################################

# describe workflow + do stats on the fly + visualize flowchart (all do all in parallel)

# 1) combine unique names lists of species in sPlot 2.0 and TRY 3.0:
# 1.1) read in sPlot

#############
# for STATS:

###

table(is.na(backbone.splot2.1.try3$sPlot2.1.TRY))
 FALSE   TRUE 
121861   8741 

###

table(is.na(backbone.splot2.1.try3$sPlot2.1.TRY))
    S    ST     T 
61588 24844 35429 



####

path.sPlot <- "/home/oliver/Dokumente/PhD/PostPhD/IDiv/sDiv/sPlot/Analyses/Data/Species/sPlot/sPlot_14_04_2015/"
# note, "sPlot_14_4_2015_species" no longer exists, but will be used for documentation purposes here

# ! NOTE, this is the version of splot to generate the backbone for to match splot 2.0 to try 3.0. In the following, I will describe the workflow for generating a backbone for this two versions of the the data bases. 
# the backbone use used in the workshop sPlot.III also contains the 7,701 additional (and/or different) species names in sPlot 2.1 (sPlot_2015_07_19). Because prior to the workshop, I had to do some ad-hoc
# since I no longer have "sPlot_14_4_2015_species"

# !!! for repeating the taxonomic standardization procedure for the additional species in future version in 

# for final R code published, generate Rmarkdown document (html and pdf for the appendix) and push on github

# strategy for the workflow: 
# 1) explain everything based and sPlot_14_4_2015_species and the TRY 3.0 species list (for the workflow text)
# 2) report statistics based sPlot_2015_07_19

#
splot.species <- read.csv(paste(path.sPlot, "sPlot_14_4_2015_species.csv", sep = ""), sep = "\t") # note, "sPlot_14_4_2015_species" no longer exists, but will be used for documentation purposes here
gc()

length(unique(splot.species$Matched.concept))

# use Matched.concept concept column
splot.species$Matched.concept<- as.character(splot.species$Matched.concept)
# ?! ask Florian about the turboveg-bit
# explain matched concept column a bit

# 1.2) read in TRY 3.0 species list
try3.species <- read.csv("/home/oliver/Dokumente/PhD/PostPhD/IDiv/sDiv/sPlot/Analyses/Data/Species/TRY/Species/TRY30_Gapfilling2015_Species.csv")
str(try3.species)
try3.species$Species <- as.character(try3.species$Species)

# 1.3) combine species lists into one unified species list:
spec.list.TRY.sPlot <- sort(unique(c(as.character(splot.species$Matched.concept), as.character(try3.species$Species))))
length(spec.list.TRY.sPlot)

# create dataframe that will later hold the original (uncleaned) names in sPlot and TRY 
spec.list.TRY.sPlot.2 <- cbind(spec.list.TRY.sPlot, spec.list.TRY.sPlot, spec.list.TRY.sPlot)

str(spec.list.TRY.sPlot.2)
dim(spec.list.TRY.sPlot.2)
spec.list.TRY.sPlot.2 <- as.data.frame(spec.list.TRY.sPlot.2)

# convert into characters
spec.list.TRY.sPlot.2[,1] <- as.character(spec.list.TRY.sPlot.2[,1])
spec.list.TRY.sPlot.2[,2] <- as.character(spec.list.TRY.sPlot.2[,2])
spec.list.TRY.sPlot.2[,3] <- as.character(spec.list.TRY.sPlot.2[,3])

# give column names
colnames(spec.list.TRY.sPlot.2) <- c("names.sPlot.TRY", "names.corr.string", "sPlot.TRY")
write.csv(spec.list.TRY.sPlot.2, file = "spec.list.TRY3.sPlot2.csv")

# spec.list.TRY3.sPlot2spec.list.TRY3.sPlot2 <- read.csv("spec.list.TRY3.sPlot2.csv")
# dim(spec.list.TRY3.sPlot2)

# note that this species list only contains 122901 species. the final backbone contains 7701 additional (and/or different) species from from the ad-hoc version sPlot_2015_07_19


# 2) add information on whether names come from sPlot (1), TRY (0) or both (2)

# which species are in sPlot 2.0
spec.list.TRY.sPlot.2$sPlot.TRY[which(spec.list.TRY.sPlot.2$names.sPlot.TRY %in% unique(splot.species$Matched.concept))] <- "S"

# which species are in TRY 3.0
spec.list.TRY.sPlot.2$sPlot.TRY[which(spec.list.TRY.sPlot.2$names.sPlot.TRY %in% unique(try3.species$Species))] <- "T"

# which species are in sPlot 2.0 and TRY 3.0

spec.list.TRY.sPlot.2$sPlot.TRY[which(spec.list.TRY.sPlot.2$names.sPlot.TRY %in% unique(try3.species$Species) & spec.list.TRY.sPlot.2$names.sPlot.TRY %in% unique(splot.species$Matched.concept))] <- "ST"

# ok, now we have assigned to each name whether it is found in splot and/or TRY

table(spec.list.TRY3.sPlot2$sPlot.TRY)

# again, recalculate that for splot 2.1 (exluding those species that are in splot2.0 but not in splot2.1)



# 3) weird names or manual names parsing
# based one the "matched concept" in splot, I manually generated list of 4093 "weird" species names (mainly trivial species names)
# (note, this was done in a very rough and preliminary way, so dont overemphasize that bit)
# basically, Jürgen went through manually, mainly correcting trivial names, ..
# e.g. (bring 5-10 expamples here for cases that could only be cleaned in that way):
# Gras silbrig Bl haarig 133106 -> Poaceae sp. [silbrig Bl haarig 133106]
# Ãƒâ€”Achnella species -> Achnella sp.
# [KHH Composite (breite Bl.)] -> Asteraceae sp. [breite Bl.]
# LICH Xanthomaculina hottentotta -> Xanthomaculina hottentotta
# cf. Silberknospe 134249 -> Spermatophyta sp. [Silberknospe 134249]
# 

# 4) use some string manipulation routines to do some a-priori cleaning prior to submission to TNRS

OriginalNames <- as.character(spec.list.TRY3.sPlot2$names.sPlot.TRY) # ! to be changed

# 4.1)
# some of the following code comes from Florian Jansen
### Name cleaning (spelling of ranks, name additions etc.)
OriginalNames <- gsub('*', '', OriginalNames, fixed=TRUE)
OriginalNames <- gsub('cf. ', '', OriginalNames, fixed=TRUE)
OriginalNames <- gsub('Cf. ', '', OriginalNames, fixed=TRUE)
OriginalNames <- gsub('[', '', OriginalNames, fixed=TRUE)
OriginalNames <- gsub(']', '', OriginalNames, fixed=TRUE)
OriginalNames <- gsub(' x ', ' ', OriginalNames, fixed=TRUE)
OriginalNames <- gsub('Ã—', '', OriginalNames, fixed=TRUE)
OriginalNames <- gsub('aff ', '', OriginalNames, fixed=TRUE)
OriginalNames <- gsub('(', '', OriginalNames, fixed=TRUE)
OriginalNames <- gsub(')', '', OriginalNames, fixed=TRUE)
OriginalNames <- gsub(' cf ', ' ', OriginalNames, fixed=TRUE)
OriginalNames <- gsub(' aff. ', ' ', OriginalNames, fixed=TRUE)
OriginalNames <- gsub('c‚e', 'ceae', OriginalNames, fixed=TRUE)
OriginalNames <- gsub('    ', ' ', OriginalNames, fixed=TRUE)
OriginalNames <- gsub('   ', ' ', OriginalNames, fixed=TRUE)
OriginalNames <- gsub('  ', ' ', OriginalNames, fixed=TRUE)
OriginalNames <- gsub('x-', '', OriginalNames, fixed=TRUE)
OriginalNames <- gsub('X-', '', OriginalNames, fixed=TRUE)
OriginalNames <- gsub('like ', '', OriginalNames, fixed=TRUE)  
OriginalNames <- gsub(',', '', OriginalNames, fixed=TRUE)  

# ? what is the following doing?:
# 4.2)
# for all names that have a number in their first word, and consist of > 1 words, remove that word
# ! check whether I have actually done that! yes, we did
library(stringr)
firstWordWithNumbers <- grepl('[0-9]', word(OriginalNames, 1))
numberOfWords <- sapply(gregexpr("\\W+", OriginalNames), length) + 1
OriginalNames[firstWordWithNumbers & numberOfWords > 1] <- sapply(OriginalNames[firstWordWithNumbers & numberOfWords > 1], function(x) substr(x, start=regexpr(pattern =' ', text=x)+1, stop=nchar(x)))

# 4.3)
# correct some species names abbreviations using vegdata::taxname.abbr
CleanedNames <- taxname.abbr(OriginalNames)
# give some examples

save(CleanedNames, file = "CleanedNames.Rdata")
write.csv(CleanedNames, file = "CleanedNames.csv")

# load("CleanedNames.Rdata")
length(CleanedNames)

#  create a data frame from the string cleaned names:
CleanedNames.df <- as.data.frame(CleanedNames, stringsAsFactors=FALSE)

spec.list.TRY.sPlot.3 <- cbind(spec.list.TRY.sPlot.2[,c(1,2,4)], CleanedNames.df, CleanedNames.df) # skip column "names.corr.string", as the cleanednames.df column as well as another column that will include Jürgens corrected names

dim(spec.list.TRY.sPlot.3)
# 122901
head(spec.list.TRY.sPlot.3)
colnames(spec.list.TRY.sPlot.3) <- c("index","original.names.sPlot.TRY","sPlot.TRY","CleanedNames","CleanedNames.Juergen")

Tax_Back_sPlot2_TRY3 <- spec.list.TRY.sPlot.3

save(Tax_Back_sPlot2_TRY3, file = "Tax_Back_sPlot2_TRY3.Rdata")
load("Tax_Back_sPlot2_TRY3.Rdata")
write.csv(Tax_Back_sPlot2_TRY3, file = "Tax_Back_sPlot2_TRY3.csv")

str(Tax_Back_sPlot2_TRY3)

# 5) substitute some cleaned names with Jürgens corrected names 
weird.JD <- read.csv("weird.names_JD_string_correct.csv")
str(weird.JD)
head(weird.JD)

sum(weird.JD$weird.names %in% Tax_Back_sPlot2_TRY3$original.names.sPlot.TRY)
# all 4093 names present in TB

index <- match(weird.JD$weird.names, Tax_Back_sPlot2_TRY3$original.names.sPlot.TRY)
Tax_Back_sPlot2_TRY3$CleanedNames.Juergen[index] <- weird.JD$Name.corrected

# 5.1) do some more cleaning on "CleanedNames.Juergen"
CleanedNames.Juergen <- Tax_Back_sPlot2_TRY3$CleanedNames.Juergen

write.csv(CleanedNames.Juergen, file = "CleanedNames.Juergen.csv")

# substitute old CleanedNames.Juergen with new string-manipulated one:
Tax_Back_sPlot2_TRY3$CleanedNames.Juergen <- CleanedNames.Juergen

save(Tax_Back_sPlot2_TRY3, file = "Tax_Back_sPlot2_TRY3.Rdata")

# 6) run cleaned names against TRNS (use six cores max), save chunks as csv-files to see where there are misspelled names


# slice CleanedNames into chunks for TNRS:

# for 5000 species
seq1 <- seq(from =1, to = 120001, 5000)
seq2 <- seq(from =5000, to = 125000, 5000)

# ! actually, we sliced it into chunks of 5000 names

# cbind(seq1, seq2)
library(foreach)

for(i in 1:length(seq1)) {
    write.csv(Tax_Back_sPlot2_TRY3$CleanedNames.Juergen[seq1[i]:seq2[i]], file = paste(paste("tnrs_submit", seq1[i], sep = "_"), "csv", sep = "."))
}

# 7) go to http://tnrs.iplantcollaborative.org/sources.html and submit the single species
# I used TNRS v.4, which became available in Aug 2015 (this version also included the plant list v.1.1)

# citation:
#To cite the Taxonomic Name Resolution Service please refer to the following publication:
#
#    Boyle, B. et al. 2013. The taxonomic name resolution service: an online tool for automated standardization of plant names. BMC Bioinformatics 14:16. doi:10.1186/1471-2105-14-16

#If the results derived from the TNRS are used in a publication, please cite:

#    The Taxonomic Name Resolution Service [Internet]. iPlant Collaborative. Version < VERSION NUMBER > [Accessed: ]. Available from: http://tnrs.iplantcollaborative.org.

#For example:

#    The Taxonomic Name Resolution Service [Internet]. iPlant Collaborative. Version 4.0 [Accessed: 20 Sep 2015]. Available from: http://tnrs.iplantcollaborative.org



# Which sources? 
# All (the five suggested sources)
# TPL (+ GCC and ILDIS)
# Tropicos
# NCBI
# USDA

#Finally, we also request that you acknowledge separately all taxonomic data sources used by the TNRS to process your data. Acknowledge only the sources you selected. Taxonomic sources should be cited as shown below. Note that the "Accessed" date is the date of the latest update of that source within the TNRS database, as noted on the Sources page of this website.

#    Tropicos.org [Internet]. Missouri Botanical Garden, St. Louis, MO, USA. [Accessed 19 Dec 2014]. Available from: http://www.tropicos.org

#    USDA, NRCS. The PLANTS Database [Internet]. National Plant Data Team, Greensboro, NC, USA. [Accessed: 17 Jan 2015]. Available from: http://plants.usda.gov

#    Flann, C, editor. Global Compositae Checklist [Internet]. 2009 - [Accessed: 21 Aug 2015]. Available from: www.compositae.org/checklist

#    Federhen S. The Taxonomy Project. 9 Oct 2002 [Updated 13 Aug 2003]. In: McEntyre J., Ostell J., editors. The NCBI Handbook [Internet]. National Center for Biotechnology Information, Bethesda, MD, USA. [Accessed: 25 Oct 2011]. Available from: http://www.ncbi.nlm.nih.gov/guide/taxonomy/

#    The Plant List (2013). Version 1.1. Published on the Internet; http://www.theplantlist.org/ [Accessed: 19 Aug 2015].

#    International Legume Database and Information Service, http://www.ildis.org/ [Accessed: 21 Aug 2015].


# use standard settings:

"Processing Mode: Selected mode:   Perform Name Resolution
 
Match Accuracy:  Allow partial matches, Selected minimum threshold: 0.05
 
Sources:  [ TPL, GCC, ILDIS, TROPICOS, USDA ]
 
Family Classification:  Selected classification source: TROPICOS"



# 8) read in TNRS tables 

library(doParallel)
# Find out how many cores are available (if you don't already know)
detectCores()
# Create cluster with desired number of cores
cl <- makeCluster(3)

# Register cluster
registerDoParallel(cl)

# Find out how many cores are being used
getDoParWorkers()

# based on all sources
setwd("/home/oliver/Downloads/")
# note that we dont have this single files anymore
system.time(
    x <- foreach(i = 1:length(seq1), .combine = rbind) %dopar% {
    read.csv(paste(paste("/home/oliver/Downloads/tnrs.tpl", seq1[i], sep = "."), "csv", sep = "."), sep = ",", stringsAsFactors = FALSE, skip = 0, head = T)[-1, ]
}
    )

tnrs.tpl <- x
# note, the full original tnrs.tpl including all 123,000+ species has been overwritten, and now instead only contains the  

# 9) # start consolidating:
# 9.1) inspect in the excel table (needs to be done manually):
# sort according to: Name_matched_rank (==Family), Taxonomic_status (==Accepted, Synomyn), Family_score (>0.9)

# assign index to first column:
tnrs.tpl$Name_number <- 1:length(tnrs.tpl$Name_number)

tnrs.tpl <- tnrs.tpl[,-1]

# start with the highest hierarchical level, family. select those names, at the family level that were either accepted names or synomym and have 
# manually checking the TRNS output reveals that all accepted names or synonyms, where fuzzy (partial) matching revealed a accuracy scores >0.88 are correct taxon names
# create "index.family"
# the similar manual checking procedure was applied to genus, species, etc.
index.family <- tnrs.tpl[which(tnrs.tpl$Name_matched_rank == "family" & (tnrs.tpl$Taxonomic_status == "Accepted" | tnrs.tpl$Taxonomic_status == "Synonym") & tnrs.tpl$Family_score > 0.88), 1]
length(index.family)


# 9.2) repeat selection for Name_matched_rank "forma" "genus" "infraspecies" ... change selection "score", e.g. lower (strong) threshold for species, higher (or no) threshold for infraspec., variety, ... (identify threshold by looking at the excel-table)
# create respective index
# 

# for forma
index.forma <- tnrs.tpl[which(tnrs.tpl$Name_matched_rank == "forma"), 1]
length(index.forma)

# genus
index.genus <- tnrs.tpl[which(tnrs.tpl$Name_matched_rank == "genus" & tnrs.tpl$Taxonomic_status == "Accepted" & tnrs.tpl$Genus_score > 0.83), 1]
length(index.genus)

# ... etc.

index.infraspec <- tnrs.tpl[which(tnrs.tpl$Name_matched_rank == "infraspecies"), 1]
length(index.infraspec)

index.species <- tnrs.tpl[which(tnrs.tpl$Name_matched_rank == "species" & (tnrs.tpl$Taxonomic_status == "Accepted" | tnrs.tpl$Taxonomic_status == "Synonym") & tnrs.tpl$Genus_score > 0.78 & tnrs.tpl$Name_score > 0.93), 1]
length(index.species1)

index.species <- tnrs.tpl[which(tnrs.tpl$Name_matched_rank == "species" & (tnrs.tpl$Taxonomic_status == "Accepted" | tnrs.tpl$Taxonomic_status == "Synonym") & tnrs.tpl$Specific_epithet_score > 0.78), 1]
length(index.species2)

index.species <- unique(c(index.species1, index.species2))
length(index.species)

index.subspec <- tnrs.tpl[which(tnrs.tpl$Name_matched_rank == "subspecies" & (tnrs.tpl$Taxonomic_status == "Accepted" | tnrs.tpl$Taxonomic_status == "Synonym")), 1]
length(index.subspec)

index.variety <- tnrs.tpl[which(tnrs.tpl$Name_matched_rank == "variety" & (tnrs.tpl$Taxonomic_status == "Accepted" | tnrs.tpl$Taxonomic_status == "Synonym")), 1]
length(index.variety)

# additional step: identifying "non-matched" species that are spermatophyta
index.spermatophyt <- tnrs.tpl[which(tnrs.tpl$Name_matched == "No suitable matches found." & word(tnrs.tpl$Name_submitted, 1) == "Spermatophyta"), 1]
length(index.spermatophyt)


# 9.3. identify those species that do not fulfill the search criteria, for further resolution other using sources other than TPL
# 
index.tpl <- c(index.family, index.forma, index.genus, index.species, index.subspec, index.variety, index.spermatophyt)
length((index.tpl))

tnrs.tpl.certain <- tnrs.tpl[index.tpl,]
dim(tnrs.tpl.certain)
save(tnrs.tpl.certain, file = "tnrs.tpl.certain.Rdata")
write.csv(tnrs.tpl.certain, file = "tnrs.tpl.certain.csv")

tnrs.tpl.uncertain <- tnrs.tpl[tnrs.tpl$Name_number %in% index.tpl == F, ]
dim(tnrs.tpl.uncertain)
save(tnrs.tpl.uncertain, file = "tnrs.tpl.uncertain.Rdata")
write.csv(tnrs.tpl.uncertain, file = "tnrs.tpl.uncertain.csv")

# generate list of species to be uploaded to TNRS:
write.csv(tnrs.tpl.uncertain[,2], file = "tnrs.tpl.uncertain.upload.csv")


# !!! remember, it is the first three hours of the day (9-12am) that determine your day
# 9:30-10:00: fuzzy matching
# 10:00-10:45 unresolved species (TPL & Jürgen)
# 10:45-11:15 adding final columns
# 11:15-11:45 dealing with additional species in sPlot2.1

# 9.4 resolve species that could not be resolved in with TNRS.tpl, using the TRNS.tropicos -> repeat the steps from tnrs.tpl

setwd("/home/oliver/Downloads/")
# note that we dont have this single files anymore
system.time(
    x <- foreach(i = 1:length(seq1), .combine = rbind) %dopar% {
    read.csv(paste(paste("/home/oliver/Downloads/tnrs.trop", seq1[i], sep = "."), "csv", sep = "."), sep = ",", stringsAsFactors = FALSE, skip = 0, head = T)[-1, ]
}
    )

tnrs.trop <- x

# tnrs.trop:
str(tnrs.trop)
tnrs.trop$Name_number <- 1:length(tnrs.trop$Name_number)
# reduce to the uncertain species from tnrs.tpl
tnrs.trop.small <- tnrs.trop[tnrs.all.small.uncertain$Name_number, ]
str(tnrs.trop.small)

save(tnrs.trop.small, file = "tnrs.trop.small.Rdata")
write.csv(tnrs.trop.small, file = "tnrs.trop.small.csv")

###
index.family <- tnrs.trop.small[which(tnrs.trop.small$Name_matched_rank == "family" & (tnrs.trop.small$Taxonomic_status == "Accepted"| tnrs.trop.small$Taxonomic_status == "Synonym")), 1]
length(index.family)

index.forma <- tnrs.trop.small[which(tnrs.trop.small$Name_matched_rank == "forma" & (tnrs.trop.small$Taxonomic_status == "Accepted" | tnrs.trop.small$Taxonomic_status == "Synonym")), 1]
length(index.forma)

index.genus <- tnrs.trop.small[which(tnrs.trop.small$Name_matched_rank == "genus" & (tnrs.trop.small$Taxonomic_status == "Accepted" | tnrs.trop.small$Taxonomic_status == "Synonym") & tnrs.trop.small$Genus_score > 0.83 & tnrs.trop.small$Name_score > 0.5), 1]
length(index.genus)

# continue here:
index.species1 <- tnrs.trop.small[which(tnrs.trop.small$Name_matched_rank == "species" & (tnrs.trop.small$Taxonomic_status == "Accepted" | tnrs.trop.small$Taxonomic_status == "Synonym") & tnrs.trop.small$Genus_score > 0.88 & tnrs.trop.small$Name_score > 0.9), 1]
length(index.species1)

index.species2 <- tnrs.trop.small[which(tnrs.trop.small$Name_matched_rank == "species" & (tnrs.trop.small$Taxonomic_status == "Accepted" | tnrs.trop.small$Taxonomic_status == "Synonym") & tnrs.trop.small$Genus_score > 0.78 & tnrs.trop.small$Name_score > 0.94), 1]
length(index.species1)

index.species3 <- tnrs.trop.small[which(tnrs.trop.small$Name_matched_rank == "species" & (tnrs.trop.small$Taxonomic_status == "Accepted" | tnrs.trop.small$Taxonomic_status == "Synonym") & tnrs.trop.small$Genus_score > 0.88 & tnrs.trop.small$Name_score > 0.49), 1]
length(index.species3)

index.species <- unique(c(index.species1, index.species2, index.species3))
length(index.species)

index.subspec <- tnrs.trop.small[which(tnrs.trop.small$Name_matched_rank == "subspecies" & (tnrs.trop.small$Taxonomic_status == "Accepted" | tnrs.trop.small$Taxonomic_status == "Synonym")), 1]
length(index.subspec)

index.variety <- tnrs.trop.small[which(tnrs.trop.small$Name_matched_rank == "variety" & (tnrs.trop.small$Taxonomic_status == "Accepted" | tnrs.trop.small$Taxonomic_status == "Synonym")), 1]
length(index.variety)

index.trop <- c(index.family, index.forma, index.genus, index.species, index.subspec, index.variety)
length((index.trop))

##
tnrs.trop.small.certain <- tnrs.trop.small[tnrs.trop.small$Name_number %in% index.trop == T,]
dim(tnrs.trop.small.certain)
save(tnrs.trop.small.certain, file = "tnrs.trop.small.certain.Rdata")
write.csv(tnrs.trop.small.certain, file = "tnrs.trop.small.certain.csv")

tnrs.trop.small.uncertain <- tnrs.trop.small[tnrs.trop.small$Name_number %in% index.trop == F, ]
dim(tnrs.trop.small.uncertain)
save(tnrs.trop.small.uncertain, file = "tnrs.trop.small.uncertain.Rdata")
write.csv(tnrs.trop.small.uncertain, file = "tnrs.trop.small.uncertain.csv")
index.subspec <- tnrs.trop.small[which(tnrs.trop.small$Name_matched_rank == "subspecies" & (tnrs.trop.small$Taxonomic_status == "Accepted" | tnrs.trop.small$Taxonomic_status == "Synonym")), 1]
length(index.subspec)

index.variety <- tnrs.trop.small[which(tnrs.trop.small$Name_matched_rank == "variety" & (tnrs.trop.small$Taxonomic_status == "Accepted" | tnrs.trop.small$Taxonomic_status == "Synonym")), 1]
length(index.variety)

index.trop <- c(index.family, index.forma, index.genus, index.species, index.subspec, index.variety)
length((index.trop))

##
tnrs.trop.small.certain <- tnrs.trop.small[tnrs.trop.small$Name_number %in% index.trop == T,]
dim(tnrs.trop.small.certain)
save(tnrs.trop.small.certain, file = "tnrs.trop.small.certain.Rdata")
write.csv(tnrs.trop.small.certain, file = "tnrs.trop.small.certain.csv")

tnrs.trop.small.uncertain <- tnrs.trop.small[tnrs.trop.small$Name_number %in% index.trop == F, ]
dim(tnrs.trop.small.uncertain)
save(tnrs.trop.small.uncertain, file = "tnrs.trop.small.uncertain.Rdata")
write.csv(tnrs.trop.small.uncertain, file = "tnrs.trop.small.uncertain.csv")

### run against NCBI
write.csv(tnrs.trop.small.uncertain$Name_submitted[1:5000], file = "trop.uncert.1.csv")
write.csv(tnrs.trop.small.uncertain$Name_submitted[5001:9641], file = "trop.uncert.5001.csv")


# 9.4) identify unresolved species (excluding "Spermatophyta...") from 1.-4. (which were not indexed according to my procedure above) and run against TPL again (using six sources BUT take NCBI first)

# 
tnrs.ncbi.1 <- read.csv("/home/oliver/Downloads/tnrs.trop.uncert.1.csv", stringsAsFactors = FALSE)[-1,]
tnrs.ncbi.2 <- read.csv("/home/oliver/Downloads/tnrs.trop.uncert.5001.csv", stringsAsFactors = FALSE)[-1,]

tnrs.ncbi <- rbind(tnrs.ncbi.1, tnrs.ncbi.2)
str(tnrs.ncbi)
range(tnrs.trop.small.uncertain$Name_number)
# give index:
tnrs.ncbi$Name_number <- tnrs.trop.small.uncertain$Name_number
range(tnrs.ncbi$Name_number)

save(tnrs.ncbi, file = "tnrs.ncbi.Rdata")
write.csv(tnrs.ncbi, file = "tnrs.ncbi.csv")

# for tnrs.ncbi, identify certain and uncertain species:
index.family <- tnrs.ncbi[which(tnrs.ncbi$Name_matched_rank == "family" & (tnrs.ncbi$Taxonomic_status == "Accepted"| tnrs.ncbi$Taxonomic_status == "Synonym") & tnrs.ncbi$Family_score > 0.85), 1]
length(index.family)

index.genus.1 <- tnrs.ncbi[which(tnrs.ncbi$Name_matched_rank == "genus" & (tnrs.ncbi$Taxonomic_status == "Accepted" | tnrs.ncbi$Taxonomic_status == "Synonym") & tnrs.ncbi$Genus_score > 0.89 & tnrs.ncbi$Name_score > 0.49), 1]
length(index.genus.1)

index.genus.2 <- tnrs.ncbi[which(tnrs.ncbi$Name_matched_rank == "genus" & (tnrs.ncbi$Taxonomic_status == "Accepted" | tnrs.ncbi$Taxonomic_status == "Synonym") & tnrs.ncbi$Genus_score > 0.99 & tnrs.ncbi$Name_score > 0.2), 1]
length(index.genus.2)

index.genus.3 <- tnrs.ncbi[which(tnrs.ncbi$Name_matched_rank == "genus" & tnrs.ncbi$Taxonomic_status == "No opinion" & tnrs.ncbi$Genus_score > 0.88 & tnrs.ncbi$Name_score > 0.49), 1]
length(index.genus.3)

index.genus <- unique(c(index.genus.1, index.genus.2, index.genus.3))
length(index.genus)

###
index.species.1 <- tnrs.ncbi[which(tnrs.ncbi$Name_matched_rank == "species" & (tnrs.ncbi$Taxonomic_status == "Accepted" | tnrs.ncbi$Taxonomic_status == "Synonym") & tnrs.ncbi$Name_score > 0.94), 1]
length(index.species.1)

index.species.2 <- tnrs.ncbi[which(tnrs.ncbi$Name_matched_rank == "species" & (tnrs.ncbi$Taxonomic_status == "Accepted" | tnrs.ncbi$Taxonomic_status == "Synonym") & tnrs.ncbi$Genus_score > 0.81 & tnrs.ncbi$Name_score > 0.51), 1]
length(index.species.2)

index.species.3 <- tnrs.ncbi[which(tnrs.ncbi$Name_matched_rank == "species" & tnrs.ncbi$Taxonomic_status == "No opinion"  & tnrs.ncbi$Genus_score > 0.7 & tnrs.ncbi$Specific_epithet_score > 0.75), 1]
length(index.species.3)

index.species <- unique(c(index.species.1, index.species.2, index.species.3))
length(index.species)

index.var <- tnrs.ncbi[which((tnrs.ncbi$Name_matched_rank == "subspecies" | tnrs.ncbi$Name_matched_rank == "unknown" | tnrs.ncbi$Name_matched_rank == "variety") & (tnrs.ncbi$Taxonomic_status == "Accepted" | tnrs.ncbi$Taxonomic_status == "No opinion" | tnrs.ncbi$Taxonomic_status == "Synonym")), 1]
length(index.var)

index.ncbi <- c(index.family, index.genus, index.species, index.var)
length((index.ncbi))

# identify certain and uncertain species:
tnrs.ncbi.certain <- tnrs.ncbi[tnrs.ncbi$Name_number %in% index.ncbi == T,]
dim(tnrs.ncbi.certain)
save(tnrs.ncbi.certain, file = "tnrs.ncbi.certain.Rdata")
write.csv(tnrs.ncbi.certain, file = "tnrs.ncbi.certain.csv")

tnrs.ncbi.uncertain <- tnrs.ncbi[tnrs.ncbi$Name_number %in% index.ncbi == F, ]
dim(tnrs.ncbi.uncertain)
save(tnrs.ncbi.uncertain, file = "tnrs.ncbi.uncertain.Rdata")
write.csv(tnrs.ncbi.uncertain, file = "tnrs.ncbi.uncertain.csv")

# -> tnrs.ncbi.uncertain gives us 1464 names, with which we do the following:
# 1) send 679 of them to Jürgen, but some of them I could resolve using the manual matching tools on the TPL homepage
# 2) the others i have checked manually

# 14:30-15:00 14.-16.nov. 2015
# in the list that i initially send to Jürgen, i corrected 62 more species using the manual name matiching tools on the TPL homepage
# e.g. Dicra vagin var. clathrata -> Dicranella vaginata

for.juergen.2 <- read.csv("for.juergen.2.csv")
head(for.juergen.2)

### further manually correct some further mispellings (e.g. ABIESNORD., ..xboris.. etc. spec1 ...) + resolve some names according to the TNRS workflow above

# first, select non-jürgen, corrected and correct species in "tnrs.ncbi.uncertain.corrected.csv"
# ! note, this file is in the download folder, so it no longer exists
ncbi.uncertain.corr <- read.csv("/home/oliver/Downloads/tnrs.ncbi.uncertain.corrected.csv")
# str(ncbi.uncertain.corr)
# i guess this file contains the 1464 uncertain species, yes they do

# select 679 species for jürgen and the species that i corrected manually:

index.juergen.corrected <- ncbi.uncertain.corr[which((ncbi.uncertain.corr$for_Jürgen == "x" | ncbi.uncertain.corr$corrected != "")), 2] 
length(index.juergen.corrected)


# further select some correct species within genus
index.correct.genus <- ncbi.uncertain.corr[which((ncbi.uncertain.corr$Name_matched_rank == "genus" & ncbi.uncertain.corr$Taxonomic_status == "Accepted" & ncbi.uncertain.corr$Overall_score > 0.6)), 2] 
length(index.correct.genus)

index.juergen.corrected <- ncbi.uncertain.corr[which((ncbi.uncertain.corr$for_Jürgen == "x" | ncbi.uncertain.corr$corrected != "")), 2] 
length(index.juergen.corrected)

#####
# further select some correct species within species
index.correct.species <- ncbi.uncertain.corr[which((ncbi.uncertain.corr$Name_matched_rank == "species" & ncbi.uncertain.corr$Taxonomic_status == "Accepted" & ncbi.uncertain.corr$Overall_score > 0.89)), 2] 
length(index.correct.species)

index.ncbi <- unique(c(index.juergen.corrected, index.correct.genus, index.correct.species))
length(index.ncbi)

# identify certain and uncertain species:
ncbi.uncertain.corr.certain <- ncbi.uncertain.corr[ncbi.uncertain.corr$Name_number %in% index.ncbi == T,]
dim(ncbi.uncertain.corr.certain)
save(ncbi.uncertain.corr.certain, file = "ncbi.uncertain.corr.certain.Rdata") 
write.csv(ncbi.uncertain.corr.certain, file = "ncbi.uncertain.corr.certain.csv")

ncbi.uncertain.corr.uncertain <- ncbi.uncertain.corr[ncbi.uncertain.corr$Name_number %in% index.ncbi == F, ]
dim(ncbi.uncertain.corr.uncertain)
save(ncbi.uncertain.corr.uncertain, file = "ncbi.uncertain.corr.uncertain.Rdata")
write.csv(ncbi.uncertain.corr.uncertain, file = "ncbi.uncertain.corr.uncertain.csv")

# ncbi.uncertain.corr.certain & ncbi.uncertain.corr.uncertain, indeed add up to the ncbi-uncertain species


# use TPL to resolve names in "ncbi.uncertain.corr.uncertain"
ncbi.uncertain <- as.character(ncbi.uncertain.corr.uncertain$Name_submitted)

# 1) run raw list (allow for fuzzy matching)
tpl.ncbi.1 <- TPL(ncbi.uncertain, corr=T, diffchar = 9, max.distance = 9)
tpl.ncbi.1 <- gsub("[", "", tpl.ncbi.1)
tpl.ncbi.1 <- gsub("]", "", tpl.ncbi.1)
tpl.ncbi.1 <- gsub("|", "", tpl.ncbi.1)
tpl.ncbi.1 <- gsub("?", "", tpl.ncbi.1)

write.csv(tpl.ncbi.1, file = "tpl.ncbi.1.csv")

# 2) extent each word eby "*", to allow for even fuzzier matching
ncbi.uncertain.2 <- paste(gsub(" ", "* ", ncbi.uncertain), "*", sep = "")

tpl.ncbi.2 <- TPL(ncbi.uncertain.2, corr=T, diffchar = 9, max.distance = 9)
write.csv(tpl.ncbi.2, file = "tpl.ncbi.2.csv")

# 3) cut to first 5 letter and extent by "*", to do more fuzzy matching

simpleCap3 <- function(x) {
  s <- strsplit(x, " ")[[1]]
  paste(paste(substring(s, 1,1), substring(s, 2,3), sep="", collapse="* "), "*", sep = "")
}

simpleCap5 <- function(x) {
  s <- strsplit(x, " ")[[1]]
  paste(paste(substring(s, 1,1), substring(s, 2,5), sep="", collapse="* "), "*", sep = "")
}

simpleCap7 <- function(x) {
  s <- strsplit(x, " ")[[1]]
  paste(paste(substring(s, 1,1), substring(s, 2,7), sep="", collapse="* "), "*", sep = "")
}

# apply the string truncation functions above:
ncbi.uncertain.3 <- sapply(ncbi.uncertain, simpleCap3)

# remove some strings to improve name matching
ncbi.uncertain.3 <- gsub("[", "", ncbi.uncertain.3, fixed = T)
ncbi.uncertain.3 <- gsub("]", "", ncbi.uncertain.3, fixed = T)
ncbi.uncertain.3 <- gsub("|", "", ncbi.uncertain.3, fixed = T)
ncbi.uncertain.3 <- gsub("?", "", ncbi.uncertain.3, fixed = T)
ncbi.uncertain.3 <- gsub("+", "", ncbi.uncertain.3, fixed = T)
ncbi.uncertain.3 <- gsub(".", "", ncbi.uncertain.3, fixed = T)
ncbi.uncertain.3 <- gsub("<", "", ncbi.uncertain.3, fixed = T)
ncbi.uncertain.3 <- gsub("/", "", ncbi.uncertain.3, fixed = T)
str(ncbi.uncertain.3)

tpl.ncbi.3 <- TPL(ncbi.uncertain.3, corr=T, diffchar = 9, max.distance = 9)
write.csv(tpl.ncbi.3, file = "tpl.ncbi.3.csv")

tpl.ncbi.5 <- TPL(ncbi.uncertain.5, corr=T, diffchar = 9, max.distance = 9)
write.csv(tpl.ncbi.5, file = "tpl.ncbi.5.csv")

tpl.ncbi.7 <- TPL(ncbi.uncertain.7, corr=T, diffchar = 9, max.distance = 9)
write.csv(tpl.ncbi.7, file = "tpl.ncbi.7.csv")

#  put tpl.ncbi tables together:
tpl.ncbi <- cbind(tpl.ncbi.1[,c(1,2,6,8,10,12)], tpl.ncbi.2[,c(6,8,10,12)], tpl.ncbi.3[,c(6,8,10,12)], tpl.ncbi.5[,c(6,8,10,12)], tpl.ncbi.7[,c(6,8,10,12)])

rownames(tpl.ncbi) <- rownames(tpl.ncbi.7)

tpl.ncbi <- cbind(ncbi.uncertain.corr.uncertain[,1:2], tpl.ncbi)
str(tpl.ncbi)
tpl.ncbi <- tpl.ncbi[,-1]

write.csv(tpl.ncbi, file = "tpl.ncbi.csv")
# manually select correct genera and species in "tpl.ncbi" and add columns "Genus.correct" and "Species.correct"

# load tpl.ncbi
tpl.ncbi.2 <- read.csv("tpl.ncbi.csv")
str(tpl.ncbi.2)
names(tpl.ncbi.2)
# select corrected species
tpl.ncbi.2$name.correct <- paste(tpl.ncbi.2$Genus.correct, tpl.ncbi.2$Species.correct)
index.corr <- tpl.ncbi.2[which(tpl.ncbi.2$name.correct != " "), 2] 

# which rows in ncbi.uncertain correspond to index.corr?
ncbi.uncertain.corr.uncertain.2 <- join(ncbi.uncertain.corr.uncertain, tpl.ncbi.2[,c(1,2,6,26:29)], by = "Name_number")

str(ncbi.uncertain.corr.uncertain.2)
names(ncbi.uncertain.corr.uncertain.2)

write.csv(ncbi.uncertain.corr.uncertain.2, file = "ncbi.uncertain.corr.uncertain.2.csv")

ncbi.uncertain.corr.uncertain.2 <- read.csv("ncbi.uncertain.corr.uncertain.2.csv")

# if names were not corrected put "Taxonomic.status" == ""
ncbi.uncertain.corr.uncertain.2$Status.correct[ncbi.uncertain.corr.uncertain.2$Status.correct==""] <- ncbi.uncertain.corr.uncertain.2$Taxonomic.status[ncbi.uncertain.corr.uncertain.2$Status.correct==""]

summary(ncbi.uncertain.corr.uncertain.2$Status.correct)
str(ncbi.uncertain.corr.uncertain.2$Status.correct)

# assign "No suitable matches found." to the remaining species:
ncbi.uncertain.corr.uncertain.2$Status.correct <- as.character(ncbi.uncertain.corr.uncertain.2$Status.correct)
ncbi.uncertain.corr.uncertain.2$Status.correct[is.na(ncbi.uncertain.corr.uncertain.2$Status.correct)] <- "No suitable matches found."

# add uncorrected names in "X" (names submitted) to "name.correct"
ncbi.uncertain.corr.uncertain.2$name.correct[ncbi.uncertain.corr.uncertain.2$Genus.correct==""] <- as.character(ncbi.uncertain.corr.uncertain.2[,41])[ncbi.uncertain.corr.uncertain.2$Genus.correct==""]

# add "No suitable matches found." to remaining species in "name.correct" according to "Status.correct"
ncbi.uncertain.corr.uncertain.2$name.correct[ncbi.uncertain.corr.uncertain.2$Status.correct=="No suitable matches found."] <- "No suitable matches found."

write.csv(ncbi.uncertain.corr.uncertain.2, file = "ncbi.uncertain.corr.uncertain.2.csv")

## done!! take "ncbi.uncertain.corr.uncertain.2" for merging with the other data sets

# 9.6: check ncbi.certain:
# a) create extra column (species.correct) and add species in "Jürgen.corrected (679) to "certain", status=accepted for resolved species, status="No suitable matches found." for the remaining non.resolved species

juergen.correct <- read.csv("/home/oliver/Dokumente/PhD/PostPhD/IDiv/sDiv/sPlot/Analyses/Code/Unresolved_sPlot2.0_TRY3.0_2_JD.csv", stringsAsFactors=FALSE)

# fill non-correctable species with "No suitable matches found."
juergen.correct$Taxon[juergen.correct$Taxon==""] <- "No suitable matches found."

str(juergen.correct)

str(ncbi.uncertain.corr.certain)

# join the two based on Name_number
ncbi.certain.juergen.corr <- join(ncbi.uncertain.corr.certain, juergen.correct[,c(2,3,8)], by = "Name_number")
str(ncbi.certain.juergen.corr)
write.csv(ncbi.certain.juergen.corr, file = "ncbi.certain.juergen.corr.csv")

ncbi.certain.juergen.corr.2 <- read.csv("ncbi.certain.juergen.corr.csv", stringsAsFactors=FALSE)
str(ncbi.certain.juergen.corr.2)

# add some more corrected species from ncbi.certain.juergen.corr.2$corrected to "name.correct"
ncbi.certain.juergen.corr.2$name.correct[is.na(ncbi.certain.juergen.corr.2$name.correct)] <- ncbi.certain.juergen.corr.2$corrected[is.na(ncbi.certain.juergen.corr.2$name.correct)]

write.csv(ncbi.certain.juergen.corr.2, file = "ncbi.certain.juergen.corr.2.csv")


# fill remaining missing names in "name.correct", because they were correctly resolved
ncbi.certain.juergen.corr.2$name.correct[ncbi.certain.juergen.corr.2$name.correct==""] <- ncbi.certain.juergen.corr.2$Name_matched[ncbi.certain.juergen.corr.2$name.correct==""]

# yay, the "ncbi.certain.juergen.corr.2" species are finished!!! now merge it with "ncbi.uncertain.corr.uncertain.2" (gives ~1400 species) !! add tag "manual matching" (means the scores from TNRS matching are useless here, but nevertheless keep them)

# .. and check other earlier tpl.ncbi.certain data for species that have been reduced to genus levels  (? is this the case in the tropicos, tpl data sets as well?)

# ncbi.certain.juergen.corr.2
# ncbi.uncertain.corr.uncertain.2

ncbi.certain.juergen.corr.3 <- read.csv("ncbi.certain.juergen.corr.3.csv", stringsAsFactors=FALSE)
str(ncbi.certain.juergen.corr.3)

ncbi.uncertain.corr.uncertain.3 <- read.csv("ncbi.uncertain.corr.uncertain.3.csv", stringsAsFactors=FALSE)
str(ncbi.uncertain.corr.uncertain.3)



## add status for "ncbi.certain.juergen.corr.3": "No suitable matches found." or "Accepted"
ncbi.certain.juergen.corr.3$Status.correct[ncbi.certain.juergen.corr.3$name.correct == "No suitable matches found."] <- "No suitable matches found."

ncbi.certain.juergen.corr.3$Status.correct[is.na(ncbi.certain.juergen.corr.3$Status.correct)] <- "Accepted"
write.csv(ncbi.certain.juergen.corr.3, file = "ncbi.certain.juergen.corr.3.csv")

# add manual matching == x
ncbi.certain.juergen.corr.3$Manual.matching <- "x"
ncbi.uncertain.corr.uncertain.3$Manual.matching <- "x"
write.csv(ncbi.certain.juergen.corr.3, file = "ncbi.certain.juergen.corr.3.csv")
write.csv(ncbi.uncertain.corr.uncertain.3, file = "ncbi.uncertain.corr.uncertain.3.csv")

# combine the two data sets:
names(ncbi.certain.juergen.corr.3)
names(ncbi.uncertain.corr.uncertain.3)

ncbi.certain.juergen.corr.3 <- ncbi.certain.juergen.corr.3[,-c(1,2,3)]
ncbi.uncertain.corr.uncertain.3 <- ncbi.uncertain.corr.uncertain.3[,-c(1,2)]

match(names(ncbi.uncertain.corr.uncertain.3), names(ncbi.certain.juergen.corr.3))

ncbi.uncertain.comb <- rbind(ncbi.uncertain.corr.uncertain.3, ncbi.certain.juergen.corr.3)
dim(ncbi.uncertain.comb)
write.csv(ncbi.uncertain.comb, file = "ncbi.uncertain.comb.csv")

## read in "tnrs.ncbi.certain"
tnrs.ncbi.certain <- read.csv("/home/oliver/Downloads/tnrs.ncbi.certain.csv", stringsAsFactors=FALSE)
str(tnrs.ncbi.certain)

# 10) resolve some more species that were previously reduced to genus-level by TNRS
# to resolve names where species were reduced to genus-level, identify "Name_submitted" where "Overall_score" == 0.5

index0.5 <- tnrs.ncbi.certain[which(tnrs.ncbi.certain$Overall_score == 0.5), 2]

tpl0.5 <- tnrs.ncbi.certain$Name_submitted[tnrs.ncbi.certain$Overall_score == 0.5]

names(tpl0.5) <- index0.5

str(tpl0.5)
length(tpl0.5)
tpl0.5[1:100]

save(tpl0.5, file = "tpl0.5.Rdata")

# do some string cleaning to improve matching:
tpl0.5 <- gsub("[", "", tpl0.5, fixed = T)
tpl0.5 <- gsub("]", "", tpl0.5, fixed = T)
tpl0.5 <- gsub("|", "", tpl0.5, fixed = T)
tpl0.5 <- gsub("?", "", tpl0.5, fixed = T)
tpl0.5 <- gsub("+", "", tpl0.5, fixed = T)
tpl0.5 <- gsub(".", "", tpl0.5, fixed = T)
tpl0.5 <- gsub("<", "", tpl0.5, fixed = T)
tpl0.5 <- gsub("/", "", tpl0.5, fixed = T)

# 1)
system.time(
tpl0.5.res <- TPL(tpl0.5, corr=T, diffchar = 2, max.distance = 1)
)
write.csv(tpl0.5.res, file = "tpl0.5.res.csv")


# 2)
tpl0.5.2 <- paste(gsub(" ", "* ", tpl0.5), "*", sep = "")
tpl0.5.2.res <- TPL(tpl0.5.2, corr=T, diffchar = 2, max.distance = 1)
write.csv(tpl0.5.2.res, file = "tpl0.5.2.res.csv")

# 3)
tpl0.5.5 <- sapply(tpl0.5, simpleCap5)
tpl0.5.5.res <- TPL(tpl0.5.5, corr=T, diffchar = 2, max.distance = 1)
write.csv(tpl0.5.5.res, file = "tpl0.5.5.res.csv")

# 4)
tpl0.5.7 <- sapply(tpl0.5, simpleCap7)
tpl0.5.7.res <- TPL(tpl0.5.7, corr=T, diffchar = 2, max.distance = 1)
write.csv(tpl0.5.7.res, file = "tpl0.5.7.res.csv")

tpl0.5.res <- read.csv("tpl0.5.res.csv", stringsAsFactors=FALSE)
tpl0.5.2.res <- read.csv("tpl0.5.2.res.csv", stringsAsFactors=FALSE)
tpl0.5.5.res <- read.csv("tpl0.5.5.res.csv", stringsAsFactors=FALSE)
tpl0.5.7.res <- read.csv("tpl0.5.7.res.csv", stringsAsFactors=FALSE)

tpl.res.comb <- cbind(tpl0.5.res[,c(1,2,3,7,9,11,13)],
tpl0.5.2.res[,c(7,9,11,13)], tpl0.5.5.res[,c(7,9,11,13)],
tpl0.5.7.res[,c(7,9,11,13)])
                                                                                   
head(tpl.res.comb)
write.csv(tpl.res.comb, file = "tpl.res.comb.csv")

tpl.res.comb <- read.csv("tpl.res.comb.csv", stringsAsFactors=FALSE)

# manually add and fill in new columns "Status.correct"	"Genus.correct"	"Species.correct" to "tpl.res.comb.csv"


# combine species.correct and genus.correct
tpl.res.comb <- read.csv("tpl.res.comb.csv", stringsAsFactors=FALSE)
str(tpl.res.comb)
names(tpl.res.comb)
tpl.res.comb$name.correct <- paste(tpl.res.comb$Genus.correct, tpl.res.comb$Species.correct)

tpl.res.comb.2 <- tpl.res.comb

# join "tnrs.ncbi.certain" and "tpl.res.comb.2"
names(tpl.res.comb.2)
names(tpl.res.comb.2)[2] <- "Name_number"

names(tnrs.ncbi.certain)

# continue here: get match correct
tnrs.ncbi.certain.0.5 <- join(tnrs.ncbi.certain[match(index0.5, tnrs.ncbi.certain$Name_number),], tpl.res.comb.2[,c(3,23:26)], by =
"Name_number")

write.csv(tnrs.ncbi.certain.0.5, file = "tnrs.ncbi.certain.0.5.csv")

# fill in extra columns in "tnrs.ncbi.certain.0.5"
tnrs.ncbi.certain.0.5 <- read.csv("tnrs.ncbi.certain.0.5.csv", stringsAsFactors=FALSE)
str(tnrs.ncbi.certain.0.5)
names(tnrs.ncbi.certain.0.5)
str(tnrs.ncbi.certain.0.5$Genus.correct)

# fill "Manual.matching"
tnrs.ncbi.certain.0.5$Manual.matching[tnrs.ncbi.certain.0.5$Genus.correct != ""] <- "x"

# fill "Status.correct"
tnrs.ncbi.certain.0.5$Status.correct[tnrs.ncbi.certain.0.5$Status.correct == ""] <- tnrs.ncbi.certain.0.5$Taxonomic_status[tnrs.ncbi.certain.0.5$Status.correct == ""]

# fill "name.correct"
tnrs.ncbi.certain.0.5$name.correct[tnrs.ncbi.certain.0.5$name.correct == " "] <- tnrs.ncbi.certain.0.5$Name_matched[tnrs.ncbi.certain.0.5$name.correct == " "]

write.csv(tnrs.ncbi.certain.0.5, file = "tnrs.ncbi.certain.0.5.csv")


# combine "tnrs.ncbi.certain.0.5" with the remaining "tnrs.ncbi.certain"
str(tnrs.ncbi.certain.0.5)
names(tnrs.ncbi.certain.0.5)

cert.0.5 <- tnrs.ncbi.certain[tnrs.ncbi.certain$Overall_score == 0.5,]
dim(cert.0.5)
str(cert.0.5)

cert.non.0.5 <- tnrs.ncbi.certain[tnrs.ncbi.certain$Overall_score != 0.5,]
dim(cert.non.0.5)
str(cert.non.0.5)
names(cert.non.0.5)

# add three more cols to "cert.non.0.5"
cert.non.0.5$Manual.matching <- NA
cert.non.0.5$Status.correct <- NA
cert.non.0.5$name.correct <- NA

tnrs.ncbi.certain.comb <- rbind(tnrs.ncbi.certain.0.5[,c(3:41,44)], cert.non.0.5[,c(2:41)])
dim(tnrs.ncbi.certain.comb)
write.csv(tnrs.ncbi.certain.comb, file = "tnrs.ncbi.certain.comb.csv")


## yay, now merge the big data sets
# 1) TPL.small.certain
load("tnrs.tpl.certain.Rdata")
dim(tnrs.tpl.certain)

# 2) all.small.certain
load("tnrs.all.small.certain.Rdata")
dim(tnrs.all.small.certain)

# 3) trop.small.certain
load("tnrs.trop.small.certain.Rdata")
dim(tnrs.trop.small.certain)

# combine the certain data sets
tnrs.tpl.all.trop.certain <- rbind(tnrs.tpl.certain, tnrs.all.small.certain, tnrs.trop.small.certain)
dim(tnrs.tpl.all.trop.certain)

# and add the four additional cols
names(tnrs.tpl.all.trop.certain)

tnrs.tpl.all.trop.certain$Manual.matching <- NA
tnrs.tpl.all.trop.certain$Status.correct <- NA
tnrs.tpl.all.trop.certain$name.correct <- NA
tnrs.tpl.all.trop.certain$rank.correct <- NA


# 4) pick the respective "ncbi" data sets
# for the 8177 certain species
names(tnrs.ncbi.certain.comb)
tnrs.ncbi.certain.comb$rank.correct <- NA
# combine the two lists
tnrs.tpl.all.trop.certain.2 <- rbind(tnrs.tpl.all.trop.certain, tnrs.ncbi.certain.comb)
dim(tnrs.tpl.all.trop.certain.2)
names(tnrs.tpl.all.trop.certain.2)

# now, take the combined uncertain species (Jürgens and the other)
names(ncbi.uncertain.comb)
# exclude columns "Jürgen" and "corrected"
ncbi.uncertain.comb.2 <- ncbi.uncertain.comb[,-c(5,6)]
names(ncbi.uncertain.comb.2)
ncbi.uncertain.comb.2$rank.correct <- NA

# combine them
tnrs.tpl.all.trop.tnrs.certain <- rbind(tnrs.tpl.all.trop.certain.2, ncbi.uncertain.comb.2)
write.csv(tnrs.tpl.all.trop.tnrs.certain, file = "tnrs.tpl.all.trop.tnrs.certain.csv")
save(tnrs.tpl.all.trop.tnrs.certain, file = "tnrs.tpl.all.trop.tnrs.certain.Rdata")

# correct one more species name
tnrs.tpl.all.trop.tnrs.certain$name.correct[which(tnrs.tpl.all.trop.tnrs.certain$name.correct == "ABIES NORDMANNIANA")] <- "Abies nordmanniana"


# FINAL cleaning:
# complement the last four columns
dim(tnrs.tpl.all.trop.tnrs.certain)
names(tnrs.tpl.all.trop.tnrs.certain)

# fill "rank.correct"
tnrs.tpl.all.trop.tnrs.certain.filled <- tnrs.tpl.all.trop.tnrs.certain

tnrs.tpl.all.trop.tnrs.certain.filled$rank.correct <- as.character(tnrs.tpl.all.trop.tnrs.certain.filled$rank.correct)

tnrs.tpl.all.trop.tnrs.certain.filled$rank.correct[is.na(tnrs.tpl.all.trop.tnrs.certain.filled$Manual.matching)] <- tnrs.tpl.all.trop.tnrs.certain.filled$Name_matched_rank[is.na(tnrs.tpl.all.trop.tnrs.certain.filled$Manual.matching)]

# fill "status.correct"
tnrs.tpl.all.trop.tnrs.certain.filled$Status.correct[is.na(tnrs.tpl.all.trop.tnrs.certain.filled$Manual.matching)] <- tnrs.tpl.all.trop.tnrs.certain.filled$Taxonomic_status[is.na(tnrs.tpl.all.trop.tnrs.certain.filled$Manual.matching)]

# fill "name.correct"
tnrs.tpl.all.trop.tnrs.certain.filled$name.correct[is.na(tnrs.tpl.all.trop.tnrs.certain.filled$Manual.matching)] <- tnrs.tpl.all.trop.tnrs.certain.filled$Accepted_name[is.na(tnrs.tpl.all.trop.tnrs.certain.filled$Manual.matching)]


# fill "name.correct" # if status.correct is "No opinion"
tnrs.tpl.all.trop.tnrs.certain.filled$name.correct[which(tnrs.tpl.all.trop.tnrs.certain.filled$Status.correct == "No opinion")] <- tnrs.tpl.all.trop.tnrs.certain.filled$Name_matched[which(tnrs.tpl.all.trop.tnrs.certain.filled$Status.correct == "No opinion")]

write.csv(tnrs.tpl.all.trop.tnrs.certain.filled, file = "tnrs.tpl.all.trop.tnrs.certain.filled.csv")


# in "tnrs.tpl.all.trop.tnrs.certain.filled" resolve some species manually on the TPL webpage


# resolve some more species that wree not resolved by tropicos:
tplupload <- read.csv("tplupload.csv", head = F)
tpl.res.67 <- TPL(as.character(tplupload[,1]), corr=T, diffchar = 9,
max.distance = 9)

write.csv(tpl.res.67, file = "tpl.res.67.csv")

# fill in names.short correct:
tnrs.tpl.all.trop.tnrs.certain.filled <- read.csv("tnrs.tpl.all.trop.tnrs.certain.filled.csv", stringsAsFactors=FALSE)

names(tnrs.tpl.all.trop.tnrs.certain.filled)
str(tnrs.tpl.all.trop.tnrs.certain.filled)

tnrs.tpl.all.trop.tnrs.certain.filled$name.short.correct <- as.character(tnrs.tpl.all.trop.tnrs.certain.filled$name.short.correct)

# identify number of words in names
wordcount <- sapply(gregexpr("\\S+", tnrs.tpl.all.trop.tnrs.certain.filled$name.correct), length)

# shorten names that have more than 1 word
tnrs.tpl.all.trop.tnrs.certain.filled$name.short.correct[wordcount>1] <- word(tnrs.tpl.all.trop.tnrs.certain.filled$name.correct[wordcount>1], 1, 2)

###
# fill in one-word names
tnrs.tpl.all.trop.tnrs.certain.filled$name.short.correct[wordcount==1] <- tnrs.tpl.all.trop.tnrs.certain.filled$name.correct[wordcount==1]

# where is the second word an x:
length(word(tnrs.tpl.all.trop.tnrs.certain.filled$name.short.correct[wordcount>1], 2)=="x")

write.csv(tnrs.tpl.all.trop.tnrs.certain.filled, file = "tnrs.tpl.all.trop.tnrs.certain.filled.csv")

tnrs.tpl.all.trop.tnrs.certain.filled$name.short.correct[wordcount>2][(word(tnrs.tpl.all.trop.tnrs.certain.filled$name.correct[wordcount>2], 2)=="x")] <- word(tnrs.tpl.all.trop.tnrs.certain.filled$name.correct[wordcount>2] ,c(1,3))

# set index where wordcount is greater 2 and the second word == "x"
index <- word(tnrs.tpl.all.trop.tnrs.certain.filled$name.correct[wordcount>2], 2) == "x"
# 7900 species with more than 2 words and where 2nd word is "x"

# remove " x " from those names
wo.x <- paste(word(tnrs.tpl.all.trop.tnrs.certain.filled$name.correct[wordcount>2][index],
1), word(tnrs.tpl.all.trop.tnrs.certain.filled$name.correct[wordcount>2][index],
3))

tnrs.tpl.all.trop.tnrs.certain.filled$name.short.correct[wordcount>2][index] <- wo.x

###
# correct "name.short correct"
tnrs.tpl.all.trop.tnrs.certain.filled <- read.csv("tnrs.tpl.all.trop.tnrs.certain.filled.csv", stringsAsFactors=FALSE)
tnrs.tpl.all.trop.tnrs.certain.filled$name.short.correct[tnrs.tpl.all.trop.tnrs.certain.filled$name.correct == "No suitable matches found."] <- NA

####
# fill in "rank.short.correct"
tnrs.tpl.all.trop.tnrs.certain.filled$rank.short.correct <- tnrs.tpl.all.trop.tnrs.certain.filled$rank.correct

table(tnrs.tpl.all.trop.tnrs.certain.filled$rank.short.correct)

tnrs.tpl.all.trop.tnrs.certain.filled$rank.short.correct[tnrs.tpl.all.trop.tnrs.certain.filled$rank.correct == "infraspecies"] <- "species"

tnrs.tpl.all.trop.tnrs.certain.filled$rank.short.correct[tnrs.tpl.all.trop.tnrs.certain.filled$rank.correct == "subspecies"] <- "species"

tnrs.tpl.all.trop.tnrs.certain.filled$rank.short.correct[tnrs.tpl.all.trop.tnrs.certain.filled$rank.correct == "subvariety"] <- "species"

tnrs.tpl.all.trop.tnrs.certain.filled$rank.short.correct[tnrs.tpl.all.trop.tnrs.certain.filled$rank.correct == "variety"] <- "species"

tnrs.tpl.all.trop.tnrs.certain.filled$rank.short.correct[tnrs.tpl.all.trop.tnrs.certain.filled$rank.correct == "forma"] <- "species"

tnrs.tpl.all.trop.tnrs.certain.filled$rank.short.correct[tnrs.tpl.all.trop.tnrs.certain.filled$rank.correct == "unknown"] <- "family"

write.csv(tnrs.tpl.all.trop.tnrs.certain.filled, file = "tnrs.tpl.all.trop.tnrs.certain.filled.csv")

####
# fix families
tnrs.tpl.all.trop.tnrs.certain.filled <- read.csv("tnrs.tpl.all.trop.tnrs.certain.filled.csv", stringsAsFactors=FALSE)

names(tnrs.tpl.all.trop.tnrs.certain.filled)
str(tnrs.tpl.all.trop.tnrs.certain.filled)

tnrs.tpl.all.trop.tnrs.certain.filled$family.correct <- as.character(tnrs.tpl.all.trop.tnrs.certain.filled$family.correct)

# rank==family
tnrs.tpl.all.trop.tnrs.certain.filled$family.correct[(is.na(tnrs.tpl.all.trop.tnrs.certain.filled$Manual.matching) & tnrs.tpl.all.trop.tnrs.certain.filled$rank.short.correct == "family")] <- 
    tnrs.tpl.all.trop.tnrs.certain.filled$name.correct[(is.na(tnrs.tpl.all.trop.tnrs.certain.filled$Manual.matching) & tnrs.tpl.all.trop.tnrs.certain.filled$rank.short.correct == "family")]

# other ranks
tnrs.tpl.all.trop.tnrs.certain.filled$family.correct[(is.na(tnrs.tpl.all.trop.tnrs.certain.filled$Manual.matching))]
<-
tnrs.tpl.all.trop.tnrs.certain.filled$Name_matched_accepted_family[(is.na(tnrs.tpl.all.trop.tnrs.certain.filled$Manual.matching))]

write.csv(tnrs.tpl.all.trop.tnrs.certain.filled, file = "tnrs.tpl.all.trop.tnrs.certain.filled.csv")

# almost done:
# link backbone with original names and splot-try code

splot.try3.code <- read.csv("spec.list.TRY3.sPlot2.csv", stringsAsFactors=FALSE)
str(splot.try3.code)

backbone.splot.try3 <- read.csv("tnrs.tpl.all.trop.tnrs.certain.filled.small.csv", stringsAsFactors=FALSE)
str(backbone.splot.try3)

backbone.splot.try3 <- join(splot.try3.code, backbone.splot.try3, by = "Name_number")
str(backbone.splot.try3)

table(backbone.splot.try3$Status.correct)

backbone.splot.try3$Status.correct[backbone.splot.try3$Status.correct == "No opinion"] <- "Unresolved"

write.csv(backbone.splot.try3, file = "backbone.splot.try3.csv")
save(backbone.splot.try3, file = "backbone.splot.try3.Rdata")

# #
table(backbone.splot.try3$sPlot.TRY)


#
table(backbone.splot.try3$Manual.matching)
   x 
1675 

#
table(backbone.splot.try3$Status.correct)
Accepted No suitable matches found. 
95485                       1692 
                   Synonym                 Unresolved 
                     20952                       4772 


#
length(unique(backbone.splot.try3$name.correct))-1
90696

#
length(unique(backbone.splot.try3$family.correct))-1
665

#
length(unique(backbone.splot.try3$name.short.correct))-1
86528

#
table(backbone.splot.try3$rank.short.correct)
 family   genus  higher species 
   1880   13383    1211  105818 

######################################
######################################
##########
### for the new stats of sPlot 2.1
##########

ind2.1 <- is.na(backbone.splot2.1.try3$sPlot2.1.TRY)==F
length(ind2.1)
table(backbone.splot2.1.try3$sPlot.TRY[ind2.1])

    S    ST     T 
61588 24796 35477 

sPlot2b       x 
   7694    1432 

table(backbone.splot2.1.try3$Manual.matching[ind2.1])

ind <- backbone.splot2.1.try3$names.sPlot.TRY[which(backbone.splot2.1.try3$Manual.matching == "sPlot2b")] %in% backbone.splot2.1.try3$names.sPlot.TRY[ind2.1][which(backbone.splot2.1.try3$Manual.matching[ind2.1] == "sPlot2b")] == F

backbone.splot2.1.try3$names.sPlot.TRY[which(backbone.splot2.1.try3$Manual.matching == "sPlot2b")][ind]

# the following species did not occur in splot2.0 under the exact same name, but were resolved under a slightly different name, e.g. "Betula petraea"
[1] "H947 \"Pinguicula rosa\""                 
[2] "Spilanthes \"prostrata\""                 
[3] "[ms283 Kraut mit \"Grewiafr\u0081chten\"]"
[4] "[ms356 \"Herzblatt\"]"                    
[5] "[ms356 \"Herzblatt"                       
[6] "Kochia \"Bassia\""                        
[7] "Betula \"petraea\""

# means there were only 7694 (instead of 7701) unresolved names added to sPlot2.1 

#
table(backbone.splot2.1.try3$Status.correct[ind2.1])

Accepted                    No suitable matches found. 
94068                       1902 
Synonym                     Unresolved 
21028                       4863 

#
length(unique(backbone.splot2.1.try3$name.correct[ind2.1]))-1
91063

#
length(unique(backbone.splot2.1.try3$family.correct[ind2.1]))-1
669

#
length(unique(backbone.splot2.1.try3$name.short.correct[ind2.1]))-1
86830

#
table(backbone.splot2.1.try3$rank.short.correct[ind2.1])

 family   genus  higher species 
   1745   12373    1020  105777 

table(is.na(backbone.splot2.1.try3$is.vascular.species[ind2.1]))

 FALSE   TRUE 
115676   6185 


#####################################
########################################
#################################

# rename "no opinion" -> "unresolved" ## done already above


# 16:25-16:55 dealing with additional species in sPlot2.1

# 10) add the 7701 species that were in the ad-hoc version of splot2.1 
####
# get the non-matching species for sPlot July 2015 that do not match with the backbone for April 2015:
####
miss.new <- read.csv("/home/oliver/Dokumente/PhD/PostPhD/IDiv/sDiv/sPlot/Analyses/Code/Mismatches_29_07_2015_new.csv")
dim(miss.new)
# there are 7701 names in the splot version 29_07_2015 that were not in splot 2.0 (april 2015) 
save(CleanedNames, file = "CleanedNames.Rdata")
write.csv(CleanedNames, file = "CleanedNames.csv")

# slice CleanedNames into chunks for TNRS:
# for 10,000 species
seq1 <- seq(from =1, to = 120001, 10000)
seq2 <- seq(from =10000, to = 130000, 10000)

# for 5000 species
seq1 <- seq(from =1, to = 120001, 5000)
seq2 <- seq(from =5000, to = 125000, 5000)

cbind(seq1,seq2)

# cbind(seq1, seq2)
library(foreach)

for(i in 1:length(seq1)) {
    write.csv(TNRS.TPL.2$TNRS.Name_submitted[seq1[i]:seq2[i]], file = paste(paste("tnrs_submit", seq1[i], sep = "_"), "csv", sep = "."))
}

# read in TNRS tables 

library(doParallel)
# Find out how many cores are available (if you don't already know)
detectCores()
# Create cluster with desired number of cores
cl <- makeCluster(3)

# Register cluster
registerDoParallel(cl)

# Find out how many cores are being used
getDoParWorkers()

# based on all sources
setwd("/home/oliver/Downloads/")

library(data.table)
x <- foreach(i = 1:length(seq1), .combine = rbind) %dopar% {
  read.table(paste(paste("tnrs.tpl", seq1[1], sep = "."), "txt", sep = "."))
}

library(data.table)

system.time(
    x <- foreach(i = 1:length(seq1), .combine = rbind) %dopar% {
    read.csv(paste(paste("/home/oliver/Downloads/tnrs.tpl", seq1[i], sep = "."), "csv", sep = "."), sep = ",", stringsAsFactors = FALSE, skip = 0, head = T)[-1, ]
}
    )

tnrs.tpl <- x

x <- read.csv(paste(paste("/home/oliver/Downloads/tnrs.tpl", seq1[24], sep = "."), "csv", sep = "."), sep = ",", stringsAsFactors = FALSE, skip = 0, head = T)[-1, ]
dim(x)
names(x)
x[1:10, c(2,37)]

write.csv(tnrs.tpl, file = "tnrs.tpl.csv")
save(tnrs.tpl, file = "tnrs.tpl.Rdata")

load("tnrs.tpl.Rdata")

###
# tpl output for non-matching species in 29_7_2015 output
###

tnrs.tpl.new <- read.csv("/home/oliver/Downloads/missing_tpl.txt", sep = "\t", stringsAsFactors = FALSE, skip = 0, head = T)[-1, ]
str(tnrs.tpl.new)

# check whether the submitted list for all sources 


##
#################################
library(taxize)
library(Taxonstand)

load("CleanedNames.Rdata")

str(CleanedNames)

system.time(
tnrs1 <- tnrs(query = CleanedNames[1:20000], source = "iPlant_TNRS")#[ , -c(5:7)]
    )
write.csv(tnrs1[ , c(1,2,4,5)], file = "tnrs1.csv")

###################################

system.time(
tnrs2 <- tnrs(query = CleanedNames[20001:40000], source = "iPlant_TNRS")#[ , -c(5:7)]
    )
write.csv(tnrs2[ , c(1,2,4,5)], file = "tnrs2.csv")

###################################
system.time(
    tnrs3 <- tnrs(query = CleanedNames[40001:60000], source = "iPlant_TNRS")#[ , -c(5:7)]
    )
write.csv(tnrs3[ , c(1,2,4,5)], file = "tnrs3.csv")
            
###################################
system.time(
    tnrs4 <- tnrs(query = CleanedNames[60001:80000], source = "iPlant_TNRS")#[ , -c(5:7)]
    )
write.csv(tnrs4[ , c(1,2,4,5)], file = "tnrs4.csv")

###################################
system.time(
    tnrs5 <- tnrs(query = CleanedNames[80001:100000], source = "iPlant_TNRS")#[ , -c(5:7)]
    )
write.csv(tnrs5[ , c(1,2,4,5)], file = "tnrs5.csv")
    
###################################
system.time(
    tnrs6 <- tnrs(query = CleanedNames[100001:122901], source = "iPlant_TNRS")#[ , -c(5:7)]
    )
write.csv(tnrs6[ , c(1,2,4,5)], file = "tnrs6.csv")

###################################

##
sp1 <- TPLck("Liliopsida", corr=TRUE, diffchar = 1, max.distance=1)
sp1


# what about species names that cannot be resolved by TNRS but that can be resolved by TPL?
# (e.g. Potentilla rhenana or Potentilla ikonokovii)
# in that case (where TNRS reduces and valid or mispelled name to a genus taxon), we need to run "CleanedNames" again against TPL

# error in tnrs2 and tnrs3 -> run in chunks of 1000

#####################################################

library(taxize)
library(Taxonstand)

load("CleanedNames.Rdata")

tnrs <- tnrs(query = CleanedNames[1:100], source = "iPlant_TNRS")[ , c(1,2,4,5)]

for (i in seq(from =50001, to = 60000, 1000)){
    nam <- CleanedNames[i:(i+999)]
    tnrs <- tnrs(query = nam, source = "iPlant_TNRS")[ , c(1,2,4,5)]
    write.csv(tnrs, paste(paste("tnrs.chunk", i), ".csv"))
}

######################################################

# 4) read in and combine tnrs tables (17.30-17.45)

tab <- NA
for (i in seq(from =20001, to = 59001, 1000))
{
    tab <- rbind(tab, read.csv(paste(paste("tnrs.chunk", i), ".csv")))
}

tnrs1 <- read.csv("tnrs1.csv")
tnrs4 <- read.csv("tnrs4.csv")
tnrs5 <- read.csv("tnrs5.csv")
tnrs6 <- read.csv("tnrs6.csv")

tab2 <- rbind(tnrs1, tab, tnrs4, tnrs5, tnrs6)

head(tab2)
str(tab2)
dim(tab2)

tab2$submittedname <- as.character(tab2$submittedname)
tab2$acceptedname <- as.character(tab2$acceptedname)
tab2$matchedname <- as.character(tab2$matchedname)

# 5) link cleaned names to backbone (cbind) check whether dataframes match

length(CleanedNames)
str(CleanedNames)

CleanedNames.df <- as.data.frame(CleanedNames, stringsAsFactors=FALSE)

spec.list.TRY.sPlot.2 <- read.csv("spec.list.TRY3.sPlot2.csv")
str(spec.list.TRY.sPlot.2)

spec.list.TRY.sPlot.3 <- cbind(spec.list.TRY.sPlot.2, CleanedNames.df)
dim(spec.list.TRY.sPlot.3)
# 122901
head(spec.list.TRY.sPlot.3)

spec.list.TRY.sPlot.3 <- spec.list.TRY.sPlot.3[,c(2,4,5)]
spec.list.TRY.sPlot.3[1100:1120,]

spec.list.TRY.sPlot.3$names.sPlot.TRY <- as.character(spec.list.TRY.sPlot.3$names.sPlot.TRY)

# 6) link TNRS names to cleaned names in backbone
# give informative colnames
colnames(tab2)[2] <- "CleanedNames"

library(dplyr)

spec.list.TRY.sPlot.TNRS <- anti_join(spec.list.TRY.sPlot.3, tab2)
dim(spec.list.TRY.sPlot.TNRS)

spec.list.TRY.sPlot.TNRS[1000:1100,c(1,3)]

# 122901 CleanedNames in the backbone
# of the 122901 submitted cleaned names 118471 were returned when running against TNRS
# what about the 4430 non-returned species? (check which of the submitted CleanedNames are not in the TNRS output?)

tab2$CleanedNames[which(tab2$CleanedNames %in% spec.list.TRY.sPlot.3$CleanedNames==F)]

# why are there 600 species names in 

# also, after merging, why are there 122499 in the merged (or inner_join) dataset (check which species are missing)

# Are all 

# Check whether all  

# 7) run "matched" TNRS names against TPL


# Monday: 
# - because TNRS does not names for all submitted, run TNRS on those that were not matched
# - further checking and cleaning
# - add family information
#  Leontodonhispidulus
# ABIESNORDMANNIANA


# check why tnrs function cannot connect to server

############################################################
## TNRS for the non-resolved names (maybe better to turn TPL and TNRS around)

# to do: sent in 100 species on 6 cores (later try 12 cores)

library(RCurl)
library(RJSONIO)

#noTPL.names <- paste(d, collapse=',')
noTPL.names <- paste(CleanedNames[20100:20200], collapse=',')
noTPL.names <- noTPL.names[!is.na(noTPL.names)]
#The string needs to be URL-encoded
noTPL.names <- curlEscape(noTPL.names)
#Send a request to the TNRS service
tnrs.api <- 'http://tnrs.iplantc.org/tnrsm-svc'
url <- paste(tnrs.api,'/matchNames?retrieve=best&names=', noTPL.names, sep='')
tnrs.json <- getURL(url)
# The response needs to be converted from JSON
tnrs.results <- fromJSON(tnrs.json)

dim(tnrs.results$items)
write.csv(tnrs.results$items, file = "tnrs.test300.csv")

# The corrected names are extracted from the response
names <- sapply(tnrs.results[[1]], function(x) c(x$nameSubmitted, x$acceptedName))

## try on 3 cores:

library(taxize)
library(Taxonstand)

load("CleanedNames.Rdata")
length(CleanedNames)

# try to run code on multiple cores
library(doParallel)
# Find out how many cores are available (if you don't already know)
detectCores()
# Create cluster with desired number of cores
cl <- makeCluster(3)

# Register cluster
registerDoParallel(cl)

# Find out how many cores are being used
getDoParWorkers()

# Use the rbind function to combine results

seq1 <- seq(from =1, to = 122901, 100)
seq2 <- seq(from =100, to = 123000, 100)

cbind(seq1, seq2)

## script partly borrowed by Florian Jansen

library(RCurl)
library(RJSONIO)

tnrs.api <- 'http://tnrs.iplantc.org/tnrsm-svc'
url <- paste(tnrs.api,'/matchNames?retrieve=best&names=', names, sep='')
tnrs.json <- getURL(url)

x <- foreach(i = 3:4, .combine = rbind) %dopar% { 
  require(RCurl)
  require(RJSONIO)                                         
  names <- paste(CleanedNames[seq1[i]:seq2[i]], collapse=',')
  names <- RCurl::curlEscape(names)
  tnrs.api <- 'http://tnrs.iplantc.org/tnrsm-svc'
  url <- paste(tnrs.api,'/matchNames?retrieve=best&names=', names, sep='')
  tnrs.json <- RCurl::getURL(url)
  tnrs.results <- jsonlite::fromJSON(tnrs.json)
  tnrs.results <- as.data.frame(tnrs.results$items[,c(2,4)])
  #return(as.data.frame(tnrs.results$items[,c(2,4)])) 
}

tnrs <- tnrs(query = CleanedNames[1:10], source = "iPlant_TNRS")[ , c(1,2,4,5)]


###  proper taxonomic backbone (final steps):
# TNRS crashed, check again 2pm
# 1) generate new cleaned list, one with and one without number as first word

# make sure that if the first word contains a number, append this word in []

# check whether strings got messed up in Jürgen's corrected names file:
weird.correct <- read.csv("weird.names_JD.csv")
weird.correct[1250:1253,]

OriginalNames[OriginalNames=="[ms644 Gentianac‚e schwach rosa]"]

OriginalNames[76578]

#OriginalNames.small <- OriginalNames[c(3:6, 100:105, 76484:76490)]

library(stringr)

# identify the orginal names that contain a number in their first word:
firstWordWithNumbers <- grepl('[0-9]', word(OriginalNames, 1))
# count the number of words:
numberOfWords <- sapply(gregexpr("\\W+", OriginalNames), length) + 1
# if first word has numbers put it in [] after the full names
OriginalNames[firstWordWithNumbers & numberOfWords > 1] <- paste(OriginalNames[firstWordWithNumbers & numberOfWords > 1],  " [", word(OriginalNames[firstWordWithNumbers & numberOfWords > 1], 1), "]", sep = "")

# for original names that have a number in their first word and which word count exceeds 1, only keep stuff that comes after that number:
OriginalNames[firstWordWithNumbers & numberOfWords > 1] <- sapply(OriginalNames[firstWordWithNumbers & numberOfWords > 1], function(x) substr(x, start=regexpr(pattern =' ', text=x)+1, stop=nchar(x)))

CleanedNames <- taxname.abbr(OriginalNames)
dup <- duplicated(CleanedNames)
sum(dup)

# rename some species that caused problems with TPL earlier
CleanedNames[which(CleanedNames=="Astragalus psoraloides")] <- "Astragalus gjunaicus"
CleanedNames[which(CleanedNames=="Hedysarum mackenzii")] <- "Hedysarum dasycarpum"

save(CleanedNames, file = "CleanedNames.Rdata")
write.csv(CleanedNames, file = "CleanedNames.csv")

# 2) substitute some of Jürgen's corrected names
# ! correct some messed up strings (encoding issue) from Jürgen's csv import manually in excel
# Thursday evening: 
# 1) match new cleaned list to original list -> save everything as Rdata; 
CleanedNames.df <- as.data.frame(CleanedNames, stringsAsFactors=FALSE)

spec.list.TRY.sPlot.3 <- cbind(spec.list.TRY.sPlot.2[,c(1,2,4)], CleanedNames.df, CleanedNames.df)
dim(spec.list.TRY.sPlot.3)
# 122901
head(spec.list.TRY.sPlot.3)
colnames(spec.list.TRY.sPlot.3) <- c("index","original.names.sPlot.TRY","sPlot.TRY","CleanedNames","CleanedNames.Juergen")

Tax_Back_sPlot2_TRY3 <- spec.list.TRY.sPlot.3

save(Tax_Back_sPlot2_TRY3, file = "Tax_Back_sPlot2_TRY3.Rdata")
load("Tax_Back_sPlot2_TRY3.Rdata")

str(Tax_Back_sPlot2_TRY3)

# 2) substitute some cleaned names with Jürgens corrected names 
weird.JD <- read.csv("weird.names_JD_string_correct.csv")
str(weird.JD)
head(weird.JD)
# 4093 names

sum(weird.JD$weird.names %in% Tax_Back_sPlot2_TRY3$original.names.sPlot.TRY)
# all 4093 names present in TB

# check 
write.csv(Tax_Back_sPlot2_TRY3, file = "Tax_Back_sPlot2_TRY3.csv")

index <- match(weird.JD$weird.names, Tax_Back_sPlot2_TRY3$original.names.sPlot.TRY)

# use syntax similar to that on for matching


# splot.species <- splot.species[-which(splot.species$PlotObservationID==index2a[1]),]  


Tax_Back_sPlot2_TRY3$CleanedNames.Juergen[index] <- weird.JD$Name.corrected

# 3) run cleaned names against TRNS (use six cores max), save chunks as csv-files to see where there are misspelled names


### do some more cleaning on "CleanedNames.Juergen"


CleanedNames.Juergen <- Tax_Back_sPlot2_TRY3$CleanedNames.Juergen


CleanedNames.Juergen <- gsub('*', '', CleanedNames.Juergen, fixed=TRUE)
CleanedNames.Juergen <- gsub('cf. ', '', CleanedNames.Juergen, fixed=TRUE)
CleanedNames.Juergen <- gsub('Cf. ', '', CleanedNames.Juergen, fixed=TRUE)
#CleanedNames.Juergen <- gsub('[', '', CleanedNames.Juergen, fixed=TRUE)
#CleanedNames.Juergen <- gsub(']', '', CleanedNames.Juergen, fixed=TRUE)
CleanedNames.Juergen <- gsub(' x ', ' ', CleanedNames.Juergen, fixed=TRUE)
CleanedNames.Juergen <- gsub('Ã—', '', CleanedNames.Juergen, fixed=TRUE)
CleanedNames.Juergen <- gsub('aff ', '', CleanedNames.Juergen, fixed=TRUE)
CleanedNames.Juergen <- gsub('(', '', CleanedNames.Juergen, fixed=TRUE)
CleanedNames.Juergen <- gsub(')', '', CleanedNames.Juergen, fixed=TRUE)
CleanedNames.Juergen <- gsub(' cf ', ' ', CleanedNames.Juergen, fixed=TRUE)
CleanedNames.Juergen <- gsub(' aff. ', ' ', CleanedNames.Juergen, fixed=TRUE)
CleanedNames.Juergen <- gsub('c‚e', 'ceae', CleanedNames.Juergen, fixed=TRUE)
CleanedNames.Juergen <- gsub('    ', ' ', CleanedNames.Juergen, fixed=TRUE)
CleanedNames.Juergen <- gsub('   ', ' ', CleanedNames.Juergen, fixed=TRUE)
CleanedNames.Juergen <- gsub('  ', ' ', CleanedNames.Juergen, fixed=TRUE)
CleanedNames.Juergen <- gsub('x-', '', CleanedNames.Juergen, fixed=TRUE)
CleanedNames.Juergen <- gsub('X-', '', CleanedNames.Juergen, fixed=TRUE)
CleanedNames.Juergen <- gsub('like ', '', CleanedNames.Juergen, fixed=TRUE)  
CleanedNames.Juergen <- gsub(',', '', CleanedNames.Juergen, fixed=TRUE)  
CleanedNames.Juergen <- gsub(',', '', CleanedNames.Juergen, fixed=TRUE)  
CleanedNames.Juergen <- gsub('=', ' ', CleanedNames.Juergen, fixed=TRUE)
CleanedNames.Juergen <- gsub('   ', '  ', CleanedNames.Juergen, fixed=TRUE)
CleanedNames.Juergen <- gsub('  ', ' ', CleanedNames.Juergen, fixed=TRUE)

write.csv(CleanedNames.Juergen, file = "CleanedNames.Juergen.csv")

Tax_Back_sPlot2_TRY3$CleanedNames.Juergen[Tax_Back_sPlot2_TRY3$CleanedNames.Juergen == "Agrostis x mercieri"]

CleanedNames[CleanedNames == "Agrostis x mercieri"]

Tax_Back_sPlot2_TRY3$CleanedNames.Juergen <- CleanedNames.Juergen

save(Tax_Back_sPlot2_TRY3, file = "Tax_Back_sPlot2_TRY3.Rdata")

# slice CleanedNames into chunks for TNRS:
# 
seq1 <- seq(from =1, to = 120001, 10000)
seq2 <- seq(from =10000, to = 130000, 10000)

# cbind(seq1, seq2)
library(foreach)

for(i in 1:length(seq1)) {
    write.csv(Tax_Back_sPlot2_TRY3$CleanedNames.Juergen[seq1[i]:seq2[i]], file = paste(paste("tnrs_submit", seq1[i], sep = "_"), "csv", sep = "."))
}


# identify species that are not matching (or have low prob. and are not Spermatophyta sp.)
# load 10000 species test data


tnrs.test <- read.csv("/home/oliver/Dokumente/PhD/PostPhD/IDiv/sDiv/sPlot/Analyses/Code/tnrs_retrieve_70001.csv")
dim(tnrs.test)

tnrs.test[1:5, ]
str(tnrs.test)

# 1) read in TNRS tables:
x <- foreach(i = 1:length(seq1), .combine = rbind) %dopar% {
  taxize::tnrs(query = CleanedNames[seq1[i]:seq2[i]], source = "iPlant_TNRS")
}



library(doParallel)
# Find out how many cores are available (if you don't already know)
detectCores()
# Create cluster with desired number of cores
cl <- makeCluster(2)

# Register cluster
registerDoParallel(cl)

# Find out how many cores are being used
getDoParWorkers()

# Use the rbind function to combine results

seq1 <- seq(from =1, to = 122901, 10000)

library(foreach)

tnrs.all <- NA

for(i in seq1) {
  tnrs.all <- rbind(tnrs.all, read.csv(paste(paste("/home/oliver/Dokumente/PhD/PostPhD/IDiv/sDiv/sPlot/Analyses/Code/tnrs.retrieve", i, sep = "."), "csv", sep = "."), stringsAsFactors=F))
}

TNRS.all <- tnrs.all[-1,]
dim(TNRS.all)
str(TNRS.all)
colnames(TNRS.all)

TNRS.all[1:10,36:37]


write.csv(TNRS.all[,-c(7,9,10,24,35:37)], file = "TNRS.all.csv")

# 2) merge with original names

load("Tax_Back_sPlot2_TRY3.Rdata")
names(Tax_Back_sPlot2_TRY3)

TNRS.all.2 <- cbind(Tax_Back_sPlot2_TRY3[,2], TNRS.all)
dim(TNRS.all.2)
names(TNRS.all.2)[1] <- "original.names.sPlot.TRY"
TNRS.all.2[1000:1100, c(1,5)]
TNRS.all.2[,1] <- as.character(TNRS.all.2[,1])

TNRS.all.2$Name_matched[1:100]

# select non-matched species:
library(stringr)
word("Spermatophyta sp. [Barleria lanceolata]", 1)

nonmatch <- TNRS.all.2$Name_submitted[which(TNRS.all.2$Name_matched == "No suitable matches found." & word(TNRS.all.2$Name_submitted, 1) != "Spermatophyta")]

length(nonmatch)

write.csv(nonmatch, file = "nonmatch.csv") # resolve this list again in TNRS and merge it with TNRS.all (~50 more species resolved)

nonmatch <- read.csv("nonmatch.csv", stringsAsFactors=F)
# match with TNRS.all 
TNRS.all[which(TNRS.all$Name_matched == "No suitable matches found." & word(TNRS.all$Name_submitted, 1) != "Spermatophyta") , ] <- nonmatch

TNRS.all.2[10:20, c(1:5)]

save(TNRS.all.2, file = "TNRS.all.2.Rdata")
write.csv(TNRS.all.2, file = "TNRS.all.2.csv")

# 3) run names matched against TPL
# to do Saturday: write script for server: multicore, 1000 species chunks, write chunks

# 4) resolve more species with gnr (taxize)

# 5) for poorly resolved TNRS species, run TPL on "submitted names"



library(Taxonstand)

TPL.test <- TPL(TNRS.all.2$Name_matched[100:200], genus = NULL, species = NULL, infrasp = NULL, infra = T, abbrev = TRUE, corr = TRUE, diffchar = 2, max.distance = 1, version = "1.1", file = "")

TPL.test[,c(1,2,6,8,10,12,16)]

colnames(TPL.test)

list1 <- c(1,2,3,4,5,)
list2 <- c(1,2,3,3,4,5)

identical(list1,list2)
all.equal(list1,list2)

# combine TNRS and TPL names check whether submitted names match
setwd("/home/oliver/Dokumente/PhD/PostPhD/IDiv/sDiv/sPlot/Analyses/Code/")
load("TNRS.all.2.Rdata")
load("TPL.all.Rdata")

str(TNRS.all.2)
str(TPL.all)

TNRS.all.3 <- TNRS.all.2[,c(1,3,4,5,6,7,12,13,14,15,16,17,18,26,27,28,30,32,33,35,36)]
colnames(TNRS.all.3)[2:21] <- paste("TNRS",colnames(TNRS.all.3)[2:21], sep = ".")

TPL.all.2 <- TPL.all[,c(1,2,3,4,6,8,9,10,12,13,16)]
colnames(TPL.all.2) <- paste("TPL",colnames(TPL.all.2), sep = ".")

# combine the two lists
TNRS.TPL <- cbind(Tax_Back_sPlot2_TRY3[,c(1,3)], TNRS.all.3, TPL.all.2)
names(TNRS.TPL)

save(TNRS.TPL, file = "TNRS.TPL.Rdata")
write.csv(TNRS.TPL, file = "TNRS.TPL.csv")
load("TNRS.TPL.Rdata")

str(TNRS.TPL)
sum(TNRS.TPL$TPL.Plant.Name.Index==F)
# 21993 names do not have a plant index

#### To do
names(TNRS.TPL)

# select uncertain
TNRS.TPL.uncertain <- TNRS.TPL[which(TNRS.TPL$TNRS.Overall_score<0.98 & TNRS.TPL$TNRS.Genus_score<0.8& TNRS.TPL$TNRS.Specific_epithet_score!=1),]
dim(TNRS.TPL.uncertain)

save(TNRS.TPL.uncertain, file = "TNRS.TPL.uncertain.Rdata")
write.csv(TNRS.TPL.uncertain, file = "TNRS.TPL.uncertain.csv")

TNRS.TPL.uncertain <- read.csv("TNRS.TPL.uncertain.csv")
head(TNRS.TPL.uncertain)
TNRS.TPL.uncertain[10:20,1:5]

# exclude word that start with "Spermatophyta"
firstWordSperm <- grepl('Spermatophyta', word(TNRS.TPL.uncertain$TNRS.Name_submitted, 1))
sum(firstWordSperm)
TNRS.TPL.uncertain.2 <- TNRS.TPL.uncertain[firstWordSperm,]
TNRS.TPL.uncertain.3 <- TNRS.TPL.uncertain[firstWordSperm==F,]
write.csv(TNRS.TPL.uncertain.2, file = "TNRS.TPL.uncertain.2.csv")
write.csv(TNRS.TPL.uncertain.3, file = "TNRS.TPL.uncertain.3.csv")

TNRS.TPL.uncertain.3 <- read.csv("TNRS.TPL.uncertain.3.csv")

save(TNRS.TPL.uncertain.3, file = "TNRS.TPL.uncertain.3.Rdata")

# run against TPL (13.00 - 13.30) (on cluster)
load("TNRS.TPL.Rdata")
load("uncertain.655.TPL.Rdata")
load("TNRS.TPL.uncertain.3.Rdata")
uncertain.655.TPL <- x
str(uncertain.655.TPL)
str(TNRS.TPL.uncertain.3)

uncertain.655.TPL.index <- cbind(TNRS.TPL.uncertain.3[,3:5], uncertain.655.TPL)

# merge uncertain.list with TNRS.TPL list
TNRS.TPL.2 <- TNRS.TPL

# continue here !!!!! check whether same columns are selected
TNRS.TPL.2[uncertain.655.TPL.index$index, c(1,2,3, 24,25,26,27,28:34)] <- uncertain.655.TPL.index[,-c(8,10,14,17,18,20)]
str(TNRS.TPL.2)
names(TNRS.TPL.2)
head(TNRS.TPL.2)
save(TNRS.TPL.2, file = "TNRS.TPL.2.Rdata")

write.csv(TNRS.TPL.2, file = "TNRS.TPL.2.csv")


str(uncertain.655.TPL.index)
'data.frame':	655 obs. of  20 variables:
 $ index                   : int  55 129 1526 1527 1543 1838 3542 4849 4854 4855 ...
 $ sPlot.TRY               : Factor w/ 3 levels "S","ST","T": 3 3 3 3 3 3 1 1 1 1 ...
 $ original.names.sPlot.TRY: Factor w/ 655 levels "ABDILOBARANA sp",..: 1 2 4 5 6 7 8 10 11 12 ...
 $ Genus                   : chr  "ABDILOBARANA" "ABIES" "ACARIQUARANA" "ACARIQUARA" ...
 $ Species                 : chr  NA "nordmanniana" NA NA ...
 $ Abbrev                  : chr  NA NA NA NA ...
 $ Infraspecific           : chr  "" "" "" "" ...
 $ ID                      : chr  "" "kew-2609993" "" "" ...
 $ Plant.Name.Index        : logi  FALSE TRUE FALSE FALSE FALSE FALSE ...
 $ TPL_version             : chr  "1.1" "1.1" "1.1" "1.1" ...
 $ Taxonomic.status        : chr  "" "Accepted" "" "" ...
 $ Family                  : chr  "" "Pinaceae" "" "" ...
 $ New.Genus               : chr  "ABDILOBARANA" "Abies" "ACARIQUARANA" "ACARIQUARA" ...
 $ New.Hybrid.marker       : chr  "" "" "" "" ...
 $ New.Species             : chr  NA "nordmanniana" NA NA ...
 $ New.Infraspecific       : chr  "" "" "" "" ...
 $ Authority               : chr  "" "(Steven) Spach" "" "" ...
 $ New.ID                  : chr  "" "kew-2609993" "" "" ...
 $ Typo                    : logi  FALSE FALSE FALSE FALSE FALSE FALSE ...
 $ WFormat                 : logi  FALSE FALSE FALSE FALSE FALSE FALSE ...

# convert factors into characters:
uncertain.655.TPL.index[,2] <- as.character(uncertain.655.TPL.index[,2])
uncertain.655.TPL.index[,3] <- as.character(uncertain.655.TPL.index[,3])


# which "TPL.Plant.Name.Index" == FALSE
TNRS.TPL.index.FALSE <- TNRS.TPL.2[which(TNRS.TPL.2$TPL.Plant.Name.Index==FALSE),]
str(TNRS.TPL.index.FALSE)
save(TNRS.TPL.index.FALSE, file = "TNRS.TPL.index.FALSE.Rdata")
write.csv(TNRS.TPL.index.FALSE, file = "TNRS.TPL.index.FALSE.csv")

# run non-matched names against "gnr_resolve"
load("TNRS.TPL.index.FALSE.Rdata")
str(TNRS.TPL.index.FALSE)

# Problem: some species that have no TPL.ID cannot be resolved with "gnr.resolve":
# e.g. Antylis barba-jovis .. -> in that case take the matched name from TNRS (if name score is >0.9)
# or species names is excluded, and just the genus name remains: e.g. Archangelica tympanodes
# -> in that case keep the full matched name from TNRS if probability is high
# Arcypteris
# Baikaea insignis
# Baphia keckii
# Benstonea monticola

# species name is pruned to genus 
# Bombacopsis flaviflora -> Bombacopsis (according to TNRS: Pachira)
# -> in this case take accepted name from TNRS

# there are still some cutoff names:
# Apium graveo subsp. butronensis

# make sure not assign family and higher-order information to genus after TPL scrubbing

# assign "Spermatophyta" MOST non-assigned species, BUT manually check for liliopsida, fungi, lichen, moss, pteridophyta, dicots ...

# extra columns for classification:

# extra column: level taxonomic information (species, genus, family ... order etc)


##  some testing strange names:
sp1 <- TPLck("Jutai acu", corr=TRUE, diffchar = 2, max.distance=2)
sp1

sp1 <- TPL(missing.2, corr=TRUE, diffchar = 2, max.distance=2)
sp1

missing.2 <- gsub("_", " ", missing)


library(taxize)
library(foreach)
library(doParallel)

detectCores()
cl <- makeCluster(3)
registerDoParallel(cl)
getDoParWorkers()

spec <- c("Poa annua","Verbena","Chenopodioideae","adsfa","Dacryodes 1","Cyperales","Davenportia davenportia")

spec <- TNRS.TPL.index.FALSE$TNRS.Name_submitted

# gnr_resolve changes order of plant names in a submitted list ... therefore needs to ran in a foreach-loop
# (test run time for subset of 100 species, on 12 cores)

system.time(
    x <- foreach(i = 4350:4355, .combine = rbind) %dopar% {
        taxize::gnr_resolve(names = spec[i], resolve_once = TRUE, highestscore = TRUE, stripauthority = TRUE, best_match_only = F, data_source_ids = c(1,2,3,4,5,9,10,12,13,15,16,20,28,31), preferred_data_sources = c(1,2,3,4,5,9,10,12,13,15,16,20,28,31))$results[1,]
    }
    )
x

write.csv(sources, file = "sources.csv")

taxize::gnr_resolve(names = "Hepatophyta", resolve_once = T, highestscore = T, stripauthority = TRUE, best_match_only = F, data_source_ids = c(1,2,3,4,5,6,7,9,10,11,13,15,16,20,28,31,108,147,150,165,167,176), preferred_data_sources = c(1,2,3,4,5,9,10,12,13,15,16,20,28,31))

spec[1002]: "Anonaceae sp1 UNA1"
spec[1018]: "Anthocephalus"

gnr_resolve(names = "Jutai acu")

taxize::gnr_resolve(names = "Hypnales Slaapmossen - Feather mosses | Hypnales Slaa", resolve_once = T, highestscore = T, stripauthority = TRUE, best_match_only = T)

lookup_table("Trentepohlia", missing_action = "NA")


temp <- gnr_resolve(names = "JM Karin K Polygala micrantha Perr. & Guill.", resolve_once = TRUE, highestscore = TRUE, best_match_only = TRUE)$results[1,]
temp$results

# read in gnr.resolve.list (has been generated on RStudio-Server)
# create "matched_name3" column

FALSE.gnr <- read.csv("TNRS.TPL.index.FALSE.gnr.csv")
str(FALSE.gnr)

FALSE.gnr$matched_name2 <- as.character(FALSE.gnr$matched_name2)
FALSE.gnr$submitted_name <- as.character(FALSE.gnr$submitted_name)

FALSE.gnr$matched_name3 <- FALSE.gnr$matched_name2

FALSE.gnr$matched_name3[which(is.na(FALSE.gnr$score))] <- FALSE.gnr$submitted_name[which(is.na(FALSE.gnr$score))]

# substitute "one-word" names with the full names
library(stringr)
numberOfWords <- str_count(FALSE.gnr$matched_name2, "\\S+")
str(numberOfWords)

FALSE.gnr$matched_name3[which(numberOfWords<2)] <- FALSE.gnr$submitted_name[which(numberOfWords<2)]

# re-run "matched_name3" against TPL
save(FALSE.gnr, file = "FALSE.gnr.Rdata")
     
# merge FALSE.gnr.TPL with 
load("FALSE.gnr.TPL.Rdata")
load("FALSE.gnr.Rdata")
str(FALSE.gnr)
str(FALSE.gnr.TPL)

# continue here
FALSE.gnr.TPL.ID <- cbind(FALSE.gnr[,c(2,3)], FALSE.gnr.TPL)
head(FALSE.gnr.TPL.ID)

FALSE.gnr.TPL.ID[,2] <- as.character(FALSE.gnr.TPL.ID[,2])

# continue here
TNRS.TPL.2[FALSE.gnr.TPL.ID$index, c(1,2, 24,25,26,27,28:34)] <- FALSE.gnr.TPL.ID[,c(1:6,8,10,11,12,14,15,18)]

str(FALSE.gnr.TPL.ID[,-c(8,10,14,17,18,20)])
names(FALSE.gnr.TPL.ID[,c(1:6,8,10,11,12,14,15,18)])
str(TNRS.TPL.2[FALSE.gnr.TPL.ID$index, c(1,2, 24,25,26,27,28:34)])
names(TNRS.TPL.2[FALSE.gnr.TPL.ID$index, c(1,2, 24,25,26,27,28:34)])

save(TNRS.TPL.2, file = "TNRS.TPL.2.Rdata")
load("TNRS.TPL.2.Rdata")
write.csv(TNRS.TPL.2, file = "TNRS.TPL.2.csv")
names(TNRS.TPL.2)

sum(TNRS.TPL.2$TPL.Plant.Name.Index!=T)
sum(TNRS.TPL.2$TPL.Plant.Name.Index==T)

# which TPL.index==FALSE, TNRS.accepted 
TNRS.accept.TPL.index.false <- TNRS.TPL.2[which(TNRS.TPL.2$TPL.Plant.Name.Index==FALSE & TNRS.TPL.2$TNRS.Taxonomic_status=="Accepted"),]
dim(TNRS.accept.TPL.index.false)
write.csv(TNRS.accept.TPL.index.false, file = "TNRS.accept.TPL.index.false.csv")


# which typo=TRUE and number of strings <6:
dim(TNRS.TPL.2)
sum(TNRS.TPL.2$TPL.Typo)
# 1259

# write script for classification (for genus or higher order information)
out <- classification(c("Hepatophyta"), return_id=FALSE, db = c("itis"))
cbind(out)


spec.2 <- x$matched_name2

x <- foreach(i = 1:length(spec.2), .combine = dplyr::bind_rows) %dopar% {
    as.data.frame(cbind(classification(spec.2[i], return_id=FALSE, db = c("itis"))))
}

a <- cbind(classification(spec.2[1], return_id=FALSE, db = c("itis")))
b <- cbind(classification(spec.2[2], return_id=FALSE, db = c("itis")))
c <- as.data.frame(cbind(classification(spec.2[7], return_id=FALSE, db = c("itis"))))
d <- as.data.frame(cbind(classification(spec.2[4], return_id=FALSE, db = c("itis"))))

library(dplyr)
bind_rows(a,b,c)


#######################
### classfication #
#######################

 (out <- get_ids(names=c("Laricifomes"), db = c("itis","ncbi"))) # Laricifomes officinalis
     (cl <- classification(out))
     rbind(cl)
     ## cbind with so many names results in some messy data
     cbind(cl)
     ## so you can turn off return_id
     cbind(classification(out, return_id=FALSE))

     write.csv(cbind( classification(out, return_id=FALSE)), file = "class.csv")
########

library(stringr)

w <- data.frame(c("a;b","a;b"))
w[,1] <- as.character(w[,1])


new <- apply(w, 1, FUN=function(x){cbind(unlist(strsplit(x,";")))})


names <- paste("Polygonum longisetum", collapse=',')
  names <- RCurl::curlEscape(names)
  tnrs.api <- 'http://tnrs.iplantc.org/tnrsm-svc'
  url <- paste(tnrs.api,'/matchNames?retrieve=best&names=', names, sep='')
  tnrs.json <- RCurl::getURL(url)
  tnrs.results <- jsonlite::fromJSON(tnrs.json)
  tnrs.results

Tax_Back_sPlot2_TRY3$CleanedNames.Juergen[Tax_Back_sPlot2_TRY3$CleanedNames.Juergen == "Spinus pinus"]

library(TaxonLookup)
lookup_table(c("Fuscospora"), missing_action = "NA")

synonyms("Fuscospora", db=c("itis"))

tnrs(query = "Verbena urticafolium", source = "NCBI,MSW3,iPlant_TNRS", code = "ICN,ICNB,ICBN,ICNCP")

########################################################
######################################
# name resolution using new TNRS (September 2015):
######################################
##########################################
# check whether submitted names match with cleaned names:

####
## for the new non-matching species in the July version:
###

# load new match from oct. 2016:
tnrs.tpl.1 <- read.csv("/home/oliver/Downloads/tnrs.tpl.1.txt", sep = "\t")[-1,]
str(tnrs.tpl.1)

tnrs.tpl.2 <- read.csv("/home/oliver/Downloads/tnrs.tpl.2.csv")
str(tnrs.tpl.2)
# "Herzblatt had to be corrected (line 1943)

tnrs.tpl.3 <- read.csv("/home/oliver/Downloads/tnrs.tpl.3.txt", sep = "\t")
str(tnrs.tpl.3)

tnrs.tpl.4 <- read.csv("/home/oliver/Downloads/tnrs.tpl.4.txt", sep = "\t")
str(tnrs.tpl.4)

tnrs.tpl <- rbind(tnrs.tpl.1[,-37], tnrs.tpl.2, tnrs.tpl.3, tnrs.tpl.4)
dim(tnrs.tpl)
str(tnrs.tpl)

write.csv(tnrs.tpl, file = "tnrs.tpl.csv")

tnrs.tpl <- read.csv("tnrs.tpl.csv")

# merge them with "cleaned names list and with the original names"
head(miss.clean)

colnames(miss.clean) <- c("names.sPlot.TRY", "names.corr.string")

###

str(tnrs.tpl.new)
tnrs.tpl <- tnrs.tpl.new
#####



TNRS.TPL.2$TNRS.Name_submitted[TNRS.TPL.2$TNRS.Name_submitted %in% tnrs.trop$Name_submitted == F]
# all match instead of three species:
# [1] "Antimima sp. [kahnf\"\"rmig]"                        
# [2] "Spermatophyta sp. [Geophyt sternf\"\"rmig]"          
# [3] "Spermatophyta sp. [Strauch \"\"Oraniquelocarpus\"\"]"

which(TNRS.TPL.2$TNRS.Name_submitted %in% tnrs.trop$Name_submitted == F)
TNRS.TPL.2$TNRS.Name_submitted[c(8349 , 51560, 110472)]
tnrs.trop$Name_submitted[c(8349 , 51560, 110472)]

write.csv(table(tnrs.tpl$Taxonomic_status), file = "tab_tax.stat_tnrs.tpl.csv")
write.csv(table(tnrs.all$Taxonomic_status), file = "tab_tax.stat_tnrs.all.csv")
write.csv(table(tnrs.trop$Taxonomic_status), file = "tab_tax.stat_tnrs.trop.csv")

# stats for "name_matched_rank"
write.csv(table(tnrs.tpl$Name_matched_rank), file = "tab_name.rank_tnrs.tpl.csv")
write.csv(table(tnrs.all$Name_matched_rank), file = "tab_name.rank_tnrs.all.csv")
write.csv(table(tnrs.trop$Name_matched_rank), file = "tab_name.rank_tnrs.trop.csv")

# start consolidating:
# 1. inspect in the excel table:
# sort according to: Name_matched_rank (==Family), Taxonomic_status (==Accepted, Synomyn), Family_score (>0.9)
# create "index.family"
# 13.40-14.00

# assign index to first column:
tnrs.tpl$Name_number <- 1:length(tnrs.tpl$Name_number)

tnrs.tpl <- tnrs.tpl[,-1]

index.family <- tnrs.tpl[which(tnrs.tpl$Name_matched_rank == "family" & (tnrs.tpl$Taxonomic_status == "Accepted" | tnrs.tpl$Taxonomic_status == "Synonym") & tnrs.tpl$Family_score > 0.88), 1]
length(index.family)

# 2. repeat selection for Name_matched_rank "forma" "genus" "infraspecies" ... change selection "score", e.g. lower (strong) threshold for species, higher (or no) threshold for infraspec., variety, ... (identify threshold by looking at the excel-table)
# create respective index
# 
# 14.00-15.00
index.forma <- tnrs.tpl[which(tnrs.tpl$Name_matched_rank == "forma"), 1]
length(index.forma)

###############
## continue here:
###############

index.genus <- tnrs.tpl[which(tnrs.tpl$Name_matched_rank == "genus" & tnrs.tpl$Taxonomic_status == "Accepted" & tnrs.tpl$Genus_score > 0.83), 1]
length(index.genus)

# Genus: Problem: the following stuff is cut down to genus-level
# Andropogon sp. [capillipes + glaucopsis + glomeratus]
# Antennaria angustata/glabrata
# Aragoa perez.arbelaeziana
# Capsella bursa.pastoris
# !! possible solution: removing ".", "/", "[]" (! do this after index based on all sources is created)

index.infraspec <- tnrs.tpl[which(tnrs.tpl$Name_matched_rank == "infraspecies"), 1]
length(index.infraspec)

index.species <- tnrs.tpl[which(tnrs.tpl$Name_matched_rank == "species" & (tnrs.tpl$Taxonomic_status == "Accepted" | tnrs.tpl$Taxonomic_status == "Synonym") & tnrs.tpl$Genus_score > 0.78 & tnrs.tpl$Name_score > 0.93), 1]
length(index.species1)

index.species <- tnrs.tpl[which(tnrs.tpl$Name_matched_rank == "species" & (tnrs.tpl$Taxonomic_status == "Accepted" | tnrs.tpl$Taxonomic_status == "Synonym") & tnrs.tpl$Specific_epithet_score > 0.78), 1]
length(index.species2)

index.species <- unique(c(index.species1, index.species2))
length(index.species)

index.subspec <- tnrs.tpl[which(tnrs.tpl$Name_matched_rank == "subspecies" & (tnrs.tpl$Taxonomic_status == "Accepted" | tnrs.tpl$Taxonomic_status == "Synonym")), 1]
length(index.subspec)

index.variety <- tnrs.tpl[which(tnrs.tpl$Name_matched_rank == "variety" & (tnrs.tpl$Taxonomic_status == "Accepted" | tnrs.tpl$Taxonomic_status == "Synonym")), 1]
length(index.variety)

# additional step: identifying "non-matched" species that are spermatophyta
index.spermatophyt <- tnrs.tpl[which(tnrs.tpl$Name_matched == "No suitable matches found." & word(tnrs.tpl$Name_submitted, 1) == "Spermatophyta"), 1]
length(index.spermatophyt)

# !! later on: resolve 


# 3. identify those species that do not fulfill the search criteria
# 15.00-15.15
index.tpl <- c(index.family, index.forma, index.genus, index.species, index.subspec, index.variety, index.spermatophyt)
length((index.tpl))

tnrs.tpl.certain <- tnrs.tpl[index.tpl,]
dim(tnrs.tpl.certain)
save(tnrs.tpl.certain, file = "tnrs.tpl.certain.Rdata")
write.csv(tnrs.tpl.certain, file = "tnrs.tpl.certain.csv")

tnrs.tpl.uncertain <- tnrs.tpl[tnrs.tpl$Name_number %in% index.tpl == F, ]
dim(tnrs.tpl.uncertain)
save(tnrs.tpl.uncertain, file = "tnrs.tpl.uncertain.Rdata")
write.csv(tnrs.tpl.uncertain, file = "tnrs.tpl.uncertain.csv")

write.csv(tnrs.tpl.uncertain[,2], file = "tnrs.tpl.uncertain.upload.csv")

### continue here: Thursday 20th Oct

tnrs.trop <- read.csv("/home/oliver/Downloads/tnrs.trop.txt", sep = "\t")
str(tnrs.trop)

#######

# 4. take table from 3. repeat steps 1.-3. for "tnrs.all" "and tnrs.trop"
# 15.15-17.00
# tpl.all:
str(tnrs.trop)
tnrs.trop$Name_number <- 1:length(tnrs.trop$Name_number)
# reduce to the uncertain species from tnrs.tpl
tnrs.trop.small <- tnrs.trop[tnrs.trop$Name_number %in% index.tpl == F, ]
str(tnrs.trop.small)

save(tnrs.trop.small, file = "tnrs.trop.small.Rdata")
write.csv(tnrs.trop.small, file = "tnrs.trop.small.csv")

index.family <- tnrs.trop.small[which(tnrs.trop.small$Name_matched_rank == "family" & (tnrs.trop.small$Taxonomic_status == "Accepted"| tnrs.trop.small$Taxonomic_status == "No opinion")), 1]
length(index.family)

index.forma <- tnrs.trop.small[which(tnrs.trop.small$Name_matched_rank == "forma" & (tnrs.trop.small$Taxonomic_status == "Accepted" | tnrs.trop.small$Taxonomic_status == "Synonym")), 1]
length(index.forma)
##

index.genus <- tnrs.trop.small[which(tnrs.trop.small$Name_matched_rank == "genus" & (tnrs.trop.small$Taxonomic_status == "Accepted" | tnrs.trop.small$Taxonomic_status == "Synonym" | tnrs.trop.small$Taxonomic_status == "No opinion") & tnrs.trop.small$Genus_score > 0.83), 1]
length(index.genus)

# continue here:
index.species <- tnrs.trop.small[which(tnrs.trop.small$Name_matched_rank == "species" & (tnrs.trop.small$Taxonomic_status == "Accepted" | tnrs.trop.small$Taxonomic_status == "Synonym" | tnrs.trop.small$Taxonomic_status == "No opinion") & tnrs.trop.small$Specific_epithet_score > 0.77), 1]
length(index.species)

index.species2 <- tnrs.trop.small[which(tnrs.trop.small$Name_matched_rank == "species" & (tnrs.trop.small$Taxonomic_status == "Accepted" | tnrs.trop.small$Taxonomic_status == "Synonym") & tnrs.trop.small$Genus_score > 0.88 & tnrs.trop.small$Name_score > 0.49), 1]
length(index.species2)

index.species <- unique(c(index.species1, index.species2))
length(index.species)

index.subspec <- tnrs.trop.small[which(tnrs.trop.small$Name_matched_rank == "subspecies"), 1]
length(index.subspec)

index.subvariety <- tnrs.trop.small[which(tnrs.trop.small$Name_matched_rank == "subvariety"), 1]
length(index.subvariety)

index.variety <- tnrs.trop.small[which(tnrs.trop.small$Name_matched_rank == "variety" & tnrs.trop.small$Taxonomic_status == "No opinion"), 1]
length(index.variety)

##
index.all <- c(index.family, index.genus, index.species, index.subspec, index.variety, index.subvariety)
length((index.all))

##
tnrs.trop.small.certain <- tnrs.trop.small[tnrs.trop.small$Name_number %in% index.all == T,]
dim(tnrs.trop.small.certain)
save(tnrs.trop.small.certain, file = "tnrs.trop.small.certain.Rdata")
write.csv(tnrs.trop.small.certain, file = "tnrs.trop.small.certain.csv")

tnrs.trop.small.uncertain <- tnrs.trop.small[tnrs.trop.small$Name_number %in% index.all == F, ]
dim(tnrs.trop.small.uncertain)
save(tnrs.trop.small.uncertain, file = "tnrs.trop.small.uncertain.Rdata")
write.csv(tnrs.trop.small.uncertain, file = "tnrs.trop.small.uncertain.csv")

#### just for Oct. 2016 backbone update:

backbone.tpl.trop.certain <- rbind(tnrs.tpl.certain, tnrs.trop.small.certain)
str(backbone.tpl.trop.certain)

# kick out some columns that should not be in teh final backbone:
backbone.tpl.trop.certain.2 <- backbone.tpl.trop.certain[ ,c(1:6,12:17,25:35)]
colnames(backbone.tpl.trop.certain.2)
# add extra columns to match the old backbone:

backbone.tpl.trop.certain.2$Manual.matching <- NA
backbone.tpl.trop.certain.2$Status.correct <- NA
backbone.tpl.trop.certain.2$name.correct <- NA
backbone.tpl.trop.certain.2$rank.correct <- NA
backbone.tpl.trop.certain.2$family.correct <- NA
backbone.tpl.trop.certain.2$name.short.correct <- NA
backbone.tpl.trop.certain.2$rank.short.correct <- NA

backbone.tpl.trop.certain.2$names.sPlot.TRY <- NA
backbone.tpl.trop.certain.2$names.corr.string <- NA
backbone.tpl.trop.certain.2$sPlot.TRY <- NA

# bring names in the same order as in the old backbone:
backbone.tpl.trop.certain.3 <- backbone.tpl.trop.certain.2[,c(1,31:33,2:30)]
match(colnames(backbone.tpl.trop.certain.3), colnames(backbone.splot.try3))
identical(colnames(backbone.tpl.trop.certain.3), colnames(backbone.splot.try3)) # TRUE


# fill in emptly columns:
# Status.correct
backbone.tpl.trop.certain.3$Status.correct <- backbone.tpl.trop.certain.3$Taxonomic_status
index <- which(backbone.tpl.trop.certain.3$Name_matched == "No suitable matches found.")
backbone.tpl.trop.certain.3$Status.correct[index] <- "No suitable matches found."
# rename no.oppinion into unresolved
index <- which(backbone.tpl.trop.certain.3$Status.correct == "No opinion")
backbone.tpl.trop.certain.3$Status.correct[index] <- "Unresolved"

# name.correct (use "Accepted name", if unresolved take "Name_matched")
backbone.tpl.trop.certain.3$name.correct <- backbone.tpl.trop.certain.3$Accepted_name
index <- which(backbone.tpl.trop.certain.3$Taxonomic_status != "Accepted" | backbone.tpl.trop.certain.3$Taxonomic_status != "Synonym")
backbone.tpl.trop.certain.3$name.correct[index] <- backbone.tpl.trop.certain.3$Name_matched[index]
index <- which(backbone.tpl.trop.certain.3$Name_matched == "No suitable matches found.")
backbone.tpl.trop.certain.3$name.correct[index] <- "No suitable matches found."

# rank.correct
backbone.tpl.trop.certain.3$rank.correct <- backbone.tpl.trop.certain.3$Accepted_name_rank
index <- which(backbone.tpl.trop.certain.3$Taxonomic_status != "Accepted" | backbone.tpl.trop.certain.3$Taxonomic_status != "Synonym")
backbone.tpl.trop.certain.3$rank.correct[index] <- backbone.tpl.trop.certain.3$Name_matched_rank[index]
index <- which(backbone.tpl.trop.certain.3$Name_matched == "No suitable matches found.")
backbone.tpl.trop.certain.3$rank.correct[index] <- NA

# family.correct
backbone.tpl.trop.certain.3$family.correct <- backbone.tpl.trop.certain.3$Accepted_name_family
index <- which(backbone.tpl.trop.certain.3$Taxonomic_status != "Accepted" | backbone.tpl.trop.certain.3$Taxonomic_status != "Synonym")
backbone.tpl.trop.certain.3$family.correct[index] <- backbone.tpl.trop.certain.3$Name_matched_accepted_family[index]
index <- which(backbone.tpl.trop.certain.3$Name_matched == "No suitable matches found.")
backbone.tpl.trop.certain.3$family.correct[index] <- NA

# name.short.correct
backbone.tpl.trop.certain.3$name.short.correct <- backbone.tpl.trop.certain.3$name.correct

index <- which(backbone.tpl.trop.certain.3$rank.correct == "subspecies" | backbone.tpl.trop.certain.3$rank.correct == "variety" | backbone.tpl.trop.certain.3$rank.correct == "forma"| backbone.tpl.trop.certain.3$rank.correct == "subvariety" | backbone.tpl.trop.certain.3$Name_matched_rank == "subspecies" | backbone.tpl.trop.certain.3$Name_matched_rank == "variety")

library(stringr)
backbone.tpl.trop.certain.3$name.short.correct[index] <- word(string = backbone.tpl.trop.certain.3$name.short.correct[index], start = 1, end = 2)

# rank.short.correct
backbone.tpl.trop.certain.3$rank.short.correct <- backbone.tpl.trop.certain.3$rank.correct

index <- which(backbone.tpl.trop.certain.3$rank.correct == "subspecies" | backbone.tpl.trop.certain.3$rank.correct == "variety" | backbone.tpl.trop.certain.3$rank.correct == "forma"| backbone.tpl.trop.certain.3$rank.correct == "subvariety")

backbone.tpl.trop.certain.3$rank.short.correct[index] <- "species"

#########
# fill in the columns in trop.small.uncertain
####
tnrs.trop.small.uncertain

# kick out some columns that should not be in teh final backbone:
tnrs.trop.small.uncertain.2 <- tnrs.trop.small.uncertain[ ,c(1:6,12:17,25:35)]
colnames(tnrs.trop.small.uncertain.2)
# add extra columns to match the old backbone:

tnrs.trop.small.uncertain.2$Manual.matching <- NA
tnrs.trop.small.uncertain.2$Status.correct <- NA
tnrs.trop.small.uncertain.2$name.correct <- NA
tnrs.trop.small.uncertain.2$rank.correct <- NA
tnrs.trop.small.uncertain.2$family.correct <- NA
tnrs.trop.small.uncertain.2$name.short.correct <- NA
tnrs.trop.small.uncertain.2$rank.short.correct <- NA

tnrs.trop.small.uncertain.2$names.sPlot.TRY <- NA
tnrs.trop.small.uncertain.2$names.corr.string <- NA
tnrs.trop.small.uncertain.2$sPlot.TRY <- NA

# bring names in the same order as in the old backbone:
tnrs.trop.small.uncertain.3 <- tnrs.trop.small.uncertain.2[,c(1,31:33,2:30)]
match(colnames(tnrs.trop.small.uncertain.3), colnames(backbone.splot.try3))
identical(colnames(tnrs.trop.small.uncertain.3), colnames(backbone.splot.try3)) # TRUE

tnrs.trop.small.uncertain.3[,c(28:29)] <- "No suitable matches found."

# merge with backbone for certain species:
backbone.tpl.trop <- rbind(backbone.tpl.trop.certain.3, tnrs.trop.small.uncertain.3)
head(backbone.tpl.trop)
dim(backbone.tpl.trop)

write.csv(backbone.tpl.trop, file = "backbone.tpl.trop.csv")

backbone.tpl.trop <- read.csv("backbone.tpl.trop.csv")

## fill in remaining first three columns
backbone.tpl.trop$sPlot.TRY <- "S"
backbone.tpl.trop$Manual.matching <- "sPlot2b"

library(plyr)
miss.clean.2 <- cbind(1:length(miss.clean[,1]), as.data.frame(miss.clean))
colnames(miss.clean.2)[1] <- "Name_number"

backbone.tpl.trop <- left_join(miss.clean.2, backbone.tpl.trop, by = "Name_number")
head(backbone.tpl.trop)

colnames(backbone.tpl.trop)

backbone.tpl.trop.2 <- backbone.tpl.trop[,-c(4:6)]

colnames(backbone.tpl.trop.2)[2:3] <- c("names.sPlot.TRY", "names.corr.string")
match(colnames(backbone.tpl.trop.2), colnames(backbone.splot.try3))
identical(colnames(backbone.tpl.trop.2), colnames(backbone.splot.try3))

write.csv(backbone.tpl.trop.2, file = "backbone.tpl.trop.2.csv")
save(backbone.tpl.trop.2, file = "backbone.tpl.trop.2.Rdata")

# merge with the big old backbone:
backbone.splot2b.try3 <- rbind(backbone.splot.try3, backbone.tpl.trop.2)
dim(backbone.splot2b.try3)

## see whether the new backbone matches the sPlot2b species data
str(splot.species)

length(unique(splot.species$Matched_concept))

which(unique(splot.species$Matched_concept) %in% backbone.splot2b.try3$names.sPlot.TRY == F)


backbone.splot2.1.try3 <- backbone.splot2b.try3
write.csv(backbone.splot2.1.try3, file = "backbone.splot2.1.try3.csv")
save(backbone.splot2.1.try3, file = "backbone.splot2.1.try3.Rdata")


#############

##############
# tnrs.trop:
str(tnrs.trop)
tnrs.trop$Name_number <- 1:length(tnrs.trop$Name_number)
# reduce to the uncertain species from tnrs.tpl
tnrs.trop.small <- tnrs.trop[tnrs.all.small.uncertain$Name_number, ]
str(tnrs.trop.small)

save(tnrs.trop.small, file = "tnrs.trop.small.Rdata")
write.csv(tnrs.trop.small, file = "tnrs.trop.small.csv")

###
index.family <- tnrs.trop.small[which(tnrs.trop.small$Name_matched_rank == "family" & (tnrs.trop.small$Taxonomic_status == "Accepted"| tnrs.trop.small$Taxonomic_status == "Synonym")), 1]
length(index.family)

index.forma <- tnrs.trop.small[which(tnrs.trop.small$Name_matched_rank == "forma" & (tnrs.trop.small$Taxonomic_status == "Accepted" | tnrs.trop.small$Taxonomic_status == "Synonym")), 1]
length(index.forma)

index.genus <- tnrs.trop.small[which(tnrs.trop.small$Name_matched_rank == "genus" & (tnrs.trop.small$Taxonomic_status == "Accepted" | tnrs.trop.small$Taxonomic_status == "Synonym") & tnrs.trop.small$Genus_score > 0.83 & tnrs.trop.small$Name_score > 0.5), 1]
length(index.genus)

# continue here:
index.species1 <- tnrs.trop.small[which(tnrs.trop.small$Name_matched_rank == "species" & (tnrs.trop.small$Taxonomic_status == "Accepted" | tnrs.trop.small$Taxonomic_status == "Synonym") & tnrs.trop.small$Genus_score > 0.88 & tnrs.trop.small$Name_score > 0.9), 1]
length(index.species1)

index.species2 <- tnrs.trop.small[which(tnrs.trop.small$Name_matched_rank == "species" & (tnrs.trop.small$Taxonomic_status == "Accepted" | tnrs.trop.small$Taxonomic_status == "Synonym") & tnrs.trop.small$Genus_score > 0.78 & tnrs.trop.small$Name_score > 0.94), 1]
length(index.species1)

index.species3 <- tnrs.trop.small[which(tnrs.trop.small$Name_matched_rank == "species" & (tnrs.trop.small$Taxonomic_status == "Accepted" | tnrs.trop.small$Taxonomic_status == "Synonym") & tnrs.trop.small$Genus_score > 0.88 & tnrs.trop.small$Name_score > 0.49), 1]
length(index.species3)

index.species <- unique(c(index.species1, index.species2, index.species3))
length(index.species)


index.subspec <- tnrs.trop.small[which(tnrs.trop.small$Name_matched_rank == "subspecies" & (tnrs.trop.small$Taxonomic_status == "Accepted" | tnrs.trop.small$Taxonomic_status == "Synonym")), 1]
length(index.subspec)

index.variety <- tnrs.trop.small[which(tnrs.trop.small$Name_matched_rank == "variety" & (tnrs.trop.small$Taxonomic_status == "Accepted" | tnrs.trop.small$Taxonomic_status == "Synonym")), 1]
length(index.variety)

index.trop <- c(index.family, index.forma, index.genus, index.species, index.subspec, index.variety)
length((index.trop))

##
tnrs.trop.small.certain <- tnrs.trop.small[tnrs.trop.small$Name_number %in% index.trop == T,]
dim(tnrs.trop.small.certain)
save(tnrs.trop.small.certain, file = "tnrs.trop.small.certain.Rdata")
write.csv(tnrs.trop.small.certain, file = "tnrs.trop.small.certain.csv")

tnrs.trop.small.uncertain <- tnrs.trop.small[tnrs.trop.small$Name_number %in% index.trop == F, ]
dim(tnrs.trop.small.uncertain)
save(tnrs.trop.small.uncertain, file = "tnrs.trop.small.uncertain.Rdata")
write.csv(tnrs.trop.small.uncertain, file = "tnrs.trop.small.uncertain.csv")

### run against NCBI
write.csv(tnrs.trop.small.uncertain$Name_submitted[1:5000], file = "trop.uncert.1.csv")
write.csv(tnrs.trop.small.uncertain$Name_submitted[5001:9641], file = "trop.uncert.5001.csv")


# 5. identify unresolved species (excluding "Spermatophyta...") from 1.-4. (which were not indexed according to my procedure above) and run against TPL again (using six sources BUT take NCBI first)

# 
tnrs.ncbi.1 <- read.csv("/home/oliver/Downloads/tnrs.trop.uncert.1.csv", stringsAsFactors = FALSE)[-1,]
tnrs.ncbi.2 <- read.csv("/home/oliver/Downloads/tnrs.trop.uncert.5001.csv", stringsAsFactors = FALSE)[-1,]

tnrs.ncbi <- rbind(tnrs.ncbi.1, tnrs.ncbi.2)
str(tnrs.ncbi)
range(tnrs.trop.small.uncertain$Name_number)
# give index:
tnrs.ncbi$Name_number <- tnrs.trop.small.uncertain$Name_number
range(tnrs.ncbi$Name_number)

save(tnrs.ncbi, file = "tnrs.ncbi.Rdata")
write.csv(tnrs.ncbi, file = "tnrs.ncbi.csv")

# for tnrs.ncbi, identify certain and uncertain species:
index.family <- tnrs.ncbi[which(tnrs.ncbi$Name_matched_rank == "family" & (tnrs.ncbi$Taxonomic_status == "Accepted"| tnrs.ncbi$Taxonomic_status == "Synonym") & tnrs.ncbi$Family_score > 0.85), 1]
length(index.family)

index.genus.1 <- tnrs.ncbi[which(tnrs.ncbi$Name_matched_rank == "genus" & (tnrs.ncbi$Taxonomic_status == "Accepted" | tnrs.ncbi$Taxonomic_status == "Synonym") & tnrs.ncbi$Genus_score > 0.89 & tnrs.ncbi$Name_score > 0.49), 1]
length(index.genus.1)

index.genus.2 <- tnrs.ncbi[which(tnrs.ncbi$Name_matched_rank == "genus" & (tnrs.ncbi$Taxonomic_status == "Accepted" | tnrs.ncbi$Taxonomic_status == "Synonym") & tnrs.ncbi$Genus_score > 0.99 & tnrs.ncbi$Name_score > 0.2), 1]
length(index.genus.2)

index.genus.3 <- tnrs.ncbi[which(tnrs.ncbi$Name_matched_rank == "genus" & tnrs.ncbi$Taxonomic_status == "No opinion" & tnrs.ncbi$Genus_score > 0.88 & tnrs.ncbi$Name_score > 0.49), 1]
length(index.genus.3)

index.genus <- unique(c(index.genus.1, index.genus.2, index.genus.3))
length(index.genus)

###
index.species.1 <- tnrs.ncbi[which(tnrs.ncbi$Name_matched_rank == "species" & (tnrs.ncbi$Taxonomic_status == "Accepted" | tnrs.ncbi$Taxonomic_status == "Synonym") & tnrs.ncbi$Name_score > 0.94), 1]
length(index.species.1)

index.species.2 <- tnrs.ncbi[which(tnrs.ncbi$Name_matched_rank == "species" & (tnrs.ncbi$Taxonomic_status == "Accepted" | tnrs.ncbi$Taxonomic_status == "Synonym") & tnrs.ncbi$Genus_score > 0.81 & tnrs.ncbi$Name_score > 0.51), 1]
length(index.species.2)

index.species.3 <- tnrs.ncbi[which(tnrs.ncbi$Name_matched_rank == "species" & tnrs.ncbi$Taxonomic_status == "No opinion"  & tnrs.ncbi$Genus_score > 0.7 & tnrs.ncbi$Specific_epithet_score > 0.75), 1]
length(index.species.3)

index.species <- unique(c(index.species.1, index.species.2, index.species.3))
length(index.species)

index.var <- tnrs.ncbi[which((tnrs.ncbi$Name_matched_rank == "subspecies" | tnrs.ncbi$Name_matched_rank == "unknown" | tnrs.ncbi$Name_matched_rank == "variety") & (tnrs.ncbi$Taxonomic_status == "Accepted" | tnrs.ncbi$Taxonomic_status == "No opinion" | tnrs.ncbi$Taxonomic_status == "Synonym")), 1]
length(index.var)

index.ncbi <- c(index.family, index.genus, index.species, index.var)
length((index.ncbi))

# identify certain and uncertain species:
tnrs.ncbi.certain <- tnrs.ncbi[tnrs.ncbi$Name_number %in% index.ncbi == T,]
dim(tnrs.ncbi.certain)
save(tnrs.ncbi.certain, file = "tnrs.ncbi.certain.Rdata")
write.csv(tnrs.ncbi.certain, file = "tnrs.ncbi.certain.csv")

tnrs.ncbi.uncertain <- tnrs.ncbi[tnrs.ncbi$Name_number %in% index.ncbi == F, ]
dim(tnrs.ncbi.uncertain)
save(tnrs.ncbi.uncertain, file = "tnrs.ncbi.uncertain.Rdata")
write.csv(tnrs.ncbi.uncertain, file = "tnrs.ncbi.uncertain.csv")

# in "ncbi uncertain":
# ... that are 

# identify species in "ncbi certain":
# ... that are potentially proper species that are pruned down to genus level and run them against TPL

# continue here: send corrected list to Jürgen:
# continue checking "uncertain" that were not sent to Jürgen

# for Jürgens list 

TPL("Nothofagus cliffortioides ", corr=T, diffchar = 9, max.distance = 9)

# select "Accepted_name" for "no opinion", "invalid", "illegitimate" -> run against TPL (using TNRS) (+ the five other sources)

# run again taxonstand::TPL
tpl.upload <- read.csv("TPLupload.csv", stringsAsFactors = F, head = F)
str(tpl.upload)

tpl.test <- TPL(tpl.upload[,1], corr = F)
write.csv(tpl.test, file = "tpl.test.csv")


# 6. identify non-matched and uncertain species list based on scores

# 7. run through list in 6 and correct some obvious misspellings (e.g. ABIESNORD., ..xboris.. etc. spec1 ...) + resolve some names according to 2.

# 8. run list from 7. against TPL (all sources)

# 9. select "No opinion" (e.g. for "subspecies" and "infraspec." levels and run against just "mtached genus" and "matched epithet" against the TPL and later tropicos etc...)

# do some final filtering to resolve stuff like:
# Polygala lila 132782	0.76	Polygala limae

# 10. at the very end, run everything that was matched against sources other than TPL, GCC or ILDIS against these three sources, to resolve some of the remaining synonyms

###################################################################
###################################################################
## May 2017: updated stats on taxonomic backbone for sPlot paper: #
###################################################################
###################################################################

# to get the updated stats, I need to reconstruct every single step:

# 13:45-14:15 - get new stats
load("backbone.splot2.1.try3.is.vascular.Rdata")

str(backbone.splot2.1.try3)
dim(backbone.splot2.1.try3)
summary(backbone.splot2.1.try3)
colnames(backbone.splot2.1.try3)
table(backbone.splot2.1.try3$is.vascular.species)

# how many unique names
length(unique(backbone.splot2.1.try3$names.sPlot.TRY))
# 130602 unique (uncleaned) names in splot and try together
length(unique(backbone.splot2.1.try3$Name_submitted))
# 120895 unique names were submitted after first cleaning

table(backbone.splot2.1.try3$is.vascular.species)
# 94.63% (123589) of all names in sPlot2.1 are vascular plants, 5.37% (7013) are non-vasular

# species in splot vs. try
table(backbone.splot2.1.try3$sPlot.TRY)
#    S    ST     T 
# 70329 24796 35477 

table(backbone.splot2.1.try3$Manual.matching)

# sPlot2b       x 
   7701    1675 

# how many accepted names, synonyms, .. 
table(backbone.splot2.1.try3$Status.correct)
                  Accepted No suitable matches found. 
                    102183                       2113 
                   Synonym                 Unresolved 
                     21383                       4923 

### damn! for getting the exact stats, I need to exactly reconstruct the workflow which 

# at the end, we identified non-angiosperm species, based on information in the column ? in splot species, which was available for most of european data bases and classifcation function in taxize 
# ! check my script

index <- which(backbone.splot2.1.try3)

###################################################################
###################################################################
# taxonomic standardization procedure, step by step:
######################################################################################
################################################

# 1) combine unique names lists of species in sPlot 2.0 and TRY 3.0:
# 1.1) read in sPlot

# 22nd May: load splot backbone, load splot 19_07_2017

splot_july_species <- read.csv("/home/oliver/Dokumente/PhD/PostPhD/IDiv/sDiv/sPlot/Analyses/Data/Species/sPlot/sPlot_2015_07_29/sPlot_2015_07_29_species.csv", sep = "")




library(data.table)
path.sPlot <- "/home/oliver/Dokumente/PhD/PostPhD/IDiv/sDiv/sPlot/Analyses/Data/Species/sPlot/sPlot_14_04_2015/"
# ! NOTE, this is the version of splot to generate the backbone for to match splot 2.0 to try 3.0. In the following, I will describe the workflow for generating a backbone for this two versions of the the data bases. 
# the backbone use used in the workshop sPlot.III also contains the 7,701 additional (and/or different) species names in sPlot 2.1 (sPlot_2015_07_19). Because prior to the workshop, I had to do some ad-hoc
# since I no longer have "sPlot_14_4_2015_species"

# !!! for repeating the taxonomic standardization procedure for the additional species in future version in 

# for final R code published, generate Rmarkdown document (html and pdf for the appendix) and push on github

# strategy for the workflow: 
# 1) explain everything based and sPlot_14_4_2015_species and the TRY 3.0 species list (for the workflow text)
# 2) report statistics based sPlot_2015_07_19

#
splot.species <- read.csv(paste(path.sPlot, "sPlot_14_4_2015_species.csv", sep = ""), sep = "\t") # note, "sPlot_14_4_2015_species" no longer exists, but will be used for documentation purposes here
gc()

length(unique(splot.species$Matched.concept))

# use Matched.concept concept column
splot.species$Matched.concept<- as.character(splot.species$Matched.concept)
# ?! ask Florian about the turboveg-bit
# explain matched concept column a bit

# 1.2) read in TRY 3.0 species list
try3.species <- read.csv("/home/oliver/Dokumente/PhD/PostPhD/IDiv/sDiv/sPlot/Analyses/Data/Species/TRY/Species/TRY30_Gapfilling2015_Species.csv")
str(try3.species)
try3.species$Species <- as.character(try3.species$Species)

# 1.3) combine species lists into one unified species list:
spec.list.TRY.sPlot <- sort(unique(c(as.character(splot.species$Matched.concept), as.character(try3.species$Species))))
length(spec.list.TRY.sPlot)

# create dataframe that will later hold the original (uncleaned) names in sPlot and TRY 
spec.list.TRY.sPlot.2 <- cbind(spec.list.TRY.sPlot, spec.list.TRY.sPlot, spec.list.TRY.sPlot)

str(spec.list.TRY.sPlot.2)
dim(spec.list.TRY.sPlot.2)
spec.list.TRY.sPlot.2 <- as.data.frame(spec.list.TRY.sPlot.2)

# convert into characters
spec.list.TRY.sPlot.2[,1] <- as.character(spec.list.TRY.sPlot.2[,1])
spec.list.TRY.sPlot.2[,2] <- as.character(spec.list.TRY.sPlot.2[,2])
spec.list.TRY.sPlot.2[,3] <- as.character(spec.list.TRY.sPlot.2[,3])

# give column names
colnames(spec.list.TRY.sPlot.2) <- c("names.sPlot.TRY", "names.corr.string", "sPlot.TRY")
write.csv(spec.list.TRY.sPlot.2, file = "spec.list.TRY3.sPlot2.csv")

# spec.list.TRY3.sPlot2spec.list.TRY3.sPlot2 <- read.csv("spec.list.TRY3.sPlot2.csv")
# dim(spec.list.TRY3.sPlot2)

# note that this species list only contains 122901 species. the final backbone contains 7701 additional (and/or different) species from from the ad-hoc version sPlot_2015_07_19


# 2) add information on whether names come from sPlot (1), TRY (0) or both (2)

# which species are in sPlot 2.0
spec.list.TRY.sPlot.2$sPlot.TRY[which(spec.list.TRY.sPlot.2$names.sPlot.TRY %in% unique(splot.species$Matched.concept))] <- "S"

# which species are in TRY 3.0
spec.list.TRY.sPlot.2$sPlot.TRY[which(spec.list.TRY.sPlot.2$names.sPlot.TRY %in% unique(try3.species$Species))] <- "T"

# which species are in sPlot 2.0 and TRY 3.0

spec.list.TRY.sPlot.2$sPlot.TRY[which(spec.list.TRY.sPlot.2$names.sPlot.TRY %in% unique(try3.species$Species) & spec.list.TRY.sPlot.2$names.sPlot.TRY %in% unique(splot.species$Matched.concept))] <- "ST"

# ok, now we have assigned to each name whether it is found in splot and/or TRY

table(spec.list.TRY3.sPlot2$sPlot.TRY)

# again, recalculate that for splot 2.1 (exluding those species that are in splot2.0 but not in splot2.1)



# 3) weird names or manual names parsing
# based one the "matched concept" in splot, I manually generated list of 4093 "weird" species names (mainly trivial species names)
# (note, this was done in a very rough and preliminary way, so dont overemphasize that bit)
# basically, Jürgen went through manually, mainly correcting trivial names, ..
# e.g. (bring 5-10 expamples here for cases that could only be cleaned in that way):
# Gras silbrig Bl haarig 133106 -> Poaceae sp. [silbrig Bl haarig 133106]
# Ãƒâ€”Achnella species -> Achnella sp.
# [KHH Composite (breite Bl.)] -> Asteraceae sp. [breite Bl.]
# LICH Xanthomaculina hottentotta -> Xanthomaculina hottentotta
# cf. Silberknospe 134249 -> Spermatophyta sp. [Silberknospe 134249]
# 

# 4) use some string manipulation routines to do some a-priori cleaning prior to submission to TNRS

OriginalNames <- as.character(spec.list.TRY3.sPlot2$names.sPlot.TRY) # ! to be changed

# 4.1)
# some of the following code comes from Florian Jansen
### Name cleaning (spelling of ranks, name additions etc.)
OriginalNames <- gsub('*', '', OriginalNames, fixed=TRUE)
OriginalNames <- gsub('cf. ', '', OriginalNames, fixed=TRUE)
OriginalNames <- gsub('Cf. ', '', OriginalNames, fixed=TRUE)
OriginalNames <- gsub('[', '', OriginalNames, fixed=TRUE)
OriginalNames <- gsub(']', '', OriginalNames, fixed=TRUE)
OriginalNames <- gsub(' x ', ' ', OriginalNames, fixed=TRUE)
OriginalNames <- gsub('Ã—', '', OriginalNames, fixed=TRUE)
OriginalNames <- gsub('aff ', '', OriginalNames, fixed=TRUE)
OriginalNames <- gsub('(', '', OriginalNames, fixed=TRUE)
OriginalNames <- gsub(')', '', OriginalNames, fixed=TRUE)
OriginalNames <- gsub(' cf ', ' ', OriginalNames, fixed=TRUE)
OriginalNames <- gsub(' aff. ', ' ', OriginalNames, fixed=TRUE)
OriginalNames <- gsub('c‚e', 'ceae', OriginalNames, fixed=TRUE)
OriginalNames <- gsub('    ', ' ', OriginalNames, fixed=TRUE)
OriginalNames <- gsub('   ', ' ', OriginalNames, fixed=TRUE)
OriginalNames <- gsub('  ', ' ', OriginalNames, fixed=TRUE)
OriginalNames <- gsub('x-', '', OriginalNames, fixed=TRUE)
OriginalNames <- gsub('X-', '', OriginalNames, fixed=TRUE)
OriginalNames <- gsub('like ', '', OriginalNames, fixed=TRUE)  
OriginalNames <- gsub(',', '', OriginalNames, fixed=TRUE)  

# ? what is the following doing?:
# 4.2)
# for all names that have a number in their first word, and consist of > 1 words, remove that word
# ! check whether I have actually done that! yes, we did
library(stringr)
firstWordWithNumbers <- grepl('[0-9]', word(OriginalNames, 1))
numberOfWords <- sapply(gregexpr("\\W+", OriginalNames), length) + 1
OriginalNames[firstWordWithNumbers & numberOfWords > 1] <- sapply(OriginalNames[firstWordWithNumbers & numberOfWords > 1], function(x) substr(x, start=regexpr(pattern =' ', text=x)+1, stop=nchar(x)))

# 4.3)
# correct some species names abbreviations using vegdata::taxname.abbr
CleanedNames <- taxname.abbr(OriginalNames)
# give some examples

save(CleanedNames, file = "CleanedNames.Rdata")
write.csv(CleanedNames, file = "CleanedNames.csv")

# load("CleanedNames.Rdata")
length(CleanedNames)

#  create a data frame from the string cleaned names:
CleanedNames.df <- as.data.frame(CleanedNames, stringsAsFactors=FALSE)

spec.list.TRY.sPlot.3 <- cbind(spec.list.TRY.sPlot.2[,c(1,2,4)], CleanedNames.df, CleanedNames.df) # skip column "names.corr.string", as the cleanednames.df column as well as another column that will include Jürgens corrected names

dim(spec.list.TRY.sPlot.3)
# 122901
head(spec.list.TRY.sPlot.3)
colnames(spec.list.TRY.sPlot.3) <- c("index","original.names.sPlot.TRY","sPlot.TRY","CleanedNames","CleanedNames.Juergen")

Tax_Back_sPlot2_TRY3 <- spec.list.TRY.sPlot.3

save(Tax_Back_sPlot2_TRY3, file = "Tax_Back_sPlot2_TRY3.Rdata")
load("Tax_Back_sPlot2_TRY3.Rdata")
write.csv(Tax_Back_sPlot2_TRY3, file = "Tax_Back_sPlot2_TRY3.csv")

str(Tax_Back_sPlot2_TRY3)

# 5) substitute some cleaned names with Jürgens corrected names 
weird.JD <- read.csv("weird.names_JD_string_correct.csv")
str(weird.JD)
head(weird.JD)

sum(weird.JD$weird.names %in% Tax_Back_sPlot2_TRY3$original.names.sPlot.TRY)
# all 4093 names present in TB

index <- match(weird.JD$weird.names, Tax_Back_sPlot2_TRY3$original.names.sPlot.TRY)
Tax_Back_sPlot2_TRY3$CleanedNames.Juergen[index] <- weird.JD$Name.corrected

# 5.1) do some more cleaning on "CleanedNames.Juergen"
CleanedNames.Juergen <- Tax_Back_sPlot2_TRY3$CleanedNames.Juergen

write.csv(CleanedNames.Juergen, file = "CleanedNames.Juergen.csv")

# substitute old CleanedNames.Juergen with new string-manipulated one:
Tax_Back_sPlot2_TRY3$CleanedNames.Juergen <- CleanedNames.Juergen

save(Tax_Back_sPlot2_TRY3, file = "Tax_Back_sPlot2_TRY3.Rdata")

# 6) run cleaned names against TRNS (use six cores max), save chunks as csv-files to see where there are misspelled names


# slice CleanedNames into chunks for TNRS:

# for 5000 species
seq1 <- seq(from =1, to = 120001, 5000)
seq2 <- seq(from =5000, to = 125000, 5000)

# ! actually, we sliced it into chunks of 5000 names

# cbind(seq1, seq2)
library(foreach)

for(i in 1:length(seq1)) {
    write.csv(Tax_Back_sPlot2_TRY3$CleanedNames.Juergen[seq1[i]:seq2[i]], file = paste(paste("tnrs_submit", seq1[i], sep = "_"), "csv", sep = "."))
}

# 7) go to http://tnrs.iplantcollaborative.org/sources.html and submit the single species
# I used TNRS v.4, which became available in Aug 2015 (this version also included the plant list v.1.1)

# citation:
#To cite the Taxonomic Name Resolution Service please refer to the following publication:
#
#    Boyle, B. et al. 2013. The taxonomic name resolution service: an online tool for automated standardization of plant names. BMC Bioinformatics 14:16. doi:10.1186/1471-2105-14-16

#If the results derived from the TNRS are used in a publication, please cite:

#    The Taxonomic Name Resolution Service [Internet]. iPlant Collaborative. Version < VERSION NUMBER > [Accessed: ]. Available from: http://tnrs.iplantcollaborative.org.

#For example:

#    The Taxonomic Name Resolution Service [Internet]. iPlant Collaborative. Version 4.0 [Accessed: 20 Sep 2015]. Available from: http://tnrs.iplantcollaborative.org



# Which sources? 
# All (the five suggested sources)
# TPL (+ GCC and ILDIS)
# Tropicos
# NCBI
# USDA

#Finally, we also request that you acknowledge separately all taxonomic data sources used by the TNRS to process your data. Acknowledge only the sources you selected. Taxonomic sources should be cited as shown below. Note that the "Accessed" date is the date of the latest update of that source within the TNRS database, as noted on the Sources page of this website.

#    Tropicos.org [Internet]. Missouri Botanical Garden, St. Louis, MO, USA. [Accessed 19 Dec 2014]. Available from: http://www.tropicos.org

#    USDA, NRCS. The PLANTS Database [Internet]. National Plant Data Team, Greensboro, NC, USA. [Accessed: 17 Jan 2015]. Available from: http://plants.usda.gov

#    Flann, C, editor. Global Compositae Checklist [Internet]. 2009 - [Accessed: 21 Aug 2015]. Available from: www.compositae.org/checklist

#    Federhen S. The Taxonomy Project. 9 Oct 2002 [Updated 13 Aug 2003]. In: McEntyre J., Ostell J., editors. The NCBI Handbook [Internet]. National Center for Biotechnology Information, Bethesda, MD, USA. [Accessed: 25 Oct 2011]. Available from: http://www.ncbi.nlm.nih.gov/guide/taxonomy/

#    The Plant List (2013). Version 1.1. Published on the Internet; http://www.theplantlist.org/ [Accessed: 19 Aug 2015].

#    International Legume Database and Information Service, http://www.ildis.org/ [Accessed: 21 Aug 2015].


# use standard settings:

"Processing Mode: Selected mode:   Perform Name Resolution
 
Match Accuracy:  Allow partial matches, Selected minimum threshold: 0.05
 
Sources:  [ TPL, GCC, ILDIS, TROPICOS, USDA ]
 
Family Classification:  Selected classification source: TROPICOS"



# 8) read in TNRS tables 

library(doParallel)
# Find out how many cores are available (if you don't already know)
detectCores()
# Create cluster with desired number of cores
cl <- makeCluster(3)

# Register cluster
registerDoParallel(cl)

# Find out how many cores are being used
getDoParWorkers()

# based on all sources
setwd("/home/oliver/Downloads/")
# note that we dont have this single files anymore
system.time(
    x <- foreach(i = 1:length(seq1), .combine = rbind) %dopar% {
    read.csv(paste(paste("/home/oliver/Downloads/tnrs.tpl", seq1[i], sep = "."), "csv", sep = "."), sep = ",", stringsAsFactors = FALSE, skip = 0, head = T)[-1, ]
}
    )

tnrs.tpl <- x
# note, the full original tnrs.tpl including all 123,000+ species has been overwritten, and now instead only contains the  

# 9) # start consolidating:
# 9.1) inspect in the excel table (needs to be done manually):
# sort according to: Name_matched_rank (==Family), Taxonomic_status (==Accepted, Synomyn), Family_score (>0.9)

# assign index to first column:
tnrs.tpl$Name_number <- 1:length(tnrs.tpl$Name_number)

tnrs.tpl <- tnrs.tpl[,-1]

# start with the highest hierarchical level, family. select those names, at the family level that were either accepted names or synomym and have 
# manually checking the TRNS output reveals that all accepted names or synonyms, where fuzzy (partial) matching revealed a accuracy scores >0.88 are correct taxon names
# create "index.family"
# the similar manual checking procedure was applied to genus, species, etc.
index.family <- tnrs.tpl[which(tnrs.tpl$Name_matched_rank == "family" & (tnrs.tpl$Taxonomic_status == "Accepted" | tnrs.tpl$Taxonomic_status == "Synonym") & tnrs.tpl$Family_score > 0.88), 1]
length(index.family)


# 9.2) repeat selection for Name_matched_rank "forma" "genus" "infraspecies" ... change selection "score", e.g. lower (strong) threshold for species, higher (or no) threshold for infraspec., variety, ... (identify threshold by looking at the excel-table)
# create respective index
# 

# for forma
index.forma <- tnrs.tpl[which(tnrs.tpl$Name_matched_rank == "forma"), 1]
length(index.forma)

# genus
index.genus <- tnrs.tpl[which(tnrs.tpl$Name_matched_rank == "genus" & tnrs.tpl$Taxonomic_status == "Accepted" & tnrs.tpl$Genus_score > 0.83), 1]
length(index.genus)

# ... etc.

index.infraspec <- tnrs.tpl[which(tnrs.tpl$Name_matched_rank == "infraspecies"), 1]
length(index.infraspec)

index.species <- tnrs.tpl[which(tnrs.tpl$Name_matched_rank == "species" & (tnrs.tpl$Taxonomic_status == "Accepted" | tnrs.tpl$Taxonomic_status == "Synonym") & tnrs.tpl$Genus_score > 0.78 & tnrs.tpl$Name_score > 0.93), 1]
length(index.species1)

index.species <- tnrs.tpl[which(tnrs.tpl$Name_matched_rank == "species" & (tnrs.tpl$Taxonomic_status == "Accepted" | tnrs.tpl$Taxonomic_status == "Synonym") & tnrs.tpl$Specific_epithet_score > 0.78), 1]
length(index.species2)

index.species <- unique(c(index.species1, index.species2))
length(index.species)

index.subspec <- tnrs.tpl[which(tnrs.tpl$Name_matched_rank == "subspecies" & (tnrs.tpl$Taxonomic_status == "Accepted" | tnrs.tpl$Taxonomic_status == "Synonym")), 1]
length(index.subspec)

index.variety <- tnrs.tpl[which(tnrs.tpl$Name_matched_rank == "variety" & (tnrs.tpl$Taxonomic_status == "Accepted" | tnrs.tpl$Taxonomic_status == "Synonym")), 1]
length(index.variety)

# additional step: identifying "non-matched" species that are spermatophyta
index.spermatophyt <- tnrs.tpl[which(tnrs.tpl$Name_matched == "No suitable matches found." & word(tnrs.tpl$Name_submitted, 1) == "Spermatophyta"), 1]
length(index.spermatophyt)


# 9.3. identify those species that do not fulfill the search criteria, for further resolution other using sources other than TPL
# 
index.tpl <- c(index.family, index.forma, index.genus, index.species, index.subspec, index.variety, index.spermatophyt)
length((index.tpl))

tnrs.tpl.certain <- tnrs.tpl[index.tpl,]
dim(tnrs.tpl.certain)
save(tnrs.tpl.certain, file = "tnrs.tpl.certain.Rdata")
write.csv(tnrs.tpl.certain, file = "tnrs.tpl.certain.csv")

tnrs.tpl.uncertain <- tnrs.tpl[tnrs.tpl$Name_number %in% index.tpl == F, ]
dim(tnrs.tpl.uncertain)
save(tnrs.tpl.uncertain, file = "tnrs.tpl.uncertain.Rdata")
write.csv(tnrs.tpl.uncertain, file = "tnrs.tpl.uncertain.csv")

# generate list of species to be uploaded to TNRS:
write.csv(tnrs.tpl.uncertain[,2], file = "tnrs.tpl.uncertain.upload.csv")


# !!! remember, it is the first three hours of the day (9-12am) that determine your day
# 9:30-10:00: fuzzy matching
# 10:00-10:45 unresolved species (TPL & Jürgen)
# 10:45-11:15 adding final columns
# 11:15-11:45 dealing with additional species in sPlot2.1

# 9.4 resolve species that could not be resolved in with TNRS.tpl, using the TRNS.tropicos -> repeat the steps from tnrs.tpl

setwd("/home/oliver/Downloads/")
# note that we dont have this single files anymore
system.time(
    x <- foreach(i = 1:length(seq1), .combine = rbind) %dopar% {
    read.csv(paste(paste("/home/oliver/Downloads/tnrs.trop", seq1[i], sep = "."), "csv", sep = "."), sep = ",", stringsAsFactors = FALSE, skip = 0, head = T)[-1, ]
}
    )

tnrs.trop <- x

# tnrs.trop:
str(tnrs.trop)
tnrs.trop$Name_number <- 1:length(tnrs.trop$Name_number)
# reduce to the uncertain species from tnrs.tpl
tnrs.trop.small <- tnrs.trop[tnrs.all.small.uncertain$Name_number, ]
str(tnrs.trop.small)

save(tnrs.trop.small, file = "tnrs.trop.small.Rdata")
write.csv(tnrs.trop.small, file = "tnrs.trop.small.csv")

###
index.family <- tnrs.trop.small[which(tnrs.trop.small$Name_matched_rank == "family" & (tnrs.trop.small$Taxonomic_status == "Accepted"| tnrs.trop.small$Taxonomic_status == "Synonym")), 1]
length(index.family)

index.forma <- tnrs.trop.small[which(tnrs.trop.small$Name_matched_rank == "forma" & (tnrs.trop.small$Taxonomic_status == "Accepted" | tnrs.trop.small$Taxonomic_status == "Synonym")), 1]
length(index.forma)

index.genus <- tnrs.trop.small[which(tnrs.trop.small$Name_matched_rank == "genus" & (tnrs.trop.small$Taxonomic_status == "Accepted" | tnrs.trop.small$Taxonomic_status == "Synonym") & tnrs.trop.small$Genus_score > 0.83 & tnrs.trop.small$Name_score > 0.5), 1]
length(index.genus)

# continue here:
index.species1 <- tnrs.trop.small[which(tnrs.trop.small$Name_matched_rank == "species" & (tnrs.trop.small$Taxonomic_status == "Accepted" | tnrs.trop.small$Taxonomic_status == "Synonym") & tnrs.trop.small$Genus_score > 0.88 & tnrs.trop.small$Name_score > 0.9), 1]
length(index.species1)

index.species2 <- tnrs.trop.small[which(tnrs.trop.small$Name_matched_rank == "species" & (tnrs.trop.small$Taxonomic_status == "Accepted" | tnrs.trop.small$Taxonomic_status == "Synonym") & tnrs.trop.small$Genus_score > 0.78 & tnrs.trop.small$Name_score > 0.94), 1]
length(index.species1)

index.species3 <- tnrs.trop.small[which(tnrs.trop.small$Name_matched_rank == "species" & (tnrs.trop.small$Taxonomic_status == "Accepted" | tnrs.trop.small$Taxonomic_status == "Synonym") & tnrs.trop.small$Genus_score > 0.88 & tnrs.trop.small$Name_score > 0.49), 1]
length(index.species3)

index.species <- unique(c(index.species1, index.species2, index.species3))
length(index.species)

index.subspec <- tnrs.trop.small[which(tnrs.trop.small$Name_matched_rank == "subspecies" & (tnrs.trop.small$Taxonomic_status == "Accepted" | tnrs.trop.small$Taxonomic_status == "Synonym")), 1]
length(index.subspec)

index.variety <- tnrs.trop.small[which(tnrs.trop.small$Name_matched_rank == "variety" & (tnrs.trop.small$Taxonomic_status == "Accepted" | tnrs.trop.small$Taxonomic_status == "Synonym")), 1]
length(index.variety)

index.trop <- c(index.family, index.forma, index.genus, index.species, index.subspec, index.variety)
length((index.trop))

##
tnrs.trop.small.certain <- tnrs.trop.small[tnrs.trop.small$Name_number %in% index.trop == T,]
dim(tnrs.trop.small.certain)
save(tnrs.trop.small.certain, file = "tnrs.trop.small.certain.Rdata")
write.csv(tnrs.trop.small.certain, file = "tnrs.trop.small.certain.csv")

tnrs.trop.small.uncertain <- tnrs.trop.small[tnrs.trop.small$Name_number %in% index.trop == F, ]
dim(tnrs.trop.small.uncertain)
save(tnrs.trop.small.uncertain, file = "tnrs.trop.small.uncertain.Rdata")
write.csv(tnrs.trop.small.uncertain, file = "tnrs.trop.small.uncertain.csv")
index.subspec <- tnrs.trop.small[which(tnrs.trop.small$Name_matched_rank == "subspecies" & (tnrs.trop.small$Taxonomic_status == "Accepted" | tnrs.trop.small$Taxonomic_status == "Synonym")), 1]
length(index.subspec)

index.variety <- tnrs.trop.small[which(tnrs.trop.small$Name_matched_rank == "variety" & (tnrs.trop.small$Taxonomic_status == "Accepted" | tnrs.trop.small$Taxonomic_status == "Synonym")), 1]
length(index.variety)

index.trop <- c(index.family, index.forma, index.genus, index.species, index.subspec, index.variety)
length((index.trop))

##
tnrs.trop.small.certain <- tnrs.trop.small[tnrs.trop.small$Name_number %in% index.trop == T,]
dim(tnrs.trop.small.certain)
save(tnrs.trop.small.certain, file = "tnrs.trop.small.certain.Rdata")
write.csv(tnrs.trop.small.certain, file = "tnrs.trop.small.certain.csv")

tnrs.trop.small.uncertain <- tnrs.trop.small[tnrs.trop.small$Name_number %in% index.trop == F, ]
dim(tnrs.trop.small.uncertain)
save(tnrs.trop.small.uncertain, file = "tnrs.trop.small.uncertain.Rdata")
write.csv(tnrs.trop.small.uncertain, file = "tnrs.trop.small.uncertain.csv")

### run against NCBI
write.csv(tnrs.trop.small.uncertain$Name_submitted[1:5000], file = "trop.uncert.1.csv")
write.csv(tnrs.trop.small.uncertain$Name_submitted[5001:9641], file = "trop.uncert.5001.csv")


# 9.4) identify unresolved species (excluding "Spermatophyta...") from 1.-4. (which were not indexed according to my procedure above) and run against TPL again (using six sources BUT take NCBI first)

# 
tnrs.ncbi.1 <- read.csv("/home/oliver/Downloads/tnrs.trop.uncert.1.csv", stringsAsFactors = FALSE)[-1,]
tnrs.ncbi.2 <- read.csv("/home/oliver/Downloads/tnrs.trop.uncert.5001.csv", stringsAsFactors = FALSE)[-1,]

tnrs.ncbi <- rbind(tnrs.ncbi.1, tnrs.ncbi.2)
str(tnrs.ncbi)
range(tnrs.trop.small.uncertain$Name_number)
# give index:
tnrs.ncbi$Name_number <- tnrs.trop.small.uncertain$Name_number
range(tnrs.ncbi$Name_number)

save(tnrs.ncbi, file = "tnrs.ncbi.Rdata")
write.csv(tnrs.ncbi, file = "tnrs.ncbi.csv")

# for tnrs.ncbi, identify certain and uncertain species:
index.family <- tnrs.ncbi[which(tnrs.ncbi$Name_matched_rank == "family" & (tnrs.ncbi$Taxonomic_status == "Accepted"| tnrs.ncbi$Taxonomic_status == "Synonym") & tnrs.ncbi$Family_score > 0.85), 1]
length(index.family)

index.genus.1 <- tnrs.ncbi[which(tnrs.ncbi$Name_matched_rank == "genus" & (tnrs.ncbi$Taxonomic_status == "Accepted" | tnrs.ncbi$Taxonomic_status == "Synonym") & tnrs.ncbi$Genus_score > 0.89 & tnrs.ncbi$Name_score > 0.49), 1]
length(index.genus.1)

index.genus.2 <- tnrs.ncbi[which(tnrs.ncbi$Name_matched_rank == "genus" & (tnrs.ncbi$Taxonomic_status == "Accepted" | tnrs.ncbi$Taxonomic_status == "Synonym") & tnrs.ncbi$Genus_score > 0.99 & tnrs.ncbi$Name_score > 0.2), 1]
length(index.genus.2)

index.genus.3 <- tnrs.ncbi[which(tnrs.ncbi$Name_matched_rank == "genus" & tnrs.ncbi$Taxonomic_status == "No opinion" & tnrs.ncbi$Genus_score > 0.88 & tnrs.ncbi$Name_score > 0.49), 1]
length(index.genus.3)

index.genus <- unique(c(index.genus.1, index.genus.2, index.genus.3))
length(index.genus)

###
index.species.1 <- tnrs.ncbi[which(tnrs.ncbi$Name_matched_rank == "species" & (tnrs.ncbi$Taxonomic_status == "Accepted" | tnrs.ncbi$Taxonomic_status == "Synonym") & tnrs.ncbi$Name_score > 0.94), 1]
length(index.species.1)

index.species.2 <- tnrs.ncbi[which(tnrs.ncbi$Name_matched_rank == "species" & (tnrs.ncbi$Taxonomic_status == "Accepted" | tnrs.ncbi$Taxonomic_status == "Synonym") & tnrs.ncbi$Genus_score > 0.81 & tnrs.ncbi$Name_score > 0.51), 1]
length(index.species.2)

index.species.3 <- tnrs.ncbi[which(tnrs.ncbi$Name_matched_rank == "species" & tnrs.ncbi$Taxonomic_status == "No opinion"  & tnrs.ncbi$Genus_score > 0.7 & tnrs.ncbi$Specific_epithet_score > 0.75), 1]
length(index.species.3)

index.species <- unique(c(index.species.1, index.species.2, index.species.3))
length(index.species)

index.var <- tnrs.ncbi[which((tnrs.ncbi$Name_matched_rank == "subspecies" | tnrs.ncbi$Name_matched_rank == "unknown" | tnrs.ncbi$Name_matched_rank == "variety") & (tnrs.ncbi$Taxonomic_status == "Accepted" | tnrs.ncbi$Taxonomic_status == "No opinion" | tnrs.ncbi$Taxonomic_status == "Synonym")), 1]
length(index.var)

index.ncbi <- c(index.family, index.genus, index.species, index.var)
length((index.ncbi))

# identify certain and uncertain species:
tnrs.ncbi.certain <- tnrs.ncbi[tnrs.ncbi$Name_number %in% index.ncbi == T,]
dim(tnrs.ncbi.certain)
save(tnrs.ncbi.certain, file = "tnrs.ncbi.certain.Rdata")
write.csv(tnrs.ncbi.certain, file = "tnrs.ncbi.certain.csv")

tnrs.ncbi.uncertain <- tnrs.ncbi[tnrs.ncbi$Name_number %in% index.ncbi == F, ]
dim(tnrs.ncbi.uncertain)
save(tnrs.ncbi.uncertain, file = "tnrs.ncbi.uncertain.Rdata")
write.csv(tnrs.ncbi.uncertain, file = "tnrs.ncbi.uncertain.csv")

# -> tnrs.ncbi.uncertain gives us 1464 names, with which we do the following:
# 1) send 679 of them to Jürgen, but some of them I could resolve using the manual matching tools on the TPL homepage
# 2) the others i have checked manually

# 14:30-15:00 14.-16.nov. 2015
# in the list that i initially send to Jürgen, i corrected 62 more species using the manual name matiching tools on the TPL homepage
# e.g. Dicra vagin var. clathrata -> Dicranella vaginata

for.juergen.2 <- read.csv("for.juergen.2.csv")
head(for.juergen.2)

### further manually correct some further mispellings (e.g. ABIESNORD., ..xboris.. etc. spec1 ...) + resolve some names according to the TNRS workflow above

# first, select non-jürgen, corrected and correct species in "tnrs.ncbi.uncertain.corrected.csv"
# ! note, this file is in the download folder, so it no longer exists
ncbi.uncertain.corr <- read.csv("/home/oliver/Downloads/tnrs.ncbi.uncertain.corrected.csv")
# str(ncbi.uncertain.corr)
# i guess this file contains the 1464 uncertain species, yes they do

# select 679 species for jürgen and the species that i corrected manually:

index.juergen.corrected <- ncbi.uncertain.corr[which((ncbi.uncertain.corr$for_Jürgen == "x" | ncbi.uncertain.corr$corrected != "")), 2] 
length(index.juergen.corrected)


# further select some correct species within genus
index.correct.genus <- ncbi.uncertain.corr[which((ncbi.uncertain.corr$Name_matched_rank == "genus" & ncbi.uncertain.corr$Taxonomic_status == "Accepted" & ncbi.uncertain.corr$Overall_score > 0.6)), 2] 
length(index.correct.genus)

index.juergen.corrected <- ncbi.uncertain.corr[which((ncbi.uncertain.corr$for_Jürgen == "x" | ncbi.uncertain.corr$corrected != "")), 2] 
length(index.juergen.corrected)

#####
# further select some correct species within species
index.correct.species <- ncbi.uncertain.corr[which((ncbi.uncertain.corr$Name_matched_rank == "species" & ncbi.uncertain.corr$Taxonomic_status == "Accepted" & ncbi.uncertain.corr$Overall_score > 0.89)), 2] 
length(index.correct.species)

index.ncbi <- unique(c(index.juergen.corrected, index.correct.genus, index.correct.species))
length(index.ncbi)

# identify certain and uncertain species:
ncbi.uncertain.corr.certain <- ncbi.uncertain.corr[ncbi.uncertain.corr$Name_number %in% index.ncbi == T,]
dim(ncbi.uncertain.corr.certain)
save(ncbi.uncertain.corr.certain, file = "ncbi.uncertain.corr.certain.Rdata") 
write.csv(ncbi.uncertain.corr.certain, file = "ncbi.uncertain.corr.certain.csv")

ncbi.uncertain.corr.uncertain <- ncbi.uncertain.corr[ncbi.uncertain.corr$Name_number %in% index.ncbi == F, ]
dim(ncbi.uncertain.corr.uncertain)
save(ncbi.uncertain.corr.uncertain, file = "ncbi.uncertain.corr.uncertain.Rdata")
write.csv(ncbi.uncertain.corr.uncertain, file = "ncbi.uncertain.corr.uncertain.csv")

# ncbi.uncertain.corr.certain & ncbi.uncertain.corr.uncertain, indeed add up to the ncbi-uncertain species


# use TPL to resolve names in "ncbi.uncertain.corr.uncertain"
ncbi.uncertain <- as.character(ncbi.uncertain.corr.uncertain$Name_submitted)

# 1) run raw list (allow for fuzzy matching)
tpl.ncbi.1 <- TPL(ncbi.uncertain, corr=T, diffchar = 9, max.distance = 9)
tpl.ncbi.1 <- gsub("[", "", tpl.ncbi.1)
tpl.ncbi.1 <- gsub("]", "", tpl.ncbi.1)
tpl.ncbi.1 <- gsub("|", "", tpl.ncbi.1)
tpl.ncbi.1 <- gsub("?", "", tpl.ncbi.1)

write.csv(tpl.ncbi.1, file = "tpl.ncbi.1.csv")

# 2) extent each word eby "*", to allow for even fuzzier matching
ncbi.uncertain.2 <- paste(gsub(" ", "* ", ncbi.uncertain), "*", sep = "")

tpl.ncbi.2 <- TPL(ncbi.uncertain.2, corr=T, diffchar = 9, max.distance = 9)
write.csv(tpl.ncbi.2, file = "tpl.ncbi.2.csv")

# 3) cut to first 5 letter and extent by "*", to do more fuzzy matching

simpleCap3 <- function(x) {
  s <- strsplit(x, " ")[[1]]
  paste(paste(substring(s, 1,1), substring(s, 2,3), sep="", collapse="* "), "*", sep = "")
}

simpleCap5 <- function(x) {
  s <- strsplit(x, " ")[[1]]
  paste(paste(substring(s, 1,1), substring(s, 2,5), sep="", collapse="* "), "*", sep = "")
}

simpleCap7 <- function(x) {
  s <- strsplit(x, " ")[[1]]
  paste(paste(substring(s, 1,1), substring(s, 2,7), sep="", collapse="* "), "*", sep = "")
}

# apply the string truncation functions above, to k:
ncbi.uncertain.3 <- sapply(ncbi.uncertain, simpleCap3)

# remove some strings to improve name matching
ncbi.uncertain.3 <- gsub("[", "", ncbi.uncertain.3, fixed = T)
ncbi.uncertain.3 <- gsub("]", "", ncbi.uncertain.3, fixed = T)
ncbi.uncertain.3 <- gsub("|", "", ncbi.uncertain.3, fixed = T)
ncbi.uncertain.3 <- gsub("?", "", ncbi.uncertain.3, fixed = T)
ncbi.uncertain.3 <- gsub("+", "", ncbi.uncertain.3, fixed = T)
ncbi.uncertain.3 <- gsub(".", "", ncbi.uncertain.3, fixed = T)
ncbi.uncertain.3 <- gsub("<", "", ncbi.uncertain.3, fixed = T)
ncbi.uncertain.3 <- gsub("/", "", ncbi.uncertain.3, fixed = T)
str(ncbi.uncertain.3)

tpl.ncbi.3 <- TPL(ncbi.uncertain.3, corr=T, diffchar = 9, max.distance = 9)
write.csv(tpl.ncbi.3, file = "tpl.ncbi.3.csv")

tpl.ncbi.5 <- TPL(ncbi.uncertain.5, corr=T, diffchar = 9, max.distance = 9)
write.csv(tpl.ncbi.5, file = "tpl.ncbi.5.csv")

tpl.ncbi.7 <- TPL(ncbi.uncertain.7, corr=T, diffchar = 9, max.distance = 9)
write.csv(tpl.ncbi.7, file = "tpl.ncbi.7.csv")

#  put tpl.ncbi tables together:
tpl.ncbi <- cbind(tpl.ncbi.1[,c(1,2,6,8,10,12)], tpl.ncbi.2[,c(6,8,10,12)], tpl.ncbi.3[,c(6,8,10,12)], tpl.ncbi.5[,c(6,8,10,12)], tpl.ncbi.7[,c(6,8,10,12)])

rownames(tpl.ncbi) <- rownames(tpl.ncbi.7)

tpl.ncbi <- cbind(ncbi.uncertain.corr.uncertain[,1:2], tpl.ncbi)
str(tpl.ncbi)
tpl.ncbi <- tpl.ncbi[,-1]

write.csv(tpl.ncbi, file = "tpl.ncbi.csv")
# manually select correct genera and species in "tpl.ncbi" and add columns "Genus.correct" and "Species.correct"

# load tpl.ncbi
tpl.ncbi.2 <- read.csv("tpl.ncbi.csv")
str(tpl.ncbi.2)
names(tpl.ncbi.2)
# select corrected species
tpl.ncbi.2$name.correct <- paste(tpl.ncbi.2$Genus.correct, tpl.ncbi.2$Species.correct)
index.corr <- tpl.ncbi.2[which(tpl.ncbi.2$name.correct != " "), 2] 

# which rows in ncbi.uncertain correspond to index.corr?
ncbi.uncertain.corr.uncertain.2 <- join(ncbi.uncertain.corr.uncertain, tpl.ncbi.2[,c(1,2,6,26:29)], by = "Name_number")

str(ncbi.uncertain.corr.uncertain.2)
names(ncbi.uncertain.corr.uncertain.2)

write.csv(ncbi.uncertain.corr.uncertain.2, file = "ncbi.uncertain.corr.uncertain.2.csv")

ncbi.uncertain.corr.uncertain.2 <- read.csv("ncbi.uncertain.corr.uncertain.2.csv")

# if names were not corrected put "Taxonomic.status" == ""
ncbi.uncertain.corr.uncertain.2$Status.correct[ncbi.uncertain.corr.uncertain.2$Status.correct==""] <- ncbi.uncertain.corr.uncertain.2$Taxonomic.status[ncbi.uncertain.corr.uncertain.2$Status.correct==""]

summary(ncbi.uncertain.corr.uncertain.2$Status.correct)
str(ncbi.uncertain.corr.uncertain.2$Status.correct)

# assign "No suitable matches found." to the remaining species:
ncbi.uncertain.corr.uncertain.2$Status.correct <- as.character(ncbi.uncertain.corr.uncertain.2$Status.correct)
ncbi.uncertain.corr.uncertain.2$Status.correct[is.na(ncbi.uncertain.corr.uncertain.2$Status.correct)] <- "No suitable matches found."

# add uncorrected names in "X" (names submitted) to "name.correct"
ncbi.uncertain.corr.uncertain.2$name.correct[ncbi.uncertain.corr.uncertain.2$Genus.correct==""] <- as.character(ncbi.uncertain.corr.uncertain.2[,41])[ncbi.uncertain.corr.uncertain.2$Genus.correct==""]

# add "No suitable matches found." to remaining species in "name.correct" according to "Status.correct"
ncbi.uncertain.corr.uncertain.2$name.correct[ncbi.uncertain.corr.uncertain.2$Status.correct=="No suitable matches found."] <- "No suitable matches found."

write.csv(ncbi.uncertain.corr.uncertain.2, file = "ncbi.uncertain.corr.uncertain.2.csv")

## done!! take "ncbi.uncertain.corr.uncertain.2" for merging with the other data sets

# 9.6: check ncbi.certain:
# a) create extra column (species.correct) and add species in "Jürgen.corrected (679) to "certain", status=accepted for resolved species, status="No suitable matches found." for the remaining non.resolved species

juergen.correct <- read.csv("/home/oliver/Dokumente/PhD/PostPhD/IDiv/sDiv/sPlot/Analyses/Code/Unresolved_sPlot2.0_TRY3.0_2_JD.csv", stringsAsFactors=FALSE)

# fill non-correctable species with "No suitable matches found."
juergen.correct$Taxon[juergen.correct$Taxon==""] <- "No suitable matches found."

str(juergen.correct)

str(ncbi.uncertain.corr.certain)

# join the two based on Name_number
ncbi.certain.juergen.corr <- join(ncbi.uncertain.corr.certain, juergen.correct[,c(2,3,8)], by = "Name_number")
str(ncbi.certain.juergen.corr)
write.csv(ncbi.certain.juergen.corr, file = "ncbi.certain.juergen.corr.csv")

ncbi.certain.juergen.corr.2 <- read.csv("ncbi.certain.juergen.corr.csv", stringsAsFactors=FALSE)
str(ncbi.certain.juergen.corr.2)

# add some more corrected species from ncbi.certain.juergen.corr.2$corrected to "name.correct"
ncbi.certain.juergen.corr.2$name.correct[is.na(ncbi.certain.juergen.corr.2$name.correct)] <- ncbi.certain.juergen.corr.2$corrected[is.na(ncbi.certain.juergen.corr.2$name.correct)]

write.csv(ncbi.certain.juergen.corr.2, file = "ncbi.certain.juergen.corr.2.csv")


# fill remaining missing names in "name.correct", because they were correctly resolved
ncbi.certain.juergen.corr.2$name.correct[ncbi.certain.juergen.corr.2$name.correct==""] <- ncbi.certain.juergen.corr.2$Name_matched[ncbi.certain.juergen.corr.2$name.correct==""]

# yay, the "ncbi.certain.juergen.corr.2" species are finished!!! now merge it with "ncbi.uncertain.corr.uncertain.2" (gives ~1400 species) !! add tag "manual matching" (means the scores from TNRS matching are useless here, but nevertheless keep them)

# .. and check other earlier tpl.ncbi.certain data for species that have been reduced to genus levels  (? is this the case in the tropicos, tpl data sets as well?)

# ncbi.certain.juergen.corr.2
# ncbi.uncertain.corr.uncertain.2

ncbi.certain.juergen.corr.3 <- read.csv("ncbi.certain.juergen.corr.3.csv", stringsAsFactors=FALSE)
str(ncbi.certain.juergen.corr.3)

ncbi.uncertain.corr.uncertain.3 <- read.csv("ncbi.uncertain.corr.uncertain.3.csv", stringsAsFactors=FALSE)
str(ncbi.uncertain.corr.uncertain.3)



## add status for "ncbi.certain.juergen.corr.3": "No suitable matches found." or "Accepted"
ncbi.certain.juergen.corr.3$Status.correct[ncbi.certain.juergen.corr.3$name.correct == "No suitable matches found."] <- "No suitable matches found."

ncbi.certain.juergen.corr.3$Status.correct[is.na(ncbi.certain.juergen.corr.3$Status.correct)] <- "Accepted"
write.csv(ncbi.certain.juergen.corr.3, file = "ncbi.certain.juergen.corr.3.csv")

# add manual matching == x
ncbi.certain.juergen.corr.3$Manual.matching <- "x"
ncbi.uncertain.corr.uncertain.3$Manual.matching <- "x"
write.csv(ncbi.certain.juergen.corr.3, file = "ncbi.certain.juergen.corr.3.csv")
write.csv(ncbi.uncertain.corr.uncertain.3, file = "ncbi.uncertain.corr.uncertain.3.csv")

# combine the two data sets:
names(ncbi.certain.juergen.corr.3)
names(ncbi.uncertain.corr.uncertain.3)

ncbi.certain.juergen.corr.3 <- ncbi.certain.juergen.corr.3[,-c(1,2,3)]
ncbi.uncertain.corr.uncertain.3 <- ncbi.uncertain.corr.uncertain.3[,-c(1,2)]

match(names(ncbi.uncertain.corr.uncertain.3), names(ncbi.certain.juergen.corr.3))

ncbi.uncertain.comb <- rbind(ncbi.uncertain.corr.uncertain.3, ncbi.certain.juergen.corr.3)
dim(ncbi.uncertain.comb)
write.csv(ncbi.uncertain.comb, file = "ncbi.uncertain.comb.csv")

## read in "tnrs.ncbi.certain"
tnrs.ncbi.certain <- read.csv("/home/oliver/Downloads/tnrs.ncbi.certain.csv", stringsAsFactors=FALSE)
str(tnrs.ncbi.certain)

# 10) resolve some more species that were previously reduced to genus-level by TNRS
# to resolve names where species were reduced to genus-level, identify "Name_submitted" where "Overall_score" == 0.5

index0.5 <- tnrs.ncbi.certain[which(tnrs.ncbi.certain$Overall_score == 0.5), 2]

tpl0.5 <- tnrs.ncbi.certain$Name_submitted[tnrs.ncbi.certain$Overall_score == 0.5]

names(tpl0.5) <- index0.5

str(tpl0.5)
length(tpl0.5)
tpl0.5[1:100]

save(tpl0.5, file = "tpl0.5.Rdata")

# do some string cleaning to improve matching:
tpl0.5 <- gsub("[", "", tpl0.5, fixed = T)
tpl0.5 <- gsub("]", "", tpl0.5, fixed = T)
tpl0.5 <- gsub("|", "", tpl0.5, fixed = T)
tpl0.5 <- gsub("?", "", tpl0.5, fixed = T)
tpl0.5 <- gsub("+", "", tpl0.5, fixed = T)
tpl0.5 <- gsub(".", "", tpl0.5, fixed = T)
tpl0.5 <- gsub("<", "", tpl0.5, fixed = T)
tpl0.5 <- gsub("/", "", tpl0.5, fixed = T)

# 1)
system.time(
tpl0.5.res <- TPL(tpl0.5, corr=T, diffchar = 2, max.distance = 1)
)
write.csv(tpl0.5.res, file = "tpl0.5.res.csv")


# 2)
tpl0.5.2 <- paste(gsub(" ", "* ", tpl0.5), "*", sep = "")
tpl0.5.2.res <- TPL(tpl0.5.2, corr=T, diffchar = 2, max.distance = 1)
write.csv(tpl0.5.2.res, file = "tpl0.5.2.res.csv")

# 3)
tpl0.5.5 <- sapply(tpl0.5, simpleCap5)
tpl0.5.5.res <- TPL(tpl0.5.5, corr=T, diffchar = 2, max.distance = 1)
write.csv(tpl0.5.5.res, file = "tpl0.5.5.res.csv")

# 4)
tpl0.5.7 <- sapply(tpl0.5, simpleCap7)
tpl0.5.7.res <- TPL(tpl0.5.7, corr=T, diffchar = 2, max.distance = 1)
write.csv(tpl0.5.7.res, file = "tpl0.5.7.res.csv")

tpl0.5.res <- read.csv("tpl0.5.res.csv", stringsAsFactors=FALSE)
tpl0.5.2.res <- read.csv("tpl0.5.2.res.csv", stringsAsFactors=FALSE)
tpl0.5.5.res <- read.csv("tpl0.5.5.res.csv", stringsAsFactors=FALSE)
tpl0.5.7.res <- read.csv("tpl0.5.7.res.csv", stringsAsFactors=FALSE)

tpl.res.comb <- cbind(tpl0.5.res[,c(1,2,3,7,9,11,13)],
tpl0.5.2.res[,c(7,9,11,13)], tpl0.5.5.res[,c(7,9,11,13)],
tpl0.5.7.res[,c(7,9,11,13)])
                                                                                   
head(tpl.res.comb)
write.csv(tpl.res.comb, file = "tpl.res.comb.csv")

tpl.res.comb <- read.csv("tpl.res.comb.csv", stringsAsFactors=FALSE)

# manually add and fill in new columns "Status.correct"	"Genus.correct"	"Species.correct" to "tpl.res.comb.csv"


# combine species.correct and genus.correct
tpl.res.comb <- read.csv("tpl.res.comb.csv", stringsAsFactors=FALSE)
str(tpl.res.comb)
names(tpl.res.comb)
tpl.res.comb$name.correct <- paste(tpl.res.comb$Genus.correct,
tpl.res.comb$Species.correct)

tpl.res.comb.2 <- tpl.res.comb

# join "tnrs.ncbi.certain" and "tpl.res.comb.2"
names(tpl.res.comb.2)
names(tpl.res.comb.2)[2] <- "Name_number"

names(tnrs.ncbi.certain)

# continue here: get match correct
tnrs.ncbi.certain.0.5 <- join(tnrs.ncbi.certain[match(index0.5, tnrs.ncbi.certain$Name_number),], tpl.res.comb.2[,c(3,23:26)], by =
"Name_number")

write.csv(tnrs.ncbi.certain.0.5, file = "tnrs.ncbi.certain.0.5.csv")

# fill in extra columns in "tnrs.ncbi.certain.0.5"
tnrs.ncbi.certain.0.5 <- read.csv("tnrs.ncbi.certain.0.5.csv", stringsAsFactors=FALSE)
str(tnrs.ncbi.certain.0.5)
names(tnrs.ncbi.certain.0.5)
str(tnrs.ncbi.certain.0.5$Genus.correct)

# fill "Manual.matching"
tnrs.ncbi.certain.0.5$Manual.matching[tnrs.ncbi.certain.0.5$Genus.correct != ""] <- "x"

# fill "Status.correct"
tnrs.ncbi.certain.0.5$Status.correct[tnrs.ncbi.certain.0.5$Status.correct == ""] <- tnrs.ncbi.certain.0.5$Taxonomic_status[tnrs.ncbi.certain.0.5$Status.correct == ""]

# fill "name.correct"
tnrs.ncbi.certain.0.5$name.correct[tnrs.ncbi.certain.0.5$name.correct == " "] <- tnrs.ncbi.certain.0.5$Name_matched[tnrs.ncbi.certain.0.5$name.correct == " "]

write.csv(tnrs.ncbi.certain.0.5, file = "tnrs.ncbi.certain.0.5.csv")


# combine "tnrs.ncbi.certain.0.5" with the remaining "tnrs.ncbi.certain"
str(tnrs.ncbi.certain.0.5)
names(tnrs.ncbi.certain.0.5)

cert.0.5 <- tnrs.ncbi.certain[tnrs.ncbi.certain$Overall_score == 0.5,]
dim(cert.0.5)
str(cert.0.5)

cert.non.0.5 <- tnrs.ncbi.certain[tnrs.ncbi.certain$Overall_score != 0.5,]
dim(cert.non.0.5)
str(cert.non.0.5)
names(cert.non.0.5)

# add three more cols to "cert.non.0.5"
cert.non.0.5$Manual.matching <- NA
cert.non.0.5$Status.correct <- NA
cert.non.0.5$name.correct <- NA

tnrs.ncbi.certain.comb <- rbind(tnrs.ncbi.certain.0.5[,c(3:41,44)], cert.non.0.5[,c(2:41)])
dim(tnrs.ncbi.certain.comb)
write.csv(tnrs.ncbi.certain.comb, file = "tnrs.ncbi.certain.comb.csv")


## yay, now merge the big data sets
# 1) TPL.small.certain
load("tnrs.tpl.certain.Rdata")
dim(tnrs.tpl.certain)

# 2) all.small.certain
load("tnrs.all.small.certain.Rdata")
dim(tnrs.all.small.certain)

# 3) trop.small.certain
load("tnrs.trop.small.certain.Rdata")
dim(tnrs.trop.small.certain)

# combine the certain data sets
tnrs.tpl.all.trop.certain <- rbind(tnrs.tpl.certain, tnrs.all.small.certain, tnrs.trop.small.certain)
dim(tnrs.tpl.all.trop.certain)

# and add the four additional cols
names(tnrs.tpl.all.trop.certain)

tnrs.tpl.all.trop.certain$Manual.matching <- NA
tnrs.tpl.all.trop.certain$Status.correct <- NA
tnrs.tpl.all.trop.certain$name.correct <- NA
tnrs.tpl.all.trop.certain$rank.correct <- NA


# 4) pick the respective "ncbi" data sets
# for the 8177 certain species
names(tnrs.ncbi.certain.comb)
tnrs.ncbi.certain.comb$rank.correct <- NA
# combine the two lists
tnrs.tpl.all.trop.certain.2 <- rbind(tnrs.tpl.all.trop.certain, tnrs.ncbi.certain.comb)
dim(tnrs.tpl.all.trop.certain.2)
names(tnrs.tpl.all.trop.certain.2)

# now, take the combined uncertain species (Jürgens and the other)
names(ncbi.uncertain.comb)
# exclude columns "Jürgen" and "corrected"
ncbi.uncertain.comb.2 <- ncbi.uncertain.comb[,-c(5,6)]
names(ncbi.uncertain.comb.2)
ncbi.uncertain.comb.2$rank.correct <- NA

# combine them
tnrs.tpl.all.trop.tnrs.certain <- rbind(tnrs.tpl.all.trop.certain.2, ncbi.uncertain.comb.2)
write.csv(tnrs.tpl.all.trop.tnrs.certain, file = "tnrs.tpl.all.trop.tnrs.certain.csv")
save(tnrs.tpl.all.trop.tnrs.certain, file = "tnrs.tpl.all.trop.tnrs.certain.Rdata")

# correct one more species name
tnrs.tpl.all.trop.tnrs.certain$name.correct[which(tnrs.tpl.all.trop.tnrs.certain$name.correct == "ABIES NORDMANNIANA")] <- "Abies nordmanniana"


# FINAL cleaning:
# complement the last four columns
dim(tnrs.tpl.all.trop.tnrs.certain)
names(tnrs.tpl.all.trop.tnrs.certain)

# fill "rank.correct"
tnrs.tpl.all.trop.tnrs.certain.filled <- tnrs.tpl.all.trop.tnrs.certain

tnrs.tpl.all.trop.tnrs.certain.filled$rank.correct <- as.character(tnrs.tpl.all.trop.tnrs.certain.filled$rank.correct)

tnrs.tpl.all.trop.tnrs.certain.filled$rank.correct[is.na(tnrs.tpl.all.trop.tnrs.certain.filled$Manual.matching)] <- tnrs.tpl.all.trop.tnrs.certain.filled$Name_matched_rank[is.na(tnrs.tpl.all.trop.tnrs.certain.filled$Manual.matching)]

# fill "status.correct"
tnrs.tpl.all.trop.tnrs.certain.filled$Status.correct[is.na(tnrs.tpl.all.trop.tnrs.certain.filled$Manual.matching)] <- tnrs.tpl.all.trop.tnrs.certain.filled$Taxonomic_status[is.na(tnrs.tpl.all.trop.tnrs.certain.filled$Manual.matching)]

# fill "name.correct"
tnrs.tpl.all.trop.tnrs.certain.filled$name.correct[is.na(tnrs.tpl.all.trop.tnrs.certain.filled$Manual.matching)] <- tnrs.tpl.all.trop.tnrs.certain.filled$Accepted_name[is.na(tnrs.tpl.all.trop.tnrs.certain.filled$Manual.matching)]


# fill "name.correct" # if status.correct is "No opinion"
tnrs.tpl.all.trop.tnrs.certain.filled$name.correct[which(tnrs.tpl.all.trop.tnrs.certain.filled$Status.correct == "No opinion")] <- tnrs.tpl.all.trop.tnrs.certain.filled$Name_matched[which(tnrs.tpl.all.trop.tnrs.certain.filled$Status.correct == "No opinion")]

write.csv(tnrs.tpl.all.trop.tnrs.certain.filled, file = "tnrs.tpl.all.trop.tnrs.certain.filled.csv")


# in "tnrs.tpl.all.trop.tnrs.certain.filled" resolve some species manually on the TPL webpage


# resolve some more species that wree not resolved by tropicos:
tplupload <- read.csv("tplupload.csv", head = F)
tpl.res.67 <- TPL(as.character(tplupload[,1]), corr=T, diffchar = 9,
max.distance = 9)

write.csv(tpl.res.67, file = "tpl.res.67.csv")

# fill in names.short correct:
tnrs.tpl.all.trop.tnrs.certain.filled <- read.csv("tnrs.tpl.all.trop.tnrs.certain.filled.csv",
stringsAsFactors=FALSE)

names(tnrs.tpl.all.trop.tnrs.certain.filled)
str(tnrs.tpl.all.trop.tnrs.certain.filled)

tnrs.tpl.all.trop.tnrs.certain.filled$name.short.correct <- as.character(tnrs.tpl.all.trop.tnrs.certain.filled$name.short.correct)

# identify number of words in names
wordcount <- sapply(gregexpr("\\S+", tnrs.tpl.all.trop.tnrs.certain.filled$name.correct), length)

# shorten names that have more than 1 word
tnrs.tpl.all.trop.tnrs.certain.filled$name.short.correct[wordcount>1] <- word(tnrs.tpl.all.trop.tnrs.certain.filled$name.correct[wordcount>1], 1, 2)

###
# fill in one-word names
tnrs.tpl.all.trop.tnrs.certain.filled$name.short.correct[wordcount==1] <- tnrs.tpl.all.trop.tnrs.certain.filled$name.correct[wordcount==1]

# where is the second word an x:
length(word(tnrs.tpl.all.trop.tnrs.certain.filled$name.short.correct[wordcount>1], 2)=="x")

write.csv(tnrs.tpl.all.trop.tnrs.certain.filled, file = "tnrs.tpl.all.trop.tnrs.certain.filled.csv")

tnrs.tpl.all.trop.tnrs.certain.filled$name.short.correct[wordcount>2][(word(tnrs.tpl.all.trop.tnrs.certain.filled$name.correct[wordcount>2], 2)=="x")] <- word(tnrs.tpl.all.trop.tnrs.certain.filled$name.correct[wordcount>2] ,c(1,3))

# set index where wordcount is greater 2 and the second word == "x"
index <- word(tnrs.tpl.all.trop.tnrs.certain.filled$name.correct[wordcount>2], 2) == "x"
# 7900 species with more than 2 words and where 2nd word is "x"

# remove " x " from those names
wo.x <- paste(word(tnrs.tpl.all.trop.tnrs.certain.filled$name.correct[wordcount>2][index],
1), word(tnrs.tpl.all.trop.tnrs.certain.filled$name.correct[wordcount>2][index],
3))

tnrs.tpl.all.trop.tnrs.certain.filled$name.short.correct[wordcount>2][index] <- wo.x

###
# correct "name.short correct"
tnrs.tpl.all.trop.tnrs.certain.filled <- read.csv("tnrs.tpl.all.trop.tnrs.certain.filled.csv", stringsAsFactors=FALSE)
tnrs.tpl.all.trop.tnrs.certain.filled$name.short.correct[tnrs.tpl.all.trop.tnrs.certain.filled$name.correct == "No suitable matches found."] <- NA

####
# fill in "rank.short.correct"
tnrs.tpl.all.trop.tnrs.certain.filled$rank.short.correct <- tnrs.tpl.all.trop.tnrs.certain.filled$rank.correct

table(tnrs.tpl.all.trop.tnrs.certain.filled$rank.short.correct)

tnrs.tpl.all.trop.tnrs.certain.filled$rank.short.correct[tnrs.tpl.all.trop.tnrs.certain.filled$rank.correct == "infraspecies"] <- "species"

tnrs.tpl.all.trop.tnrs.certain.filled$rank.short.correct[tnrs.tpl.all.trop.tnrs.certain.filled$rank.correct == "subspecies"] <- "species"

tnrs.tpl.all.trop.tnrs.certain.filled$rank.short.correct[tnrs.tpl.all.trop.tnrs.certain.filled$rank.correct == "subvariety"] <- "species"

tnrs.tpl.all.trop.tnrs.certain.filled$rank.short.correct[tnrs.tpl.all.trop.tnrs.certain.filled$rank.correct == "variety"] <- "species"

tnrs.tpl.all.trop.tnrs.certain.filled$rank.short.correct[tnrs.tpl.all.trop.tnrs.certain.filled$rank.correct == "forma"] <- "species"

tnrs.tpl.all.trop.tnrs.certain.filled$rank.short.correct[tnrs.tpl.all.trop.tnrs.certain.filled$rank.correct == "unknown"] <- "family"

write.csv(tnrs.tpl.all.trop.tnrs.certain.filled, file = "tnrs.tpl.all.trop.tnrs.certain.filled.csv")

####
# fix families
tnrs.tpl.all.trop.tnrs.certain.filled <- read.csv("tnrs.tpl.all.trop.tnrs.certain.filled.csv",
stringsAsFactors=FALSE)

names(tnrs.tpl.all.trop.tnrs.certain.filled)
str(tnrs.tpl.all.trop.tnrs.certain.filled)

tnrs.tpl.all.trop.tnrs.certain.filled$family.correct <- as.character(tnrs.tpl.all.trop.tnrs.certain.filled$family.correct)

# rank==family
tnrs.tpl.all.trop.tnrs.certain.filled$family.correct[(is.na(tnrs.tpl.all.trop.tnrs.certain.filled$Manual.matching) & tnrs.tpl.all.trop.tnrs.certain.filled$rank.short.correct == "family")] <- 
    tnrs.tpl.all.trop.tnrs.certain.filled$name.correct[(is.na(tnrs.tpl.all.trop.tnrs.certain.filled$Manual.matching) & tnrs.tpl.all.trop.tnrs.certain.filled$rank.short.correct == "family")]

# other ranks
tnrs.tpl.all.trop.tnrs.certain.filled$family.correct[(is.na(tnrs.tpl.all.trop.tnrs.certain.filled$Manual.matching))]
<-
tnrs.tpl.all.trop.tnrs.certain.filled$Name_matched_accepted_family[(is.na(tnrs.tpl.all.trop.tnrs.certain.filled$Manual.matching))]

write.csv(tnrs.tpl.all.trop.tnrs.certain.filled, file =
"tnrs.tpl.all.trop.tnrs.certain.filled.csv")

# almost done:
# link backbone with original names and splot-try code

splot.try3.code <- read.csv("spec.list.TRY3.sPlot2.csv", stringsAsFactors=FALSE)
str(splot.try3.code)

backbone.splot.try3 <- read.csv("tnrs.tpl.all.trop.tnrs.certain.filled.small.csv", stringsAsFactors=FALSE)
str(backbone.splot.try3)

backbone.splot.try3 <- join(splot.try3.code, backbone.splot.try3, by = "Name_number")
str(backbone.splot.try3)

table(backbone.splot.try3$Status.correct)

backbone.splot.try3$Status.correct[backbone.splot.try3$Status.correct == "No opinion"] <- "Unresolved"

write.csv(backbone.splot.try3, file = "backbone.splot.try3.csv")
save(backbone.splot.try3, file = "backbone.splot.try3.Rdata")

# #
table(backbone.splot.try3$sPlot.TRY)


#
table(backbone.splot.try3$Manual.matching)
   x 
1675 

#
table(backbone.splot.try3$Status.correct)
Accepted No suitable matches found. 
95485                       1692 
                   Synonym                 Unresolved 
                     20952                       4772 


#
length(unique(backbone.splot.try3$name.correct))-1
90696

#
length(unique(backbone.splot.try3$family.correct))-1
665

#
length(unique(backbone.splot.try3$name.short.correct))-1
86528

#
table(backbone.splot.try3$rank.short.correct)
 family   genus  higher species 
   1880   13383    1211  105818 


# rename "no opinion" -> "unresolved" ## done already above


# 16:25-16:55 dealing with additional species in sPlot2.1

# 10) add the 7701 species that were in the ad-hoc version of splot2.1 
####
# get the non-matching species for sPlot July 2015 that do not match with the backbone for April 2015:
####
# apply the cleaning procedure, similar to the one used for splot 2.0

miss.new <- read.csv("/home/oliver/Dokumente/PhD/PostPhD/IDiv/sDiv/sPlot/Analyses/Code/Mismatches_29_07_2015_new.csv")
dim(miss.new)
# there are 7701 names in the splot version 29_07_2015 that were not in splot 2.0 (april 2015

OriginalNames <- as.character(miss.new$x)

## Name cleaning (spelling of ranks, name additions etc.)
OriginalNames <- gsub('*', '', OriginalNames, fixed=TRUE)
OriginalNames <- gsub('cf. ', '', OriginalNames, fixed=TRUE)
OriginalNames <- gsub('Cf. ', '', OriginalNames, fixed=TRUE)
OriginalNames <- gsub('[', '', OriginalNames, fixed=TRUE)
OriginalNames <- gsub(']', '', OriginalNames, fixed=TRUE)
OriginalNames <- gsub(' x ', ' ', OriginalNames, fixed=TRUE)
OriginalNames <- gsub('Ã—', '', OriginalNames, fixed=TRUE)
OriginalNames <- gsub('aff ', '', OriginalNames, fixed=TRUE)
OriginalNames <- gsub('(', '', OriginalNames, fixed=TRUE)
OriginalNames <- gsub(')', '', OriginalNames, fixed=TRUE)
OriginalNames <- gsub(' cf ', ' ', OriginalNames, fixed=TRUE)
OriginalNames <- gsub(' aff. ', ' ', OriginalNames, fixed=TRUE)
OriginalNames <- gsub('c‚e', 'ceae', OriginalNames, fixed=TRUE)
OriginalNames <- gsub('    ', ' ', OriginalNames, fixed=TRUE)
OriginalNames <- gsub('   ', ' ', OriginalNames, fixed=TRUE)
OriginalNames <- gsub('  ', ' ', OriginalNames, fixed=TRUE)
OriginalNames <- gsub('x-', '', OriginalNames, fixed=TRUE)
OriginalNames <- gsub('X-', '', OriginalNames, fixed=TRUE)
OriginalNames <- gsub('like ', '', OriginalNames, fixed=TRUE)  
OriginalNames <- gsub(',', '', OriginalNames, fixed=TRUE)  


library(stringr)
firstWordWithNumbers <- grepl('[0-9]', word(OriginalNames, 1))
numberOfWords <- sapply(gregexpr("\\W+", OriginalNames), length) + 1
OriginalNames[firstWordWithNumbers & numberOfWords > 1] <- sapply(OriginalNames[firstWordWithNumbers & numberOfWords > 1], function(x) substr(x, start=regexpr(pattern =' ', text=x)+1, stop=nchar(x)))

CleanedNames <- taxname.abbr(OriginalNames)

write.csv(CleanedNames, file = "CleanedNames.csv")
save(CleanedNames, file = "CleanedNames.Rdata")

# upload CleanedNames to TRNS, resolve first using all six source (TPL first), and after that using tropicos first
###
# tpl output for non-matching species in 29_7_2015 output
###

# tnrs.tpl.new <- read.csv("/home/oliver/Downloads/missing_tpl.txt", sep = "\t", stringsAsFactors = FALSE, skip = 0, head = T)[-1, ]
# str(tnrs.tpl.new)

tnrs.tpl <- read.csv("tnrs.tpl.csv")

# assign index to first column:
tnrs.tpl$Name_number <- 1:length(tnrs.tpl$Name_number)

tnrs.tpl <- tnrs.tpl[,-1]

index.family <- tnrs.tpl[which(tnrs.tpl$Name_matched_rank == "family" & (tnrs.tpl$Taxonomic_status == "Accepted" | tnrs.tpl$Taxonomic_status == "Synonym") & tnrs.tpl$Family_score > 0.88), 1]
length(index.family)

# 2. repeat selection for Name_matched_rank "forma" "genus" "infraspecies" ... change selection "score", e.g. lower (strong) threshold for species, higher (or no) threshold for infraspec., variety, ... (identify threshold by looking at the excel-table)
# create respective index
# 
# 14.00-15.00
index.forma <- tnrs.tpl[which(tnrs.tpl$Name_matched_rank == "forma"), 1]
length(index.forma)

###############
## continue here:
###############

index.genus <- tnrs.tpl[which(tnrs.tpl$Name_matched_rank == "genus" & tnrs.tpl$Taxonomic_status == "Accepted" & tnrs.tpl$Genus_score > 0.83), 1]
length(index.genus)

# Genus: Problem: the following stuff is cut down to genus-level
# Andropogon sp. [capillipes + glaucopsis + glomeratus]
# Antennaria angustata/glabrata
# Aragoa perez.arbelaeziana
# Capsella bursa.pastoris
# !! possible solution: removing ".", "/", "[]" (! do this after index based on all sources is created)

index.infraspec <- tnrs.tpl[which(tnrs.tpl$Name_matched_rank == "infraspecies"), 1]
length(index.infraspec)

index.species <- tnrs.tpl[which(tnrs.tpl$Name_matched_rank == "species" & (tnrs.tpl$Taxonomic_status == "Accepted" | tnrs.tpl$Taxonomic_status == "Synonym") & tnrs.tpl$Genus_score > 0.78 & tnrs.tpl$Name_score > 0.93), 1]
length(index.species1)

index.species <- tnrs.tpl[which(tnrs.tpl$Name_matched_rank == "species" & (tnrs.tpl$Taxonomic_status == "Accepted" | tnrs.tpl$Taxonomic_status == "Synonym") & tnrs.tpl$Specific_epithet_score > 0.78), 1]
length(index.species2)

index.species <- unique(c(index.species1, index.species2))
length(index.species)

index.subspec <- tnrs.tpl[which(tnrs.tpl$Name_matched_rank == "subspecies" & (tnrs.tpl$Taxonomic_status == "Accepted" | tnrs.tpl$Taxonomic_status == "Synonym")), 1]
length(index.subspec)

index.variety <- tnrs.tpl[which(tnrs.tpl$Name_matched_rank == "variety" & (tnrs.tpl$Taxonomic_status == "Accepted" | tnrs.tpl$Taxonomic_status == "Synonym")), 1]
length(index.variety)

# additional step: identifying "non-matched" species that are spermatophyta
index.spermatophyt <- tnrs.tpl[which(tnrs.tpl$Name_matched == "No suitable matches found." & word(tnrs.tpl$Name_submitted, 1) == "Spermatophyta"), 1]
length(index.spermatophyt)

# !! later on: resolve 


# 3. identify those species that do not fulfill the search criteria
# 15.00-15.15
index.tpl <- c(index.family, index.forma, index.genus, index.species, index.subspec, index.variety, index.spermatophyt)
length((index.tpl))

tnrs.tpl.certain <- tnrs.tpl[index.tpl,]
dim(tnrs.tpl.certain)
save(tnrs.tpl.certain, file = "tnrs.tpl.certain.Rdata")
write.csv(tnrs.tpl.certain, file = "tnrs.tpl.certain.csv")

tnrs.tpl.uncertain <- tnrs.tpl[tnrs.tpl$Name_number %in% index.tpl == F, ]
dim(tnrs.tpl.uncertain)
save(tnrs.tpl.uncertain, file = "tnrs.tpl.uncertain.Rdata")
write.csv(tnrs.tpl.uncertain, file = "tnrs.tpl.uncertain.csv")

write.csv(tnrs.tpl.uncertain[,2], file = "tnrs.tpl.uncertain.upload.csv")

### continue here: Thursday 20th Oct

tnrs.trop <- read.csv("/home/oliver/Downloads/tnrs.trop.txt", sep = "\t")
str(tnrs.trop)

#######

# 4. take table from 3. repeat steps 1.-3. for "tnrs.all" "and tnrs.trop"
# 15.15-17.00
# tpl.all:
str(tnrs.trop)
tnrs.trop$Name_number <- 1:length(tnrs.trop$Name_number)
# reduce to the uncertain species from tnrs.tpl
tnrs.trop.small <- tnrs.trop[tnrs.trop$Name_number %in% index.tpl == F, ]
str(tnrs.trop.small)

save(tnrs.trop.small, file = "tnrs.trop.small.Rdata")
write.csv(tnrs.trop.small, file = "tnrs.trop.small.csv")

index.family <- tnrs.trop.small[which(tnrs.trop.small$Name_matched_rank == "family" & (tnrs.trop.small$Taxonomic_status == "Accepted"| tnrs.trop.small$Taxonomic_status == "No opinion")), 1]
length(index.family)

index.forma <- tnrs.trop.small[which(tnrs.trop.small$Name_matched_rank == "forma" & (tnrs.trop.small$Taxonomic_status == "Accepted" | tnrs.trop.small$Taxonomic_status == "Synonym")), 1]
length(index.forma)
##

index.genus <- tnrs.trop.small[which(tnrs.trop.small$Name_matched_rank == "genus" & (tnrs.trop.small$Taxonomic_status == "Accepted" | tnrs.trop.small$Taxonomic_status == "Synonym" | tnrs.trop.small$Taxonomic_status == "No opinion") & tnrs.trop.small$Genus_score > 0.83), 1]
length(index.genus)

# continue here:
index.species <- tnrs.trop.small[which(tnrs.trop.small$Name_matched_rank == "species" & (tnrs.trop.small$Taxonomic_status == "Accepted" | tnrs.trop.small$Taxonomic_status == "Synonym" | tnrs.trop.small$Taxonomic_status == "No opinion") & tnrs.trop.small$Specific_epithet_score > 0.77), 1]
length(index.species)

index.species2 <- tnrs.trop.small[which(tnrs.trop.small$Name_matched_rank == "species" & (tnrs.trop.small$Taxonomic_status == "Accepted" | tnrs.trop.small$Taxonomic_status == "Synonym") & tnrs.trop.small$Genus_score > 0.88 & tnrs.trop.small$Name_score > 0.49), 1]
length(index.species2)

index.species <- unique(c(index.species1, index.species2))
length(index.species)

index.subspec <- tnrs.trop.small[which(tnrs.trop.small$Name_matched_rank == "subspecies"), 1]
length(index.subspec)

index.subvariety <- tnrs.trop.small[which(tnrs.trop.small$Name_matched_rank == "subvariety"), 1]
length(index.subvariety)

index.variety <- tnrs.trop.small[which(tnrs.trop.small$Name_matched_rank == "variety" & tnrs.trop.small$Taxonomic_status == "No opinion"), 1]
length(index.variety)

##
index.all <- c(index.family, index.genus, index.species, index.subspec, index.variety, index.subvariety)
length((index.all))

##
tnrs.trop.small.certain <- tnrs.trop.small[tnrs.trop.small$Name_number %in% index.all == T,]
dim(tnrs.trop.small.certain)
save(tnrs.trop.small.certain, file = "tnrs.trop.small.certain.Rdata")
write.csv(tnrs.trop.small.certain, file = "tnrs.trop.small.certain.csv")

tnrs.trop.small.uncertain <- tnrs.trop.small[tnrs.trop.small$Name_number %in% index.all == F, ]
dim(tnrs.trop.small.uncertain)
save(tnrs.trop.small.uncertain, file = "tnrs.trop.small.uncertain.Rdata")
write.csv(tnrs.trop.small.uncertain, file = "tnrs.trop.small.uncertain.csv")

#### just for Oct. 2016 backbone update:

backbone.tpl.trop.certain <- rbind(tnrs.tpl.certain, tnrs.trop.small.certain)
str(backbone.tpl.trop.certain)

# kick out some columns that should not be in teh final backbone:
backbone.tpl.trop.certain.2 <- backbone.tpl.trop.certain[ ,c(1:6,12:17,25:35)]
colnames(backbone.tpl.trop.certain.2)
# add extra columns to match the old backbone:

backbone.tpl.trop.certain.2$Manual.matching <- NA
backbone.tpl.trop.certain.2$Status.correct <- NA
backbone.tpl.trop.certain.2$name.correct <- NA
backbone.tpl.trop.certain.2$rank.correct <- NA
backbone.tpl.trop.certain.2$family.correct <- NA
backbone.tpl.trop.certain.2$name.short.correct <- NA
backbone.tpl.trop.certain.2$rank.short.correct <- NA

backbone.tpl.trop.certain.2$names.sPlot.TRY <- NA
backbone.tpl.trop.certain.2$names.corr.string <- NA
backbone.tpl.trop.certain.2$sPlot.TRY <- NA

# bring names in the same order as in the old backbone:
backbone.tpl.trop.certain.3 <- backbone.tpl.trop.certain.2[,c(1,31:33,2:30)]
match(colnames(backbone.tpl.trop.certain.3), colnames(backbone.splot.try3))
identical(colnames(backbone.tpl.trop.certain.3), colnames(backbone.splot.try3)) # TRUE



# fill in emptly columns:
# Status.correct
backbone.tpl.trop.certain.3$Status.correct <- backbone.tpl.trop.certain.3$Taxonomic_status
index <- which(backbone.tpl.trop.certain.3$Name_matched == "No suitable matches found.")
backbone.tpl.trop.certain.3$Status.correct[index] <- "No suitable matches found."
# rename no.oppinion into unresolved
index <- which(backbone.tpl.trop.certain.3$Status.correct == "No opinion")
backbone.tpl.trop.certain.3$Status.correct[index] <- "Unresolved"

# name.correct (use "Accepted name", if unresolved take "Name_matched")
backbone.tpl.trop.certain.3$name.correct <- backbone.tpl.trop.certain.3$Accepted_name
index <- which(backbone.tpl.trop.certain.3$Taxonomic_status != "Accepted" | backbone.tpl.trop.certain.3$Taxonomic_status != "Synonym")
backbone.tpl.trop.certain.3$name.correct[index] <- backbone.tpl.trop.certain.3$Name_matched[index]
index <- which(backbone.tpl.trop.certain.3$Name_matched == "No suitable matches found.")
backbone.tpl.trop.certain.3$name.correct[index] <- "No suitable matches found."

# rank.correct
backbone.tpl.trop.certain.3$rank.correct <- backbone.tpl.trop.certain.3$Accepted_name_rank
index <- which(backbone.tpl.trop.certain.3$Taxonomic_status != "Accepted" | backbone.tpl.trop.certain.3$Taxonomic_status != "Synonym")
backbone.tpl.trop.certain.3$rank.correct[index] <- backbone.tpl.trop.certain.3$Name_matched_rank[index]
index <- which(backbone.tpl.trop.certain.3$Name_matched == "No suitable matches found.")
backbone.tpl.trop.certain.3$rank.correct[index] <- NA

# family.correct
backbone.tpl.trop.certain.3$family.correct <- backbone.tpl.trop.certain.3$Accepted_name_family
index <- which(backbone.tpl.trop.certain.3$Taxonomic_status != "Accepted" | backbone.tpl.trop.certain.3$Taxonomic_status != "Synonym")
backbone.tpl.trop.certain.3$family.correct[index] <- backbone.tpl.trop.certain.3$Name_matched_accepted_family[index]
index <- which(backbone.tpl.trop.certain.3$Name_matched == "No suitable matches found.")
backbone.tpl.trop.certain.3$family.correct[index] <- NA


# name.short.correct
backbone.tpl.trop.certain.3$name.short.correct <- backbone.tpl.trop.certain.3$name.correct

index <- which(backbone.tpl.trop.certain.3$rank.correct == "subspecies" | backbone.tpl.trop.certain.3$rank.correct == "variety" | backbone.tpl.trop.certain.3$rank.correct == "forma"| backbone.tpl.trop.certain.3$rank.correct == "subvariety" | backbone.tpl.trop.certain.3$Name_matched_rank == "subspecies" | backbone.tpl.trop.certain.3$Name_matched_rank == "variety")

library(stringr)
backbone.tpl.trop.certain.3$name.short.correct[index] <- word(string = backbone.tpl.trop.certain.3$name.short.correct[index], start = 1, end = 2)

# rank.short.correct
backbone.tpl.trop.certain.3$rank.short.correct <- backbone.tpl.trop.certain.3$rank.correct

index <- which(backbone.tpl.trop.certain.3$rank.correct == "subspecies" | backbone.tpl.trop.certain.3$rank.correct == "variety" | backbone.tpl.trop.certain.3$rank.correct == "forma"| backbone.tpl.trop.certain.3$rank.correct == "subvariety")

backbone.tpl.trop.certain.3$rank.short.correct[index] <- "species"

#########
# fill in the columns in trop.small.uncertain
####
tnrs.trop.small.uncertain



# kick out some columns that should not be in teh final backbone:
tnrs.trop.small.uncertain.2 <- tnrs.trop.small.uncertain[ ,c(1:6,12:17,25:35)]
colnames(tnrs.trop.small.uncertain.2)
# add extra columns to match the old backbone:

tnrs.trop.small.uncertain.2$Manual.matching <- NA
tnrs.trop.small.uncertain.2$Status.correct <- NA
tnrs.trop.small.uncertain.2$name.correct <- NA
tnrs.trop.small.uncertain.2$rank.correct <- NA
tnrs.trop.small.uncertain.2$family.correct <- NA
tnrs.trop.small.uncertain.2$name.short.correct <- NA
tnrs.trop.small.uncertain.2$rank.short.correct <- NA

tnrs.trop.small.uncertain.2$names.sPlot.TRY <- NA
tnrs.trop.small.uncertain.2$names.corr.string <- NA
tnrs.trop.small.uncertain.2$sPlot.TRY <- NA

# bring names in the same order as in the old backbone:
tnrs.trop.small.uncertain.3 <- tnrs.trop.small.uncertain.2[,c(1,31:33,2:30)]
match(colnames(tnrs.trop.small.uncertain.3), colnames(backbone.splot.try3))
identical(colnames(tnrs.trop.small.uncertain.3), colnames(backbone.splot.try3)) # TRUE

tnrs.trop.small.uncertain.3[,c(28:29)] <- "No suitable matches found."

# merge with backbone for certain species:
backbone.tpl.trop <- rbind(backbone.tpl.trop.certain.3, tnrs.trop.small.uncertain.3)
head(backbone.tpl.trop)
dim(backbone.tpl.trop)

write.csv(backbone.tpl.trop, file = "backbone.tpl.trop.csv")

backbone.tpl.trop <- read.csv("backbone.tpl.trop.csv")



## fill in remaining first three columns
backbone.tpl.trop$sPlot.TRY <- "S"
backbone.tpl.trop$Manual.matching <- "sPlot2b"

library(plyr)
miss.clean.2 <- cbind(1:length(miss.clean[,1]), as.data.frame(miss.clean))
colnames(miss.clean.2)[1] <- "Name_number"

backbone.tpl.trop <- left_join(miss.clean.2, backbone.tpl.trop, by = "Name_number")
head(backbone.tpl.trop)

colnames(backbone.tpl.trop)

backbone.tpl.trop.2 <- backbone.tpl.trop[,-c(4:6)]

colnames(backbone.tpl.trop.2)[2:3] <- c("names.sPlot.TRY", "names.corr.string")
match(colnames(backbone.tpl.trop.2), colnames(backbone.splot.try3))
identical(colnames(backbone.tpl.trop.2), colnames(backbone.splot.try3))

write.csv(backbone.tpl.trop.2, file = "backbone.tpl.trop.2.csv")
save(backbone.tpl.trop.2, file = "backbone.tpl.trop.2.Rdata")

# merge with the big old backbone:
backbone.splot2b.try3 <- rbind(backbone.splot.try3, backbone.tpl.trop.2)
dim(backbone.splot2b.try3)

## see whether the new backbone matches the sPlot2b species data
str(splot.species)

length(unique(splot.species$Matched_concept))

which(unique(splot.species$Matched_concept) %in% backbone.splot2b.try3$names.sPlot.TRY == F)


backbone.splot2.1.try3 <- backbone.splot2b.try3
write.csv(backbone.splot2.1.try3, file = "backbone.splot2.1.try3.csv")
save(backbone.splot2.1.try3, file = "backbone.splot2.1.try3.Rdata")


#
##### tag vascular species in backbone.splot2.1.try3
load("backbone.splot2.1.try3.is.vascular.Rdata")
colnames(backbone.splot2.1.try3)

library(rgbif)

# get families:
unique(backbone.splot2.1.try3$family.correct)

fam <- unique(backbone.splot2.1.try3$family.correct)

gbiffam <- sapply(fam[2:5], function(x) name_usage(name=x, rank = 'FAMILY,', limit = 1)$data$phylum)


gbiffam[which(sapply(gbiffam, function(x) is.null(x)))] <- 'unknown'

fam$phylum <- unlist(gbiffam, use.names = TRUE)
table(fam$phylum)
write.csv(fam, file='family_affiliation_gbif.csv')

family_affiliation_gbif <- read.csv('Florian_TaxStand/family_affiliation_gbif.csv')
table(family_affiliation_gbif$phylum)

# add column "is.vascular.species" and set all families that correspond to Tracheophyta (vascular plants == TRUE)

table(is.na(backbone.splot2.1.try3$is.vascular.species))

# FALSE   TRUE 
# 123589   7013 

# identify families that belong to trachiophyta:
fam.trach <- family_affiliation_gbif$Var1[family_affiliation_gbif$phylum == "Tracheophyta"]
dim(fam.trach)


ind.vasc <- backbone.splot2.1.try3$family.correct %in% fam.trach
backbone.splot2.1.try3$is.vascular.species <- ind.vasc

backbone.splot2.1.try3$is.vascular.species[backbone.splot2.1.try3$is.vascular.species==FALSE] <- NA

# backbone.splot2.1.try3.is.vascular <- backbone.splot2.1.try3

# to get proper stats for sPlot2.1, kick out (or tag) the species  
## to get the species list 
splot.species.july2015 <- read.csv("/home/oliver/Dokumente/PhD/PostPhD/IDiv/sDiv/sPlot/Analyses/Data/Species/sPlot/sPlot_2015_07_29/sPlot_2015_07_29_species.csv", sep = "\t") # note, "sPlot_14_4_2015_species" no longer exists, but will be used for documentation purposes here
gc()

splot.species.july2015.spec <- as.character(unique(splot.species.july2015$Matched.concept))
str(splot.species.july2015.spec)
write.csv(splot.species.july2015.spec, file = "splot.species.july2015.spec.csv")

# 86432 unique (uncorrected names in sPlot2.1)
# are those species all in the new backbone?
load("backbone.splot2.1.try3.is.vascular.Rdata")
# export small backbone:
backbone.splot2.1.try3.small <- backbone.splot2.1.try3[,c(2,32)]
write.csv(backbone.splot2.1.try3.small, file = "backbone.splot2.1.try3.small.csv")


load("backbone.splot2.1.try3.Rdata")

ind <- (splot.species.july2015.spec %in% backbone.splot2.1.try3$names.sPlot.TRY)

splot.species.july2015.spec[ind==F]
table(ind)
# 86427 (5 species are missing)

# the following species are in sPlot2.1 (splot.species.july2015.spec) but not in the backbone (backbone.splot2.1.try)
[1] "Strauch like Oraniquelocarpus" "Buchenavia [GUNDINGA]"        
[3] "[ms554 Triumfetta Ahorn]"      "Dolichos holosericea"         
[5] "[Aeschynomene latifolia]"
# actually there are but just spelled differently, e.g. Strauch like ""Oraniquelocarpus"" or [ms554 Triumfetta "Ahorn"]
# probably there names got messed up, generate a vector of that 5 species that is consistent with the spelling used Helge's missing species list and in the final backbone:

miss7701 <- read.csv("/home/oliver/Dokumente/PhD/PostPhD/IDiv/sDiv/sPlot/Analyses/Code/Mismatches_29_07_2015_new.csv", stringsAsFactors = F)
vec5 <- miss7701[c(49, 3165, 5793, 5814, 5823), 1]

# add these 5 species to our splot2.1 species list
splot.species.july2015.spec.5 <- c(splot.species.july2015.spec, vec5)

# in the big backbone, idenfify species that are in "S" and "ST" and that are in our splot2.1 species list (should be 86432)

ind <- (splot.species.july2015.spec.5 %in% backbone.splot2.1.try3$names.sPlot.TRY)

splot.species.july2015 <- splot.species.july2015.spec.5[ind]

ind <- (splot.species.july2015 %in% backbone.splot2.1.try3$names.sPlot.TRY)
table(ind)
# great, these are the species in sPlot2.1

# 1) select species in backbone that are in splot.species.july2015

# total species in splot2.1 that are both only in sPlot as well as in splot and TRY
ind.splot2.1 <- which(backbone.splot2.1.try3$names.sPlot.TRY %in% splot.species.july2015)
# 86432

# total species in TRY, that are both only in TRY as well as in splot and TRY
# 2) select species in backbone that are in TRY
ind.try <- which(backbone.splot2.1.try3$sPlot.TRY=="T" | backbone.splot2.1.try3$sPlot.TRY=="ST")
# 60273

intersect_all <- function(a,b,...){
  Reduce(intersect, list(a,b,...))
}

inter <- intersect_all(ind.splot2.1, ind.try)
# 24844 shared between splot and try

# check whether the three numbers above are correct .. append to columns to backbone (S and T)

backbone.splot2.1.try3$ST <- NA

backbone.splot2.1.try3$ST[ind.splot2.1] <- "S"
backbone.splot2.1.try3$ST[ind.try] <- "T"
backbone.splot2.1.try3$ST[inter] <- "ST"
colnames(backbone.splot2.1.try3)[35] <- "sPlot2.1.TRY"

save(backbone.splot2.1.try3, file = "backbone.splot2.1.try3.is.vascular.Rdata")

####################
#### finished 
####################




## continue here on Monday 15th May, with the remaing steps, incl. manual cleaning, corrections of the weird species names list and the remaining steps.

# the other rough steps:

# additional fuzzy steps:
# i) correct weird names list
# ii) some manual matching of the unresolved names
# (iii) still some final matching against the plant list)
# for final backbone exclude those species that are not in sPlot 2.1, or leave them in the backbone, but just do not include them into the stats
# iV) identifying vascular species

  

#################################
######## 
# sPlot 2.0 - TRY 3.0 for workshop sPlot III WS (stop at 13.00)
####################################################
####################################################

# 10.30 -11.30 (without biomes) for gapfilled and the 18 Shan traits, all, most common, most dominant species
# import reduced splot.species (the one without "no suitable matches found" in names.short.correct)
load("/home/oliver/Dokumente/PhD/PostPhD/IDiv/sDiv/sPlot/Analyses/Data/sPlotWSIII/DT2small.Rdata")
gc(DT2small)
str(DT2small)

# unique resolved species in sPlot2.1:
length(unique(DT2small$species)) # 61131 unique resolved species in splot
names.splot <- unique(DT2small$species)


# unique resolved species in TRY
# get TRY gapfilled
try3gapfilled <- read.csv("/home/oliver/Dokumente/PhD/PostPhD/IDiv/sDiv/sPlot/Analyses/Data/Traits/TRY_3.0_gapfilled/Export_sPlot_2016_09_12.csv", stringsAsFactors = F)
dim(try3gapfilled)
str(try3gapfilled)

# match with backbone
index2 <- match(try3gapfilled$Species, backbone.splot2.1.try3$names.sPlot.TRY)
str(index2)
try3gapfilled$name.short.correct <- backbone.splot2.1.try3$name.short.correct[index2]
str(try3gapfilled)
try3gapfilled[100:200, c(22,34)]
names.try <- unique(try3gapfilled$name.short.correct)
length(names.try) # 52033 (unique resolved species in TRY)
length(unique(try3gapfilled$Species))  # 59319 (unique but partly unresolved species in TRY)
# means that 12.3% of the gapfilled species in TRY3.0 are Synonyms (or to a small extent species where no suitable name matches were found)

# how many species in splot are try.gapfilled
100*(length(
    names.splot
    [which(names.splot
           %in% 
           names.try)])/
     length(names.splot))

# gapfilled: 43.62598 of the species are covered by traits in TRY

# load non-gap-filled trait data from TRY:
## !!! to do: use TRY3 original data for all 18 instead just the 16 traits
try.orig <- read.csv("/home/oliver/Dokumente/PhD/PostPhD/IDiv/sDiv/sPlot/Analyses/Data/Traits/TRY_3.0_OrigData_18Traits/GapFilling2015_01_31_OrigData_cleaned_corrected_18TraitsSelected.csv",stringsAsFactors = F)
str(try.orig)
length(unique(try.orig$Species))
colnames(try.orig)

index2 <- match(try.orig$Species, backbone.splot2.1.try3$names.sPlot.TRY)
str(index2)
try.orig$name.short.correct <- backbone.splot2.1.try3$name.short.correct[index2]
str(try.orig)

# which identify unique resolved species that have original (measured) trait values in TRY3
head(try.orig[,16:31]) 

match.stat <- numeric(16)
names(match.stat) <- colnames(try.orig[,16:31])

names(match.stat) <- c("LeafArea.mean", "StemDens.mean", "SLA.mean", "LeafC.perdrymass.mean",
                           "LeafN.mean","LeafP.mean", "PlantHeight.mean", "SeedMass.mean", "Seed.length.mean",
                           "LDMC.mean","LeafNperArea.mean", "LeafNPratio.mean", "Leaf.delta.15N.mean", 
                           "Seed.num.rep.unit.mean", "Leaffreshmass.mean", "Stem.cond.dens.mean", 
                           "Disp.unit.leng.mean", "Wood.vessel.length.mean")

match.fun <- function(spec.nam) {
    for (i in 1:16){
        index3 <- which(is.na(try.orig[,i+15])==F)
        names.try.single <- unique(try.orig$name.short.correct[index3])
        match.stat[i] <- 100*(length(
            spec.nam
            [which(spec.nam
                   %in% 
                   names.try.single)])/
            length(spec.nam))
    }
    match.stat
}

match.res <- match.fun(spec.nam = names.splot)
match.res

# go on with the most frequent and most dominant species:
library(dplyr)
library(plyr)
colnames(DT2small)
spec.group <- group_by(DT2small, species)
spec.agg <- summarise(spec.group, count.spec = n(), Avg_Cover_Perc = mean(Relative.cover))
dim(spec.agg) # for all of the 61131 (58114 previously) corrected, unique species, frequency and dominance has been calculated
summary(spec.agg)

spec.agg[spec.agg$Avg_Cover_Perc > .99,]
spec.agg[spec.agg$count.spec > 100000, ]
spec.agg.splot2.vasc <- spec.agg

## calculate stats for i) the most frequent and ii) most dominant species:
spec.agg.splot2.vasc <- spec.agg
names(spec.agg.splot2.vasc)

fac1 <- cut(as.numeric(spec.agg.splot2.vasc$count.spec), quantile(spec.agg.splot2.vasc$count.spec,(0:4)/4),labels=c("Low","Medium","High","Highest"))

quantile(spec.agg.splot2.vasc$count.spec,(0:4)/4)

"    0%    25%    50%    75%   100% 
     1      3     13     56 128942 "

fac2 <- cut(as.numeric(spec.agg.splot2.vasc$Avg_Cover_Perc), quantile(spec.agg.splot2.vasc$Avg_Cover_Perc,(0:4)/4),labels=c("Low","Medium","High","Highest"))

quantile(spec.agg.splot2.vasc$Avg_Cover_Perc,(0:4)/4)
"          0%          25%          50%          75%         100% 
2.099379e-06 9.698998e-03 1.953731e-02 3.965419e-02 1.000000e+00 "

spec.agg.splot2.vasc$count.fac <- fac1
spec.agg.splot2.vasc$cover.fac <- fac2

count.high <- spec.agg.splot2.vasc[which(spec.agg.splot2.vasc[,4]=="Highest"),]

cover.high <- spec.agg.splot2.vasc[which(spec.agg.splot2.vasc[,5]=="Highest"),]


100*(length(
    count.high$species
    [which(count.high$species
           %in% 
           names.try)])/
     length(count.high$species))

# cover.high: gap.filled
# 51.84846 % (15,283 most dominant species with 0.039654 - 1 relative cover)

# count.high: gap.filled
# 67.45457 % (15,188 most frequent species with 56 - 128942 occurrences)

# for original traits:

match.fun <- function(spec.nam) {
    match.stat <- numeric(16)
    names(match.stat) <- colnames(try.orig[,16:31])
    for (i in 1:16){
        index3 <- which(is.na(try.orig[,i+15])==F)
        names.try.single <- unique(try.orig$name.short.correct[index3])
        match.stat[i] <- 100*(length(
            spec.nam
            [which(spec.nam
                   %in% 
                   names.try.single)])/
            length(spec.nam))
    }
    match.stat
}

match.res.cover <- match.fun(spec.nam = cover.high$species)
match.res.cover

match.res.count <- match.fun(spec.nam = count.high$species)
match.res.count

# combine match results for all, dominant and frequent species:
match.comb <- as.data.frame(rbind(match.res, match.res.cover, match.res.count))
# give names:
names(match.comb) <- c("LA", "SSD", "SLA", "LeafC", "LeafN","LeafP", "Height", "SeedMass", "LDMC","LeafNArea", "LeafNP", "Leaf.d15N", "Lfreshmass", "SCondDens", "DispUL", "WoodVlen")

match.comb.sort <- match.comb[, order(match.comb[1,], decreasing = TRUE)]

rownames(match.comb.sort) <- c("All", "Most.Dominant", "Most.Frequent")

# gap.filled:
match.comb.sort$Gap.filled <- c(43.62598, 51.84846, 67.45457)
match.comb.sort <- match.comb.sort[,c(17,1:16)]
# do the plotting:
biome <- as.data.frame(t(match.comb.sort))

biome$Traits <- factor(rownames(biome), levels=c("Gap.filled", "Height", "SeedMass", "LA", "SLA", "LeafN", "SSD", "LeafNArea", "LeafP", "SCondDens", "LDMC", "LeafC", "WoodVlen", "DispUL", "LeafNP", "Leaf.d15N", "Lfreshmass"))

colnames(biome)[1:3] <- c("All", "Most.Dominant", "Most.Frequent")
mdat <- melt(biome, id.vars="Traits")
head(mdat)

library(ggplot2)


ggplot(mdat, aes(variable, value, fill=Traits)) + 
  geom_bar(stat="identity", position="dodge")+
    xlab("Species") +
  ylab("Percentage")+
  ggtitle("Match sPlot 2.1 - TRY 3.0")

ggsave("Trait.splot2.1.try3.match.cover.dominance.bmp", plot = last_plot(), device = "bmp", path = NULL, scale = 1, width = 185, height = 78, units = c("mm"), dpi = 150, limitsize = TRUE)

ggsave("Trait.splot2.1.try3.match.cover.dominance.png", plot = last_plot(), device = "png", path = NULL, scale = 1.4, width = 185, height = 82, units = c("mm"), dpi = 300, limitsize = TRUE)

# include biomes
# load coordinates with biome affiliation:
coord.biome <- read.csv("/home/oliver/Dokumente/PhD/PostPhD/IDiv/sDiv/sPlot/Analyses/Data/sPlotWSIII/splot_biomes.csv")
str(coord.biome)

# plots per biome:
plots.biome <- as.data.frame(table(coord.biome$Bio_name))
                                                       0 Alpine 
                           1139                           81858 
 1 Tropics with year-round rain      2 Tropics with summer rain 
                           8923                           13047 
   3 Dry tropics and subtropics   4 Subtropics with winter rain 
                          21336                          103990 
5 Subtrop. with year-round rain        6 Temperate midlatitudes 
                          21747                          798522 
             7 Dry midlatitudes                   8 Boreal zone 
                          48514                           18346 
      9 Polar and subpolar zone 
                           3822 

no.plots.biome <- as.data.frame(plots.biome)

colnames(no.plots.biome)[1] <- "Schulz_Bio"

mdat2 <- melt(no.plots.biome, id.vars="Schulz_Bio")
head(mdat2)

library(scales)

   ggplot(mdat2, aes(variable, value, fill=Schulz_Bio)) + 
  geom_bar(stat="identity", position="dodge")+
    xlab("Biomes") +
  ylab("log10(Number of plots)")+
      scale_y_continuous(trans = log10_trans())+ 
      #theme(panel.background = element_blank())+
      theme_bw() +
  ggtitle("Number of plots per biome")   
                                        
ggsave("Plots.per.biome.png", plot = last_plot(), device = "png", path = NULL, scale = 1, width = 155, height = 82, units = c("mm"), dpi = 300, limitsize = TRUE)

## number of species per biome:
# append biome affiliation to splot2.1 species data

index3 <- match(DT2small$PlotObservationID, coord.biome$PlotID)
str(index3)

DT2small$biome <- coord.biome$Bio_ID[index3]
str(DT2small)
table(DT2small$biome)

# calculate number of unique species per biome:
biome.group <- group_by(DT2small, biome)
biome.agg <- summarise(biome.group, no.species = length(unique(species)))
str(biome.agg)

biome.agg2 <- rbind(biome.agg[11,], biome.agg[1:10,])
colnames(biome.agg2)[1] <- "Schulz_Bio"
biome.agg2$Schulz_Bio <- no.plots.biome$Schulz_Bio

mdat3 <- melt(biome.agg2, id.vars="Schulz_Bio")
head(mdat3)

   ggplot(mdat3, aes(variable, value, fill=Schulz_Bio)) + 
  geom_bar(stat="identity", position="dodge")+
    xlab("Biomes") +
  ylab("Number of species)")+
  ggtitle("Number of species per biome")   
                                        # 
ggsave("Species.per.biome.png", plot = last_plot(), device = "png", path = NULL, scale = 1, width = 155, height = 82, units = c("mm"), dpi = 300, limitsize = TRUE)

##########
## trait match per biome
# gapfilled trait data

biome.trait.match.agg <- summarise(biome.group, 
                                   match.splot.try = 
                                       100*(length(unique(species)[which(unique(species) %in% names.try)])/length(unique(species))))
# works perfect  

# write function that loops over the 16 traits:
library(doParallel)

i <- 17

biome.trait.match.agg.sing <- foreach(i = 16:31, .combine = cbind) %do% {
    index3 <- which(is.na(try.orig[,i])==F)
    names.try.single <- unique(try.orig$name.short.correct[index3])
    x <- summarise(biome.group, 
                   match.splot.try = 100*(length(unique(species)[which(unique(species) %in% names.try.single)])/length(unique(species))))[,2]
x
}

str(biome.trait.match.agg.sing)

colnames(biome.trait.match.agg.sing) <- c("LA", "SSD", "SLA", "LeafC", "LeafN","LeafP", "Height", "SeedMass", "LDMC","LeafNArea", "LeafNP", "Leaf.d15N", "Lfreshmass", "SCondDens", "DispUL", "WoodVlen")

biome.trait.match.agg.sing2 <- cbind(biome.trait.match.agg, biome.trait.match.agg.sing)
colnames(biome.trait.match.agg.sing2)[1] <- "Schulz_Bio"
colnames(biome.trait.match.agg.sing2)[2] <- "Gap.filled"

rbind(biome.trait.match.agg.sing2[11,], biome.trait.match.agg.sing2[1:10,])
biome.trait.match.agg.sing2$Schulz_Bio <- no.plots.biome$Schulz_Bio

biome.trait.match.agg.sing3 <- biome.trait.match.agg.sing2[,order(match.comb[1,], decreasing = TRUE)+2]
biome.trait.match.agg.sing4 <- cbind(biome.trait.match.agg.sing2[,1:2], biome.trait.match.agg.sing3)

         
mdat4 <- melt(biome.trait.match.agg.sing4, id.vars="Schulz_Bio")
head(mdat4)


ggplot(mdat4, aes(Schulz_Bio, value, fill=Schulz_Bio)) + 
  geom_bar(stat="identity", position="dodge")+
    facet_wrap(~ variable, ncol = 5) +
    theme(axis.text.x=element_blank(),
          axis.ticks.x=element_blank(), 
          axis.title.x=element_blank())+
    xlab("Biomes") +
  ylab("Percentage match")+    
  ggtitle("Match TRY3-sPlot2.1 per biome")   

ggsave("Match TRY3-sPlot2.1.biome.png", plot = last_plot(), device = "png", path = NULL, scale = 1, width = 200, height = 140, units = c("mm"), dpi = 300, limitsize = TRUE)

#####
##### run temporal variability analysis:
# 22.30-23.00: load bioclim, anomaly data and link it to the plot IDs 

# calculate some fake FD-response data:
require(raster)

load("/home/oliver/Dokumente/PhD/PostPhD/IDiv/sDiv/sPlot/Analyses/Data/sPlotWSIII/FD.Rao.Rdata")
load("/home/oliver/Dokumente/PhD/PostPhD/IDiv/sDiv/sPlot/Analyses/Data/sPlotWSIII/mpd.abu.Rdata")
load("/home/oliver/Dokumente/PhD/PostPhD/IDiv/sDiv/sPlot/Analyses/Data/sPlotWSIII/mntd.pa.Rdata")

# match data with coordinates (12.15-13.00)
traits <- mpd.abu
# exclude NA values:
index <- which(is.na(mpd.abu[,1])==F)
length(index)
traits2 <- as.data.frame(traits[index,])
traits2$PlotID <- rownames(traits2)
dim(traits2) # 1,100,058 plots

# convert rownames to integers:
traits2$PlotID <- strtoi(rownames(traits2), base = 0L)

colnames(clim)[1] <- "PlotID"

# left_join everything
clim = read.csv("/home/oliver/Dokumente/PhD/PostPhD/IDiv/sDiv/sPlot/Analyses/Data/sPlotWSIII/sPlot_2015_07_29_header_clim.txt", sep = ";")
str(clim)
tail(clim[,2:3])

library(dplyr)
library(plyr)
traits.clim <- inner_join(traits2, clim)
traits.clim.biome <- inner_join(traits.clim, coord.biome)
summary(traits.clim.biome)
traits.clim.biome[, c(20,21,72,73)]
colnames(traits.clim.biome)


anomaly = raster("/home/oliver/Dokumente/PhD/PostPhD/IDiv/sDiv/sPlot/Analyses/Data/Data_Brody/LGM to Present Temperature Anomaly.tif")
plot(anomaly)


anomvals = extract(anomaly,cbind(as.numeric(traits.clim.biome$Longitude),as.numeric(traits.clim.biome$Latitude)))
plot(anomaly)
str(anomvals)

traits.clim.biome <- cbind(traits.clim.biome, anomvals)

save(traits.clim.biome, file = "traits.clim.biome.Rdata")

load("/home/oliver/Dokumente/PhD/PostPhD/IDiv/sDiv/sPlot/Analyses/Data/sPlotWSIII/traits.clim.biome.Rdata")
# exlude anomaly NAs

index <- which(is.na(traits.clim.biome$anomvals)==F)
traits.clim.biome <- traits.clim.biome[index,]

#Some plotting functions

bnames = c("Alpine", "Tropics with year-round rain","Tropics with summer rain",
	"Dry tropics and subtropics","Subtropics with winter rain",
	"Subtrop. with year-round rain","Temperate midlatitudes",
	"Dry midlatitudes","Boreal zone","Polar and subpolar zone", "")

lightenColor = function(color,percent)
	{
	v = rgb2hsv(col2rgb(color)) * c(1,0.5,1)
	return(hsv(v[1],v[2],v[3]))
	}

# x - clim$BIO_1
# y - traits$mpd.LHS.abu
# biome - xy$Schulz_Bio
# xl - "Mean temperature"
# yl - "LHS MPD (abundance-weighted)"

x <- traits.clim.biome$BIO_01
y  <- traits.clim.biome$mpd.abu.LHS
biome <-  traits.clim.biome$Name
xl <- "Mean temperature"
yl <- "LHS MPD (abundance-weighted)"


sPlotSub = function(x,y,biome,xl,yl)
	{
	colors = rainbow(12)[1:11]
	plot(x,y,col = "white",xlab = xl,ylab = yl)
	for(i in 1:length(bnames))
		{
		index = which(biome == bnames[i] & !is.na(x) & !is.na(y))
		points(x[index],y[index],col = lightenColor(colors[i],33),pch = 16,cex = 0.25)
		}
	for(i in 1:length(bnames))
		{
		index = which(biome == bnames[i] & !is.na(x) & !is.na(y))
		lines(lowess(x[index],y[index],f = 1),col = colors[i],lwd = 2)
		}
	cx = cut(x,25,labels = F)
	lines(lowess(as.numeric(by(x,cx,mean,na.rm=T)),as.numeric(by(y,cx,mean,na.rm=T)), f = 0.66),lwd = 2,col = "dark grey")
	}

sPlotSub(traits.clim.biome$BIO_01,
         traits.clim.biome$mpd.abu.LHS,
         traits.clim.biome$Name,
         "Mean temperature",
         "Plant height MPD (abundance-weighted)")

# calculate for "forest" and "non.forest"

i <- 3

index.forest <- which(traits.clim.biome$is.forest==TRUE)
index.non.forest <- which(traits.clim.biome$is.non.forest==TRUE)

traits.clim.biome.forest <- traits.clim.biome[index.forest, ]

# continue here:
traits.clim.biome.non.forest <- traits.clim.biome[index.non.forest, ]

for (i in 2:5){
bmp(paste0(colnames(traits.clim.biome.non.forest)[i], ".non.forest.bmp"), units = "in",res = 450,width = 9,height = 3.5)
par(mfrow = c(1,3))

sPlotSub(traits.clim.biome.non.forest$BIO_01, traits.clim.biome.non.forest[,i],traits.clim.biome.non.forest$Name,"Mean temperature",colnames(traits.clim.biome.non.forest)[i])

sPlotSub(traits.clim.biome.non.forest$BIO_04,traits.clim.biome.non.forest[,i],traits.clim.biome.non.forest$Name,"Temperature seasonality", colnames(traits.clim.biome.non.forest)[i])
sPlotSub(traits.clim.biome.non.forest$anomvals,traits.clim.biome.non.forest[,i],traits.clim.biome.non.forest$Name,"Temperature anomaly",colnames(traits.clim.biome.non.forest)[i])
dev.off()
}

pdf("caption.pdf")
plot(1,col = "white")
legend(0.6,1.2,pch = 16,legend = bnames, col = rainbow(12)[2:10])
legend(1.1,1.2,pch = 16,legend = c("Alpine", "Tropics (wet)","Tropics (summer rain)","Sub/tropics (dry)", "Subtropics (winter rain)","Subtropics (wet)","Temperate midlat.","Dry midlat.","Boreal","Sub/polar", " "), col = rainbow(12)[1:11])
dev.off()

###############################
### Phylogeny for sPlot 2.1 ###
###############################

# 1) identify species in splot that are not in the tank tree:
# load taxonomic backbone

load("backbone.splot2.1.try3.Rdata")
dim(backbone.splot2.1.try3)

splot.try.nam <- unique(backbone.splot2.1.try3$name.short.correct)

head(splot.try.nam)
splot.try.nam[10:100]

# select species in splot
splot.nam <- backbone.splot2.1.try3[backbone.splot2.1.try3$sPlot.TRY != "T",c(4,32)]
table(splot.nam$sPlot.TRY)
head(splot.nam)

splot.nam.2 <- unique(splot.nam$name.short.correct)

any(is.na(splot.nam.2))

na.ind <- which(is.na(splot.nam.2))
splot.nam.3 <- splot.nam.2[-na.ind]
any(is.na(splot.nam.3))
# 61214 unique resolved species in splot 2.1

splot.nam.4 <- gsub(" ", "_", splot.nam.3)

#### which species in splot are not in the tank tree:

library(ape)
tank.tree <- read.tree("/home/oliver/Dokumente/PhD/PostPhD/IDiv/sDiv/sPlot/Analyses/Data/Phylogeny/2/PhylogeneticResources/Vascular_Plants_rooted.dated.tre")

ind.miss <- splot.nam.4 %in% tank.tree$tip.label 

table(ind.miss)
"ind.miss
FALSE  TRUE 
45784 15430 "

# only 25% of the species in splot are in the tank tree

# before run "addCongeners" inspect missing species to see whether there are obvious species that should be there

splot.nam.miss <- splot.nam.4[ind.miss==F]

write.csv(sort(splot.nam.miss), file = "splot.nam.miss.csv")

## run "addCongeners" on Rstudio2 
# takes 4.5 hours to add the missing 45784 species
# 7247 species could not be added (11.8% of all resolved taxa in sPlot) -> we have a phylogeny for 53967 of the 61214 standardized taxa in sPlot 2.1 (anyway, lichens, mosses and some weird stuff are still included here)

splot2.1.tank.tree.70287 <- read.tree("splot2.1.tank.tree.70287.tre")

ind.miss.2 <- splot.nam.miss %in% splot2.1.tank.tree.70287$tip.label 
splot.nam.miss.2 <- splot.nam.miss[ind.miss.2==F]
write.csv(sort(splot.nam.miss.2), file = "splot.nam.miss.2.csv")

### how may splot species are missing in the qian phyto-phylo tree?:

phyto.phylo.tree <- read.tree("/home/oliver/Dokumente/PhD/PostPhD/IDiv/sDiv/sPlot/Analyses/Data/Phylogeny/Qian_PhytoPhylo/AppendixS5/PhytoPhylo.tre")


ind.miss <- splot.nam.4 %in% phyto.phylo.tree$tip.label 

table(ind.miss)
"FALSE  TRUE 
45093 16121 "
# 16121 of the resolved species in sPlot 2.1 are in the Qian-corrected Tank.tree.

splot.nam.miss.phyto.phylo <- splot.nam.4[ind.miss==F]

phyto.phylo.splot2.1.69335 <- read.tree("/home/oliver/Dokumente/PhD/PostPhD/IDiv/sDiv/sPlot/Analyses/Data/Phylogeny/sPlot2.1Phylo/phyto.phylo.splot2.1.69335.tre")

pdf("phyto.phylo.tree.splot.69335.pdf", height = 150, width = 150)
plot(phyto.phylo.splot2.1.69335, "f", cex = .1)
dev.off()

ind.miss.3 <- splot.nam.miss.phyto.phylo %in% phyto.phylo.splot2.1.69335$tip.label 
table(ind.miss.3)

splot.nam.miss.3 <- splot.nam.miss.phyto.phylo[ind.miss.3==F]
write.csv(sort(splot.nam.miss.3), file = "splot.nam.miss.3.csv")

# prune to splot2.1 data

pruned.tree <- drop.tip(phyto.phylo.splot2.1.69335, setdiff(phyto.phylo.splot2.1.69335$tip.label, splot.nam.4))

phyto.phylo.splot2.1.54067 <- pruned.tree

write.tree(phyto.phylo.splot2.1.54067, file = "phyto.phylo.splot2.1.54067.tre")

phyto.phylo.splot2.1.54067 <- read.tree("phyto.phylo.splot2.1.54067.tre")

# 16121/54067
# of the 54067 species that are now in the sPlot2.1 tree, ~30% of them are were actually found in the Qian-corrected Tank tree, the remainder was added as congeners

# should contain 54067 species

pdf("phyto.phylo.tree.splot.54067.pdf", height = 220, width = 220)
plot(phyto.phylo.splot2.1.54067, "f", edge.width = .4, label.offset = .03, cex = .1)
dev.off()

png("phyto.phylo.tree.splot.54067.png", height = 10000, width = 10000, pointsize = 1, res = 4000)
plot(phyto.phylo.splot2.1.54067, "f", edge.width = .1, label.offset = .03, cex = .1)
dev.off()

#############################
#### generate tree for maddy
spec.bac <- read.csv("/home/oliver/Dokumente/PhD/PostPhD/Projects/Maddy/SpeciesList_plants_BAC.csv", stringsAsFactors=F)
spec.bac[-1,]
nam <- apply(spec.bac, 1, FUN = .simpleCap)

ind <- nam %in% phyto.phylo.splot2.1.69335$tip.label

tpl.get(c("Agropyron smithii", "Petalostemum villosum", "Petalostemum purpureum"))
#  Elymus smithii, Dalea villosa, Dalea purpurea

# finish stuff for maddy:

nam <- c("Achillea_millefolium" ,   "Elymus_smithii"   ,   
 "Amorpha_canescens"    ,   "Dalea_villosa"  ,
 "Andropogon_gerardii"  ,   "Asclepias_tuberosa"     ,
 "Elymus_canadensis"   ,    "Koeleria_macrantha"    , 
  "Lespedeza_capitata"  ,    "Liatris_aspera"       ,  
 "Lupinus_perennis"      ,  "Monarda_fistulosa"     , 
 "Solidago_rigida"        , "Panicum_virgatum"      , 
 "Dalea_purpurea"  ,"Poa_pratensis"         , 
 "Quercus_ellipsoidalis"   ,"Quercus_macrocarpa"    , 
 "Schizachyrium_scoparium" ,"Sorghastrum_nutans"  )

tree.new <- addCongeners(phyto.phylo.splot2.1.69335, "Dalea_villosa")

pruned.tree <- drop.tip(tree.new, setdiff(tree.new$tip.label, nam))

write.tree(pruned.tree, file = "BAC.plant.phylo.20.tre")

library(ape)
BAC.plant.phylo.20 <- read.tree("BAC.plant.phylo.20.tre")
plot(BAC.plant.phylo.20)

pd(samp, tree, include.root = FALSE)
# if you set "include.root = TRUE", you can calculate pd also for monoculatures. if you dont need monoculture pd then set it to FALSE
mpd(samp, cophenetic(tree), abundance.weighted = TRUE)
# ....

#####
#############

### test alternative taxon-grafting methods according to Qian:

# what are the 3 methods doing?
# 

# load function: "S.PhyloMaker"
source("/home/oliver/Dokumente/PhD/PostPhD/IDiv/sDiv/sPlot/Analyses/Data/Phylogeny/Qian_PhytoPhylo/AppendixS5/R_codes for function S.PhyloMaker.R")
library(phytools)

example<-read.csv("/home/oliver/Dokumente/PhD/PostPhD/IDiv/sDiv/sPlot/Analyses/Data/Phylogeny/Qian_PhytoPhylo/AppendixS5/example.splist.csv",header=T)       # read in the example species list.
phylo<-read.tree("/home/oliver/Dokumente/PhD/PostPhD/IDiv/sDiv/sPlot/Analyses/Data/Phylogeny/Qian_PhytoPhylo/AppendixS5/PhytoPhylo.tre")      # read in the megaphylogeny.
nodes<-read.csv("/home/oliver/Dokumente/PhD/PostPhD/IDiv/sDiv/sPlot/Analyses/Data/Phylogeny/Qian_PhytoPhylo/AppendixS5/nodes.csv",header=T)     # read in the nodes information of the megaphylogeny.


result<-S.PhyloMaker(splist=example, tree=phylo, nodes=nodes)      # run the function S.PhyloMaker.
# !!!! takes already  ~5 min for 33 to match 

write.csv(result$Species.list, file = "result$Species.list.csv")

# test, whether is also runs without the "case" column

system.time(
result.2<-S.PhyloMaker(splist=example[10:13,1:3], tree=phylo, nodes=nodes) 
)
# yes, it works
# calculation time for species 10:13 and all three scenarios:
# 56.612

# scen.1
system.time(
result.3<-S.PhyloMaker(splist=example[1:10,1:3], tree=phylo, nodes=nodes, scenarios = "S1") 
)
# 18.759

# scen.2
system.time(
result.4<-S.PhyloMaker(splist=example[10:13,1:3], tree=phylo, nodes=nodes, scenarios = "S2") 
)
# 18.497

# scen.3
system.time(
result.4<-S.PhyloMaker(splist=example[10:13,1:3], tree=phylo, nodes=nodes, scenarios = "S3") 
)
# 18.859

# matching ~40,000 missing species would take ~35h for each scenario -> run each scenario on separate core in Rstudio server

# run addCongers on the 35 species expample list from qian and add it to the plot:
library(geiger)
addCongeners.35.2 <- addCongeners(phylo, as.character(example$species))
# prune it to the 35 species list:
pruned.tree.35.2 <- drop.tip(addCongeners.35.2, setdiff(addCongeners.35.2$tip.label, example$species))


pdf("phyto.phylo.test.35.2.2.pdf", height = 12, width = 12)
str(result)       # the structure of the ouput of S.PhyloMaker.
par(mfrow=c(1,5),mar=c(0,0,1,0))       # show the phylogenies of the three scenarios.
plot(result$Scenario.1,cex=1.1,main="Scenarion One")
plot(result$Scenario.2,cex=1.1,main="Scenarion Two")
plot(result$Scenario.3,cex=1.1,main="Scenarion Three")
plot(pruned.tree.35,cex=1.1,main="Add Congeners Brody")
plot(pruned.tree.35.2,cex=1.1,main="Add Congeners Brody 2")
dev.off()

# add.congeners seems to be more reliable, so go for that
# to do: generate distribution of 1000 trees to get an unbiased mean across 1000 realizations of phylogenetic diversity


## next steps (if necessary): 
# check how many of species in the splot species list are mosses, lichens etc. and thus can be excluded from the species list
# which species in phyto-phylo correspond to "matched names" in backbone -> substitute them with "name.correct" in backbone
# use alternative grafting algorithms from Qian 2016, but need to prepare the table with family, genus, species information first.; + first check how their grafting works with the small example species list in Qian



################################################
################################################


######################################################
#Takes a tree and species list, each containing "Genus_species"
#formatted names. For each species in the list, if it has a congener
#on the tree but is not itself on the tree, add it next to a 
#randomly selected congener at a random position along the edge
#returns a larger tree

# Written by Brody, Dec 2, 2014

addCongeners = function(tree,speciesToAdd)
  {
	resample <- function(x, ...) x[sample.int(length(x), ...)]
	staGenus = unlist(lapply(strsplit(speciesToAdd,"_"),function(i){i[[1]]}))
	gtree = tree
	for(i in sample(1:length(speciesToAdd),length(speciesToAdd),replace = F))
		{	


		gtreeGenera = unlist(lapply(strsplit(gtree$tip,"_"),function(i){i[[1]]}))
		
		#If the species isn't on the tree but a congener is
		if(!speciesToAdd[i] %in% tree$tip.label & staGenus[i] %in% gtreeGenera)
			{
			branchName = gtree$tip[resample(which(gtreeGenera == staGenus[i]),1)]
			newtree = sim.bdtree(n=2)
			newtree$tip.label = c(branchName,speciesToAdd[i])

			edgeL = gtree$edge.length[which.edge(gtree,branchName)]

			#Splice in at a random depth between 0 and 1
			depth = runif(1,0,1)
			newtree$edge.length = depth*newtree$edge.length*edgeL/max(newtree$edge.length)

			whereToGraft = which(gtree$tip == branchName)
			gtree = bind.tree(gtree,newtree,where = whereToGraft,position = edgeL*depth)

			#The grafting process duplicates the branchName tip. Drop one of them.
			gtree = drop.tip(gtree, which(gtree$tip == branchName)[1])
			}
		}
	return(gtree)
	}

tank.tree.splot <- addCongeners(tank.tree, splot.nam.miss[100])

tank.tree
# 31749 tips

pdf("tank.tree.splot.test.pdf", height = 250, width = 250)
plot(tank.tree.splot, "f", cex = .1)
dev.off()

## idea: color added species in the final tree (or even better, map binary classification, whether species was present or absent in the phylogeny using trait.plot in the "diversitree" R-packages)
# http://www.zoology.ubc.ca/~fitzjohn/diversitree.docs/trait.plot.html

# similarity, map biome affiliation on the tree (as well species occurrence across realms within biome (to see diversification gradients from old to new world))

# plot families, instead of species names, on the tree 

# collapsing species within families and plot as triangles:
# http://stackoverflow.com/questions/34403957/how-to-collapse-branches-in-a-phylogenetic-tree-by-the-label-in-their-nodes-or-l

# 2-4 pm draft first presentation
# 4-6 draft second presentation


###################################################
# script from TNRS page to resolve names from R:
library(ape)

library(rjson)	
library(RCurl) 

tnrs.api<-'http://tnrs.iplantc.org/tnrsm-svc'

#Tree topology from Ackerly, D. 2009. Conservatism and diversification of plant functional traits: Evolutionary rates versus phylogenetic signal. PNAS 106:19699--19706.

lobelioids.string<-'((((((Lobelia_kauaensis,Lobelia_villosa),Lobelia_gloria-montis),(Trematolobelia_kauaiensis,Trematolobelia_macrostachys)),((Lobelia_hypoleuca,Lobelia_yuccoides),Lobelia_niihauensis)),((Brighamia_insignis,Brighamia_rockii),(Delissea_rhytidosperma,Delissea_subcordata))),((((Cyanea_pilosa,Cyanea_acuminata),Cyanea_hirtella),(Cyanea_coriacea,Cyanea_leptostegia)),(((Clermontia_kakeana,Clermontia_parviflora),Clermontia_arborescens),Clermontia_fauriei)));'

#Transform the newick sting into an ape phylo object
tree<-read.tree(text=lobelioids.string)

#Obtain the taxa names
old.names<-tree$tip.label

#Change the underscore characters into blank spaces
old.names<-gsub('_',' ',old.names)

#Transporms the vector into a string
old.names <- TNRS.TPL.2$TNRS.Name_submitted[11000:11110]
old.names<-paste(old.names,collapse=',')
old.names
#The string needs to be URL-encoded
old.names<-curlEscape(old.names)

#Send a request to the TNRS service
url<-paste(tnrs.api,'/matchNames?retrieve=all&names=',old.names,sep='')
tnrs.json<-getURL(url) 

#The response needs to be converted from JSON
tnrs.results<-fromJSON(tnrs.json)

#The corrected names are extracted from the response
names<-sapply(tnrs.results[[1]], function(x) c(x$nameSubmitted,x$acceptedName,x$url))
names<-as.data.frame(t(names),stringsAsFactors=FALSE)
names

#If TNRS did not return any accepted name (no match, or name is already accepted), the submitted name is retained
names[names[,2]=="",2]<-names[names[,2]=="",1] 

#The old taxa names are replaced with the corrected taxa names
tree$tip.label<-names[,2]

plot(tree)

###################################################


## other stuff
## combinations test for Öland review

x <- foreach(i = 1:length(seq1), .combine = rbind) %dopar% {
  taxize::tnrs(query = CleanedNames[seq1[i]:seq2[i]], source = "iPlant_TNRS")
}

library(gtools)
library(foreach)

x <- foreach(i = 1:6, .combine = sum)%dopar% {
    dim(gtools::combinations(6,i,v=c("AMF", "C", "Grazing", "N", "P", "PlantDiv")))[1]
    }

x <- foreach(i = 1:6, .combine = list) %dopar% {
    cbind("Age", combinations(6, i ,v=c("AMF", "C", "Grazing", "N", "P", "PlantDiv")))
}





##############################


## Phylogeny Simone
spec.simone <- read.csv("/home/oliver/Dokumente/PhD/PostPhD/Projects/Simone/wehpo.csv", head = F)
library(ape)
tank.tree.simone <- read.tree("/home/oliver/Dokumente/PhD/PostPhD/Projects/Simone/tank.tree.simone.tre")

str(spec.simone) 

spec.simone[,1] <- as.character(spec.simone[,1])

spec.simone[,1] <- gsub(" ", "_", spec.simone[,1])

spec.simone[,1][which(spec.simone[,1] %in% tank.tree.simone$tip.label == F)]


missing <- spec.simone[,1][which(spec.simone[,1] %in% tank.tree.simone$tip.label == F)]
write.csv(missing, file = "missing.csv")
as.data.frame(missing)

# substitute some names in the tank.tree.simone to match simones list 
# simone <- tank.tree.name

tank.tree.simone$tip.label[tank.tree.simone$tip.label=="Elaeocarpus_decipiens"] <- "Elaeocarpus_glabripetalus"
tank.tree.simone$tip.label[tank.tree.simone$tip.label=="Manglietia_fordiana"] <- "Magnolia_yuyuanensis"
tank.tree.simone$tip.label[tank.tree.simone$tip.label=="Triadica_sebifera"] <- "Sapium_sebiferum"
tank.tree.simone$tip.label[tank.tree.simone$tip.label=="Dalbergia_nigra"] <- "Dalbergia_retusa"

Elaeocarpus glabripetalus <- Elaeocarpus_decipiens # done 
# continue here:
Magnolia yuyuanensis <- Manglietia_fordiana
Sapium sebiferum  <- Triadica_sebifera
Dalbergia retusa <- Dalbergia_nigra

# add the rest to the global tank.tree as congeners using Brody's code
Celtis biondii
Elaeocarpus chinensis
Phoebe bournei
Quercus fabrei
Quercus phillyreoides
Sapindus mukorossi
Dipterocarpus conformis
Hopea sangal
Albizia adinocephala
Colubrina glandulosa
Albizia saman
Parashorea malaanonan (only one sister taxa in tank tree: Parashorea_lucida)
Parashorea tomentella (only one sister taxa in tank tree: Parashorea_lucida)

# create names vector and add to tank.tree

###################
library(ape)
library(geiger)

######################################################
#Takes a tree and species list, each containing "Genus_species"
#formatted names. For each species in the list, if it has a congener
#on the tree but is not itself on the tree, add it next to a 
#randomly selected congener at a random position along the edge
#returns a larger tree

# Written by Brody, Dec 2, 2014

addCongeners = function(tree,speciesToAdd)
  {
	resample <- function(x, ...) x[sample.int(length(x), ...)]
	staGenus = unlist(lapply(strsplit(speciesToAdd,"_"),function(i){i[[1]]}))
	gtree = tree
	for(i in sample(1:length(speciesToAdd),length(speciesToAdd),replace = F))
		{	

		gtreeGenera = unlist(lapply(strsplit(gtree$tip,"_"),function(i){i[[1]]}))
		
		#If the species isn't on the tree but a congener is
		if(!speciesToAdd[i] %in% tree$tip.label & staGenus[i] %in% gtreeGenera)
			{
			branchName = gtree$tip[resample(which(gtreeGenera == staGenus[i]),1)]
			newtree = sim.bdtree(n=2)
			newtree$tip.label = c(branchName,speciesToAdd[i])

			edgeL = gtree$edge.length[which.edge(gtree,branchName)]

			#Splice in at a random depth between 0 and 1
			depth = runif(1,0,1)
			newtree$edge.length = depth*newtree$edge.length*edgeL/max(newtree$edge.length)

			whereToGraft = which(gtree$tip == branchName)
			gtree = bind.tree(gtree,newtree,where = whereToGraft,position = edgeL*depth)

			#The grafting process duplicates the branchName tip. Drop one of them.
			gtree = drop.tip(gtree, which(gtree$tip == branchName)[1])
			}
		}
	return(gtree)
	}


## add species to the tank tree:

tank.tree.simone.2 <- addCongeners(tank.tree.simone, missing)
spec.simone[,1][which(spec.simone[,1] %in% tank.tree.simone.2$tip.label == F)]

#rename the following
Larix eurolepis - added to Larix decidua (Die Europäische Lärche (Larix decidua) und die Japanische Lärche (Larix kaempferi)  bastardisiert gelegentlich zu Larix eurolepis (Syn. Larix × marschlinsii)) 
# done

# prune tank tree
dat <- rbind(spec.simone[,1], spec.simone[,1])
colnames(dat) <- dat[1,]
tank.tree.simone.pruned <- prune.sample(dat, tank.tree.simone.2)

pdf("Phylo_Simone.pdf", height = 15, width = 9)
plot(tank.tree.simone.pruned, type = "p", cex = .7)
dev.off()

write.tree(tank.tree.simone.pruned, file = "phylo_simone.tre")

##############################
# calculate diversity indices #
###############################

# read in community data
spec.simone <- read.csv("/home/oliver/Dokumente/PhD/PostPhD/Projects/Simone/Community_matrix2.csv", head = T)
str(spec.simone)
spec.simone[1:5,1:5]
rownames(spec.simone) <- spec.simone[,1]
# give rownames according to the site names
spec.simone2 <- spec.simone[,-1]

# remove species that do not occur in any site:
miss.spec <- apply(spec.simone2, 2, FUN = function (x) {sum(is.na(x))})!=1008
spec.simone3 <- spec.simone2[,miss.spec]
# only contains 87 of the 107 species
spec.simone3[1:5,1:5]
# convert Nas into 0
spec.simone3[is.na(spec.simone3)] <- 0
str(spec.simone3)


colnames(spec.simone3) <- gsub("\\.", "_", colnames(spec.simone3))

colnames(spec.simone3)[which(colnames(spec.simone3)=="Parashorea__malaanonan")] <- "Parashorea_malaanonan"

colnames(spec.simone3)[which(colnames(spec.simone3) %in% colnames(mat$comm)==F)]

# match phylogeny and community data
mat <- match.phylo.comm(tank.tree.simone.pruned, spec.simone3)
phylodiv <- pd(mat$comm, mat$phy, include.root=TRUE)

library(PhyloMeasures)

pd.phylo <- pd.query(mat$phy, mat$comm)
pd.phylo.stand <- pd.query(mat$phy, mat$comm,TRUE)

mpd.phylo <- mpd.query(mat$phy, mat$comm)
mpd.phylo.stand <- mpd.query(mat$phy, mat$comm, TRUE)

mntd.phylo <- mntd.query(mat$phy, mat$comm)
mntd.phylo.stand <- mntd.query(mat$phy, mat$comm, TRUE)

plot(phylodiv$PD, phylodiv$SR)
plot(phylodiv$PD, pd.phylo)
cor(phylodiv$SR, pd.phylo.stand)
plot(phylodiv$PD, pd.phylo.stand)
plot(pd.phylo, pd.phylo.stand)

phylodiversity <- cbind(phylodiv$SR, pd.phylo, pd.phylo.stand, mpd.phylo, mpd.phylo.stand, mntd.phylo, mntd.phylo.stand)
colnames(phylodiversity) <- c("S","PD","PD.stand","MPD","MPD.stand","MNTD","MNTD.stand")

save(phylodiversity, file = "phylodiversity.Rdata")
write.csv(phylodiversity, file = "phylodiversity.csv")

com87 <- mat$comm
save(com87, file = "com87.Rdata")

phy87 <- mat$phy
save(phy87, file = "phy87.Rdata")

#################

## code Maddy:
Nem_Sp <- read.csv("/home/oliver/Dokumente/PhD/PostPhD/Projects/Maddy/Nem_Sps.csv")
Nem.taxon <- read.csv("/home/oliver/Dokumente/PhD/PostPhD/Projects/Maddy/Nem.taxon.csv")
colnames(Nem_Sp) <- paste("Spec", 1:50, sep=".")


library(vegan)
taxdis <- taxa2dist(Nem.taxon, varstep=TRUE)
taxdismat <- as.matrix(taxdis)

colnames(taxdismat) <- colnames(Nem_Sp)
rownames(taxdismat) <- colnames(Nem_Sp)

c1<-hclust(as.dist(taxdismat), "aver")

nem.tree <- as.phylo(c1)
plot(nem.tree)

Nem.Sp.49 <- Nem_Sp[,-38]

mat <- match.comm.dist(Nem.Sp.49, taxdismat)

mat2 <- match.phylo.comm(nem.tree, Nem.Sp.49)

library(picante)
library(FD)
library(spacodiR)

dbFDNull <- function(traits, com, value, nullmod, runs){
FD.shuff <- function(com, runs){
  Res = NA
  for (r in 1:runs) {     
    Res <- cbind(Res, dbFD(x = traits, a = t(eval(parse(text=paste("resamp.", nullmod, sep = "")))(t(com))), corr = "lingoes", m = 10, calc.CWM = F, stand.FRic = TRUE)[[value]])
  }
  return(Res)
}
obs <- dbFD(x = traits, a = com, corr = "lingoes", m = 10, calc.CWM = F, stand.FRic = TRUE)[[value]]
resamp <- FD.shuff(com = com, runs = runs)
rand.mean <- apply(resamp, MARGIN = 1, FUN = mean, na.rm = TRUE)
rand.sd <- apply(resamp, MARGIN = 1, FUN = sd, na.rm = TRUE)
ses <- (obs - rand.mean)/rand.sd
data.frame(obs, ses)
}

# example FRic:
dbFD.FRic.Nullmod.SES <- dbFDNull(traits = as.dist(mat$dist), com = mat$comm, value = 3, nullmod = "1s", runs = 20)
dbFD.FRic.Nullmod.SES

# example FDiv:
dbFD.FDiv.Nullmod.SES <- dbFDNull(traits = mat$dist, com = mat$comm, value = 6, nullmod = "1s", runs = 9)
dbFD.FDiv.Nullmod.SES


res <- ses.mpd(mat$comm, mat$dist,null.model="taxa.labels", runs = 999, abundance.weighted = TRUE)
res

 
res.2 <- ses.mpd(mat$comm, mat$dist,null.model="taxa.labels", runs = 999, abundance.weighted = FALSE)
res.2   

res.3 <- ses.pd(mat2$comm, mat2$phy, null.model="taxa.labels", runs = 99)
res.3   

res.4 <- ses.pd(mat2$comm, mat2$phy, null.model="taxa.labels", runs = 99, include.root=TRUE)
res.4  

# treatment data:
Trt_Order <- read.csv("/home/oliver/Dokumente/PhD/PostPhD/Projects/Maddy/Trt_Order.csv")

phylodiv <- cbind(res[,c(1,2,6)],res.2[,c(2,6)],res.3[,c(2,6)])
colnames(phylodiv) <- c("S", "mpd.abu", "ses.mpd.abu", "mpd.pa", "ses.mpd.pa", "pd", "ses.pd")

phylodiv.trt <- cbind(Trt_Order,phylodiv)
str(phylodiv.trt)

write.csv(phylodiv.trt, file = "phylodiv.trt.csv")

#######################################################


####
## 14.00-14.30: 
# check whether MPDabu corresponds to Delta (or Rao) or Delta*

library(picante)
data(phylocom)
mpd.abu <- mpd(phylocom$sample, cophenetic(phylocom$phylo), abundance.weighted=TRUE)
mpd.pa <- mpd(phylocom$sample, cophenetic(phylocom$phylo), abundance.weighted=FALSE)
# for taxondive,e species names in the distance matrix and community matrix have to be in the same order, so have the data first:
mat <- match.phylo.comm(phylocom$phylo, phylocom$sample)

delta <-   taxondive(phylocom$sample, cophenetic(phylocom$phylo))$D
dstar <-   taxondive(phylocom$sample, cophenetic(phylocom$phylo))$Dstar
dplus <-   taxondive(phylocom$sample, cophenetic(phylocom$phylo))$Dplus
sr <-   taxondive(phylocom$sample, cophenetic(phylocom$phylo))$Species

rao <- raoD(phylocom$sample, phylocom$phylo)$Dkk

PDmeasures <- cbind(sr, mpd.abu, mpd.pa, delta, dstar, dplus, rao)
CorTestPlot(PDmeasures)

######################################################    
### phylogeny for 9 mosses from open tree of life:
library(rotl)	

nam <- c(
    "Rhytidiadelphus squarrosus",
    "Calliergonella cuspidata",
    "Brachythecium rutabulum",
    "Marchantia polymorpha",
    "Hypnum cupressiforme",
    "Grimmia pulvinata",
    "Polytrichum strictum",
    "Fissidens taxifolius",
    "Plagiomnium undulatum"
)


mosses <- nam
(resolved_names <- tnrs_match_names(mosses))

tr <- tol_induced_subtree(ott_ids=ott_id(resolved_names))
plot(tr)

write.tree(tr, file = "moss_phylo.tre")

pdf("moss_phylo.pdf", height = 10, width = 10)
plot(tr, type = "p", cex = 1)
dev.off()

######################################################
