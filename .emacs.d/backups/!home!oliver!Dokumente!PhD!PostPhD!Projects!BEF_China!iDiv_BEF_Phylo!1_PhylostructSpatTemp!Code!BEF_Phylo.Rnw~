%% LyX 2.0.3 created this file.  For more info, see http://www.lyx.org/.
%% Do not edit unless you really know what you are doing.
\documentclass{article}
\usepackage{mathpazo}
%\usepackage{lmodern}

\renewcommand{\sfdefault}{lmss}
\renewcommand{\ttdefault}{lmtt}
\usepackage[T1]{fontenc}
\usepackage{geometry}
\geometry{verbose,tmargin=2.5cm,bmargin=2.5cm,lmargin=2.5cm,rmargin=2.5cm}
\usepackage{url}
\usepackage[authoryear]{natbib}

\makeatletter
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% User specified LaTeX commands.
% \VignetteIndexEntry{An Introduction to knitr}

\makeatother

\begin{document}

\title{Lab report: "Temporal dynamics of phylogenetic structure during subtropical forest
succession"}

\author{Oliver Purschke}

\maketitle
The \textbf{knitr} package \citep{Bel10} is an alternative too
to Sweave based on a different design with more features. This document
is not the real vignette, but only serves as a placeholder to guide
you to the real manuals of this package. You can find them in the
package website: \url{http://yihui.name/knitr}%
\footnote{e.g. the main manual: \url{https://github.com/downloads/yihui/knitr/knitr-manual.pdf}
and the graphics manual: \url{https://github.com/downloads/yihui/knitr/knitr-graphics.pdf}%
}, and remember to read the help pages of functions in this package.

Anyway, here is a code chunk that shows you can compile vignettes
with \textbf{knitr} as well by using a proper \textsf{Makefile} (see
\url{http://yihui.name/knitr/demo/vignette/}):

<<show-off>>=

# load packages
library(multitable)
library(knitr)
library(picante)
library(spacodiR)
library(ggplot2)
library(adephylo)
library(phylobase)
library(ade4)
library(ecoPD)

# set paths


path.code <- "/home/oliver/Dokumente/PhD/Code/"
path.data <- "/home/oliver/Dokumente/PhD/PostPhD/Projects/BEF_China/Data/"
path.species <- "/home/oliver/Dokumente/PhD/PostPhD/Halle/BEF_China/Data/Species/"
path.phylo <- "/home/oliver/Dokumente/PhD/PostPhD/Projects/BEF_China/Data/Phylo/"
path.site <- "/home/oliver/Dokumente/PhD/PostPhD/Halle/BEF-China/Data/Site/"
path.results <- "/home/oliver/Dokumente/PhD/PostPhD/Halle/BEF-China/Results/"

# load additional functions
source(paste(path.code, "OPfunc.R", sep = ""))
source(paste(path.code,"RaoDeBelloJVS/Rao_JVS.R", sep = ""))
source(paste(path.code, "spacodiutility.R", sep = ""))

# load entire data set
load(paste(path.data,"befdat.Rdata", sep = ""))

save(befdat, file = paste(path.data,"befdat.Rdata", sep = ""))

## load BCI phylogeny
bci.tree <- read.tree("/home/oliver/Dokumente/PhD/PostPhD/IDiv/BCI_w_Nadja_Nate/dated.tree.tre")

pdf("bci.tree.pdf")
plot(bci.tree, type = "f", cex = .25)
dev.off()

##
# PCA of workshop applicants
pcadat <- read.csv("/home/oliver/Dokumente/PhD/PostPhD/IDiv/sDiv/TraitWorkshop/Analysis/TraitVegetation/PCA_People.csv", sep = "\t", row.names=1)

str(pcadat)

pca.ws <- rda(pcadat+rnorm(dim(pcadat)[1]*3)/5)
ordipointlabel(pca.ws, cex = c(.6,.6))
pdf("pcaWS3.pdf")
ordipointlabel(pca.ws, cex = c(.6,.6))
dev.off()

##########################################
###### figures for Geobot-Lecture:

   ## Preliminary: needs better data and some support functions
     data(dune)
     data(dune.taxon)
     # Taxonomic distances from a classification table with variable step lengths.
     taxdis <- taxa2dist(dune.taxon, varstep=TRUE)

postscript("phylo.tax.hier.eps", height = 8, width = 8, paper = "special", onefile = FALSE, horizontal = FALSE, pointsize=14)
     plot(hclust(taxdis), hang = -1)
dev.off()


postscript("phylo.tax.topo.bioflor.eps", height = 8, width = 8, paper = "special", onefile = FALSE, horizontal = FALSE, pointsize=14)
plot(compute.brlen(as.phylo(hclust(taxdis)),1))
dev.off()


### Leprieur code PlosOne 2012:

source("/home/oliver/Dokumente/PhD/PostPhD/Workshops/BiodivExp_BetaDiversity/Code/Leprieur2012Code.R")


beta.comp <- beta.pd.decompo(com, tree,type="both",output.dist=F, random=F)

##a measure of phylobetadiversity (e.g., Graham & Fine 2008) using Lande's (1996) scheme, used phylocom format file (comID,abund,species name). Includes randomization test if n.rand > 0 (swap tip labels across the phylogeny).
#Marc Cadotte
#Nov 2008

phyloBeta<-function (phy,com,n.rand=0) {
	
	PDT<-sum(phy$edge.length)
	
	PDa<-PDcalc(phy,com)
	
	PDa$q<-PDa$sp.rich/sum(PDa$sp.rich)	
	PDa$mean.PDa<-(PDa$q*PDa$PD)
	results<-data.frame(PD.alpha=sum(PDa$mean.PDa),
		PDT,PD.beta=PDT-sum(PDa$mean.PDa))
	
	if (n.rand>0) 	{
		
		tmp.phy<-phy
		rand.tmp<-data.frame(PD.alph.rand=0, PDT.rand=0,
		PD.beta.rand=0,n.rand=0)
		
		for (i in 1:n.rand) {
			
			tmp.phy$tip.label<-sample(tmp.phy$tip.label)
			rand.tmp[i,2]<-sum(tmp.phy$edge.length)
			tmp.PDa<-PDcalc(tmp.phy,com)
			tmp.PDa$q<-tmp.PDa$sp.rich/sum(tmp.PDa$sp.rich)
			rand.tmp[i,1]<-sum(tmp.PDa$q*tmp.PDa$PD)
			
			rand.tmp[i,3]<-rand.tmp$PDT.rand[i]-rand.tmp$PD.alph.rand[i]
			rand.tmp[i,4]<-n.rand	
			}
		results<-cbind(results,
		null.PD.alph=mean(rand.tmp$PD.alph.rand),
		SD.PD.alph=sd(rand.tmp$PD.alph.rand),
		null.PD.beta=mean(rand.tmp$PD.beta.rand),
		SD.PD.beta=sd(rand.tmp$PD.beta.rand),
		num.rands=n.rand)
		} 

	return(results)
	}

#function to claculate PD using a phylogeny file (phy) and a 
#community file in the phylocom format (columns: community name, 
#spp abundance, spp name). Make sure names in community file and #phylogeny match using 'match' function.

#Marc Cadotte
#Oct 2008

com <- d.phylocom

PDcalc <- function (phy,com) {
	
	Community<-unique(com[,1])#generate list of community IDs
	N.coms<-length(Community)
	species<-phy$tip.label

	#for output
	PD<-numeric(N.coms)
	sp.rich<-numeric(N.coms)

	for (i in 1:N.coms) {
		
		ID<-Community[i]#select community.ID
		myclade<-com[com[,1]==ID,3]	# !!!!!!! fix a bug here	
		if (length(myclade)==1) {
			print(paste("Community",ID,"has a single species!"))
			}
		
		sub.tree<-subTree(phy,myclade)
		
		PD[i]<-sum(sub.tree$edge.length)
		sp.rich[i]<-length(sub.tree$tip.label)


		}#end iter loop

results <- data.frame(Community,PD,sp.rich)
return(results)
	}



#to make subtrees from phylogeny file (phy) and species vector

subTree<- function(phy,species) {
		
		all.in<-is.na(match(species,phy$tip.label))
		
		if (sum(all.in)>0) 
		paste("species",as.character(species[all.in]),
			"not in phylogeny")
		
		dropme<-phy$tip.label[!phy$tip.label %in% unique(species)]
		sub.tr<-drop.tip(phy,dropme)

		}

################################################################

###########
## Plotter of 2 distance matrices (phylogeny and character)
## By Katie Wagner and Marc Cadotte
## Aug 2008

char <- writetraits(trait2, , file = "traits.csv")
tree <- phy

trait1 <- cbind(trait[,3:4], rownames(trait), trait[,3])
trait2 <- trait1[,3:4]

char <- trait2

distPlot(tree, char, dist.method="manhattan",scheme="color",circles="small",comparison="tree-char")

distPlot <- function 
(tree,char, dist.method="manhattan",scheme="color",circles="small",comparison="tree-char") {
	
	require(ape)
if (comparison=="tree-char") {

	if (is.ultrametric(tree)==F) {
		tree<-chronogram(tree)
		}
		
		
	if (class(char)=="data.frame") {
		
		names(char)<-c("rname","char")
		s.ord<-match(tree$tip.label,char$rname)
		char<-char[s.ord,]
		
		rownames(char)<-char$rname
		
		charD<-as.matrix(dist(char[2],method=dist.method))
		treeD<-as.matrix(as.dist(2*max(tree$edge.length)-2*(vcv.phylo(tree))))
		
		}
	if (class(char)!="data.frame")	 {
			print("Need 2 column dataframe!")
			char=0
			}	
		}

if (comparison == "char-char") {
	treeD<-tree
	 charD<-char
	}

treeD[lower.tri(treeD)]<-NA
charD[lower.tri(charD)]<-NA

df<-data.frame()

for (i in 1:length(rownames(treeD))){

	#phylo matrix
	centxvec<-treeD[i,]
	#character matrix
	centyvec<-charD[i,]

	for (j in i:length(centxvec)){
		x<-centxvec[j]
		y<-centyvec[j]
		
		if (!is.na(x) | !is.na(y))
			vec<-c(x,y)
			df<-data.frame(rbind(df,vec))	
	}		
}	

df<-df[df$X0!=0 & df$X0.1!=0,]

vec1bind<-NULL
vec2bind<-NULL
	
for (j in 1:length(centxvec)){
	vec1<-rep(j,times=length(centxvec)-j)
	
	vec1bind<-c(vec1bind,vec1)
	
	if (j<length(centxvec)) {
	vec2<-(j+1):length(centxvec)
	vec2bind<-c(vec2bind,vec2)
	}	
}

	coldf<-data.frame(cbind(vec1bind,vec2bind))
	df<-data.frame(df[1]/max(df[1]),df[2]/max(df[2]))
	final<-data.frame(df,coldf,
	row.names=c(1:length(coldf$vec1bind)))
	
	half_circ<-function(centx,centy,r,col1,col2){
        theta<-seq(-pi,pi,length=100)
        polygon(centx+r*sin(theta),centy+r*cos(theta), col=col1)
        theta<-seq(-pi,0,length=50)
        polygon(centx+r*sin(theta),centy+r*cos(theta), col=col2)
	}

	par(mfrow=c(1,2))
	maxX<-max(final$X0)-min(final$X0)

	if (circles=="small"){
		r=((1/40)*maxX)
	}
	
	if (circles=="large"){
	r=((1/25)*maxX)
	}

	colorvec<-hsv(seq(0,0.8,by=0.01),1,1,alpha=0.7)
	div<-(floor(length(colorvec)/length(unique(final$vec1bind))))
	choosecols<-seq(1,length(colorvec),by=div)
	cols<-colorvec[choosecols]
	
if (comparison=="tree-char") {
	
	
	plot(0,0,type="n",xlim=c(min(final$X0),1),
	ylim=c(min(final$X0.1),1),
	xlab="Relative phylogenetic distance",
	ylab="Relative character distance",asp=T)

if (scheme=="color") {

	for (i in 1:length(final$X0)){

		half_circ(centx=final$X0[i],
		centy=final$X0.1[i],
		r,
		col1=cols[final$vec1bind[i]],
		col2=cols[final$vec2bind[i]])
	}
	plot(tree,tip.color=cols)
	}

if (scheme=="grey") {

	cols<-c(colors()[262:361],"black")

	for (i in 1:length(final$X0)){

		half_circ(centx=final$X0[i],
		centy=final$X0.1[i],
		r,
		col1=cols[final$vec1bind[i]],
		col2=cols[final$vec2bind[i]])
	}
	plot(tree,tip.color=cols)
	}
	}
	
	if (comparison=="char-char") {
	
	plot(0,0,type="n",xlim=c(min(final$X0),1),
	ylim=c(min(final$X0.1),1),
	xlab="Relative character distance 1",
	ylab="Relative character distance 2",asp=T)
	
	
if (scheme=="color") {

	for (i in 1:length(final$X0)){

		half_circ(centx=final$X0[i],
		centy=final$X0.1[i],
		r,
		col1=cols[final$vec1bind[i]],
		col2=cols[final$vec2bind[i]])
	}
	frame()
	plot.window(xlim=c(1,4),ylim=c(1,length(unique(final$vec1bind))))
	points(rep(1,times=length(unique(final$vec1bind))),
		c(length(unique(final$vec1bind))):1,
		col="black",
		bg=cols[length(unique(final$vec1bind)):1],
		pch=21,
		cex=1.1	)
	text(rep(2,times=length(unique(final$vec1bind))),
		c(length(unique(final$vec1bind))):1,
		label=rownames(charD))
	}

if (scheme=="grey") {

	cols<-c(colors()[262:361],"black")

	for (i in 1:length(final$X0)){

		half_circ(centx=final$X0[i],
		centy=final$X0.1[i],
		r,
		col1=cols[final$vec1bind[i]],
		col2=cols[final$vec2bind[i]])
	}
	}
	}

	
  	
}

################################################################

# compare phylobeta-metrics (take BEF_China Data)
mat <- match.phylo.comm(phy=befdat$phy.gut.ultra.nongymnocult, comm=t(befdat$com.order))
com.abu <- mat$comm
com.pa <- decostand(mat$comm, "pa")
phy <- mat$phy

### for the 122 species (for which trait data are available):
# trait.table:
load("/home/oliver/Dokumente/PhD/PostPhD/Projects/BEF_China/Helge/SYNCSA/Code/syncsa.data.125.Rdata")

# trait choice according to Böhnke 2013 JVS
trait <- syncsa.data.125$trait.125[,c(5,11,16,1,30,15,27)]
# colnames(trait)
[1] "DW"  "CN"  "Al"  "LM"  "Hei" "Mg"  "Cu" 
# !! "StoA" missing

# exclude species with missing values:
#[1] "Clerodendrum_cyrtophyllum" "Photinia_glabra"          
#[3] "Idesia_polycarpa"    
trait122 <- trait[rownames(trait) %in% rownames(trait)[which(is.na(trait$DW))]==FALSE, ]

trait.pcoa <- pcoa(dist(scale(trait122)))

trait.pcoa.2 <- trait.pcoa$vectors[,1:3]

com122 <- syncsa.data.125$com.125[, rownames(trait)%in%rownames(trait)[which(is.na(trait$DW))]==FALSE]

phy122 <- prune.sample(com122, phy)

com.abu <- com122
com.pa <- decostand(com122, "pa")
phy <- phy122

######################################
# for functional dendrogram
phy <- cl
#############################################
###

beta.list <- list()

# 0) calculate taxonomic Sorensen und Jaccard

beta.list$jacc <- betadiver(com.pa, 10)
beta.list$sor <- betadiver(com.pa, 11)

#1) phylosor

physo <- phylosor(com.pa, phy)
beta.list$physo <- physo

# 2) unifrac

unifra <- unifrac(com.pa, phy)
beta.list$unifra <- unifra

# 3) PDbeta 
  # convert to phylocom
    d.phylocom <- as.phylocom(data=t(com.abu), picante=FALSE)
     d.phylocom ## phylocom format

sample <- writesample(com.abu, file = "sample")
sample <- read.table("sample")

PDbeta <- phyloBeta(phy, d.phylocom, n.rand = 0)

PDbeta <- phyloBeta(phy, sample, n.rand = 0)

# 5) Rao tax

# p/a and abund.

rao.tax.pa <- raoD(com.pa)

beta.list$rao.tax.pa.dkl <- as.dist(rao.tax.pa$Dkl)
beta.list$rao.tax.pa.h <- as.dist(rao.tax.pa$H)

rao.tax.abu <- raoD(com.abu)

beta.list$rao.tax.abu.dkl <- as.dist(rao.tax.abu$Dkl)
beta.list$rao.tax.abu.h <- as.dist(rao.tax.abu$H)

# 6) Rao phy

rao.phy.pa <- raoD(com.pa, phy)

beta.list$rao.phy.pa.dkl <- as.dist(rao.phy.pa$Dkl)
beta.list$rao.phy.pa.h <- as.dist(rao.phy.pa$H)

rao.phy.abu <- raoD(com.abu, phy)

beta.list$rao.phy.abu.dkl <- as.dist(rao.phy.abu$Dkl)
beta.list$rao.phy.abu.h <- as.dist(rao.phy.abu$H)


# 7) Dpw (pa & abu) ! trait distance matrix in case of FD!!

beta.list$Dpw.pa <- comdist(com.pa, cophenetic(phy), abundance.weighted=FALSE)
    
beta.list$Dpw.abu <- comdist(com.abu, cophenetic(phy), abundance.weighted=TRUE)

# on trait distances:
beta.list$Dpw.pa <- comdist(com.pa, as.matrix(dist(scale(trait122))), abundance.weighted=FALSE)
    
beta.list$Dpw.abu <- comdist(com.abu, as.matrix(dist(scale(trait122))), abundance.weighted=TRUE)

# 8) Dnn (pa & abu)

beta.list$Dnn.pa <- comdistnt(com.pa, cophenetic(phy), abundance.weighted=FALSE)
    
beta.list$Dnn.abu <- comdistnt(com.abu, cophenetic(phy), abundance.weighted=TRUE)

# on trait distances:

beta.list$Dnn.pa <- comdistnt(com.pa, as.matrix(dist(scale(trait122))), abundance.weighted=FALSE)
    
beta.list$Dnn.abu <- comdistnt(com.abu, as.matrix(dist(scale(trait122))), abundance.weighted=TRUE)



# 9) Pst (pa & abu)

beta.list$Ist.pa <- as.dist(spacodi.calc(sp.plot = t(com.pa), phy = phy, pairwise=TRUE)$pairwise.Ist)
beta.list$Pst.pa <- as.dist(spacodi.calc(sp.plot = t(com.pa), phy = phy, pairwise=TRUE)$pairwise.Pst)

beta.list$Ist.abu <- as.dist(spacodi.calc(sp.plot = t(com.abu), phy = phy, pairwise=TRUE)$pairwise.Ist)
beta.list$Pst.abu <- as.dist(spacodi.calc(sp.plot = t(com.abu), phy = phy, pairwise=TRUE)$pairwise.Pst)

# on trait distances:

beta.list$Ist.pa <- as.dist(spacodi.calc(sp.plot = t(com.pa), phy = as.matrix(dist(scale(trait122))), pairwise=TRUE)$pairwise.Ist)
beta.list$Pst.pa <- as.dist(spacodi.calc(sp.plot = t(com.pa), phy = as.matrix(dist(scale(trait122))), pairwise=TRUE)$pairwise.Pst)

beta.list$Ist.abu <- as.dist(spacodi.calc(sp.plot = t(com.abu), phy = as.matrix(dist(scale(trait122))), pairwise=TRUE)$pairwise.Ist)
beta.list$Pst.abu <- as.dist(spacodi.calc(sp.plot = t(com.abu), phy = as.matrix(dist(scale(trait122))), pairwise=TRUE)$pairwise.Pst)

# 10) PIst and Bst

beta.list$Bst <- as.dist(spacodi.calc(sp.plot = t(com.abu), phy = phy, pairwise=TRUE)$pairwise.Bst)
beta.list$PIst <- as.dist(spacodi.calc(sp.plot = t(com.abu), phy = phy, pairwise=TRUE)$pairwise.PIst)

# on trait distances:
beta.list$Bst <- as.dist(spacodi.calc(sp.plot = t(com.abu), phy = as.matrix(dist(scale(trait122))), pairwise=TRUE)$pairwise.Bst)
beta.list$PIst <- as.dist(spacodi.calc(sp.plot = t(com.abu), phy = as.matrix(dist(scale(trait122))), pairwise=TRUE)$pairwise.PIst)


# 11) pcd (?pa & abu)

beta.list$PCD <- pcd.pa$PCD
beta.list$PCDc <- pcd.pa$PCDc
beta.list$PCDp <- pcd.pa$PCDp

###################

################################################
# 12) Leprieur- decomp

beta.comp <- beta.pd.decompo(com=com.pa, tree=phy, type="both",output.dist=F, random=F)
# repeat for functional dendrogram

########################################################

# 13) Villeger-decomp ()
library(betapart)

nest.jac <- beta.pair(com.pa, index.family="jac")
nest.sor <- beta.pair(com.pa, index.family="sor")


nest.func.jac <- functional.beta.pair(x=com.pa, traits=trait.pcoa.2, index.family = "jaccard")
nest.func.sor <- functional.beta.pair(x=com.pa, traits=trait.pcoa.2, index.family = "sorensen")

# for phylogenetic distance

phy.pcoa <- pcoa(cophenetic(phy122))

phy.pcoa.2 <- phy.pcoa$vectors[,1:3]
    
nest.phyl.jac <- functional.beta.pair(x=com.pa, traits=phy.pcoa.2, index.family = "jaccard")
nest.phyl.sor <- functional.beta.pair(x=com.pa, traits=phy.pcoa.2, index.family = "sorensen")

beta.list2 <- c(beta.list, nest.jac, nest.sor, nest.func.jac, nest.func.sor)

# ! redo for nest.phyl.jac
beta.list2 <- c(beta.list, nest.jac, nest.sor, nest.phyl.jac, nest.phyl.sor)

## !!! check whether beta based on 122 species is equivalent to beta based on 143 species


# 14) de Bello equivalent number approach

Rao.PD <- Rao(sample=t(com122), dfunc=NULL, dphyl=cophenetic(phy122), weight=F, Jost=T, structure=NULL)
Rao.PD.pa <- Rao(sample=t(decostand(com122, "pa")), dfunc=NULL, dphyl=cophenetic(phy122), weight=F, Jost=T, structure=NULL)

beta.list2$Rao.tax.Jost.abu <- Rao.PD$TD$Pairwise_samples$Beta_prop
beta.list2$Rao.tax.Jost.pa <- Rao.PD.pa$TD$Pairwise_samples$Beta_prop

beta.list2$Rao.pd.Jost.abu <- Rao.PD$PD$Pairwise_samples$Beta_prop
beta.list2$Rao.pd.Jost.pa <- Rao.PD.pa$PD$Pairwise_samples$Beta_prop


### also for functional dendrogram

# for distance matrix on the traits directly

Rao.FD <- Rao(sample=t(com122), dfunc=dist(scale(trait122)), dphyl=NULL, weight=F, Jost=T, structure=NULL)
Rao.FD.pa <- Rao(sample=t(decostand(com122, "pa")), dfunc=dist(scale(trait122)), dphyl=NULL, weight=F, Jost=T, structure=NULL)

# for distance matrix on the functional dendrogram

Rao.FD <- Rao(sample=t(com122), dfunc=cophenetic(phy), dphyl=NULL, weight=F, Jost=T, structure=NULL)
Rao.FD.pa <- Rao(sample=t(decostand(com122, "pa")), dfunc=cophenetic(phy), dphyl=NULL, weight=F, Jost=T, structure=NULL)

##

beta.list2$Rao.tax.Jost.abu <- Rao.FD$TD$Pairwise_samples$Beta_prop
beta.list2$Rao.tax.Jost.pa <- Rao.FD.pa$TD$Pairwise_samples$Beta_prop

beta.list2$Rao.fd.Jost.abu <- Rao.FD$FD$Pairwise_samples$Beta_prop
beta.list2$Rao.fd.Jost.pa <- Rao.FD.pa$FD$Pairwise_samples$Beta_prop

####

beta.vec <- as.data.frame(lapply(beta.list2, as.vector))

beta.vec2 <- cbind(beta.vec, beta.comp$betadiv) 
# convert similarities into dissimilarities
beta.vec2$physo <- 1-beta.vec2$physo
beta.vec2$jacc <- 1-beta.vec2$jacc
beta.vec2$sor <- 1-beta.vec2$sor

########################################

# why is beta.nes and functional/phylo.-nes so strange:

# 1) check whether the nestness matrices (from the beta-part package are right) are right (yes is right)
# 2) what is the difference between the nestedness and turnover components in Leprieur 2012 and Villeger 2013 (see also Baselga 2012 GEB)

# 3) correlate FD and PD within each of the different (3?) groups


# go on with 2-3 more slides
# mention standard approaches (distance-based RDA, mantel-test)
# double- DPCoA
# structural equation modelling approach to modelling beta diversity
# ANOQE

# 1) 

cor(nest.func.jac$funct.beta.jac, nest.jac$beta.jac)
cor(1-beta.list$jacc, nest.jac$beta.jac)

cor(1-beta.list$physo, nest.func.sor$funct.beta.sor)
plot(1-beta.list$physo, nest.func.sor$funct.beta.sor)


cor(beta.vec.FD$funct.beta.jne, beta.vec.FD$UniFrac_PD)

plot(1-beta.list$physo, nest.phyl.sor$funct.beta.sim)


# 2) Difference between the nestedness and turnover components in Leprieur 2012 and Villeger 2013 (see also Baselga 2012 GEB)


# 3) Correlate FD and PD within each of the different (3, maybe 5?) groups

# [13] "Dpw.pa","Dpw.abu""rao.phy.pa.dkl""rao.phy.abu.dkl"

names(beta.vec.PD)
 [1] "jacc"             "sor"              "physo"            "unifra"          
 [5] "rao.tax.pa.dkl"   "rao.tax.pa.h"     "rao.tax.abu.dkl"  "rao.tax.abu.h"   
 [9] "rao.phy.pa.dkl"   "rao.phy.pa.h"     "rao.phy.abu.dkl"  "rao.phy.abu.h"   
[13] "Dpw.pa"           "Dpw.abu"          "Dnn.pa"           "Dnn.abu"         
[17] "Ist.pa"           "Pst.pa"           "Ist.abu"          "Pst.abu"         
[21] "Bst"              "PIst"             "PCD"              "PCDc"            
[25] "PCDp"             "beta.jtu"         "beta.jne"         "beta.jac"        
[29] "beta.sim"         "beta.sne"         "beta.sor"         "funct.beta.jtu"  
[33] "funct.beta.jne"   "funct.beta.jac"   "funct.beta.sim"   "funct.beta.sne"  
[37] "funct.beta.sor"   "Rao.tax.Jost.abu" "Rao.tax.Jost.pa"  "Rao.pd.Jost.abu" 
[41] "Rao.pd.Jost.pa"   "PhyloSor"         "PhyloSor_turn"    "PhyloSor_PD"     
[45] "UniFrac"          "UniFrac_turn"     "UniFrac_PD"   

names(beta.vec.FD.dist)
 [1] "jacc"             "sor"              "physo"            "unifra"          
 [5] "rao.tax.pa.dkl"   "rao.tax.pa.h"     "rao.tax.abu.dkl"  "rao.tax.abu.h"   
 [9] "Dpw.pa"           "Dpw.abu"          "Dnn.pa"           "Dnn.abu"         
[13] "Ist.pa"           "Pst.pa"           "Ist.abu"          "Pst.abu"         
[17] "Bst"              "PIst"             "PCD"              "PCDc"            
[21] "PCDp"             "rao.phy.pa.dkl"   "rao.phy.pa.h"     "rao.phy.abu.dkl" 
[25] "rao.phy.abu.h"    "beta.jtu"         "beta.jne"         "beta.jac"        
[29] "beta.sim"         "beta.sne"         "beta.sor"         "funct.beta.jtu"  
[33] "funct.beta.jne"   "funct.beta.jac"   "funct.beta.sim"   "funct.beta.sne"  
[37] "funct.beta.sor"   "Rao.tax.Jost.abu" "Rao.tax.Jost.pa"  "Rao.fd.Jost.abu" 
[41] "Rao.fd.Jost.pa"   "PhyloSor"         "PhyloSor_turn"    "PhyloSor_PD"     
[45] "UniFrac"          "UniFrac_turn"     "UniFrac_PD"    

#####################

PD.group.1.1 <- beta.vec.PD[, c(43,46,40,12,20,16)]
FD.group.1.1 <- beta.vec.FD.dist[, c(43,46,40,25,16,12)]

names(PD.group.1.1)
names(FD.group.1.1)

#####################

PD.group.1.2 <- beta.vec.PD[, c(23,42,45,41,18,15,10)]
FD.group.1.2 <- beta.vec.FD.dist[, c(19,42,45,41,14,11,23)]

names(PD.group.1.2)
names(FD.group.1.2)

#####################

PD.group.1.3 <- beta.vec.PD[, c(32, 35)]
FD.group.1.3 <- beta.vec.FD.dist[, c(32, 35)]

names(PD.group.1.3)
names(FD.group.1.3)

######################################

PD.group.1 <- beta.vec.PD[, c(23,42,45,41,18,15,10,43,46,40,12,20,16,32,35)]
FD.group.1 <- beta.vec.FD.dist[, c(19,42,45,41,14,11,23,43,46,40,25,16,12,32,35)]

names(PD.group.1)
names(FD.group.1)

######################################

PD.group.2 <- beta.vec.PD[, c(13,14,9,11)]
FD.group.2 <- beta.vec.FD.dist[, c(9,10,22,24)]

names(PD.group.2)
names(FD.group.2)

######################################

PD.group.3 <- beta.vec.PD[, c(22,25,46,47,33,36,34,37)]
FD.group.3 <- beta.vec.FD.dist[, c(18,21,46,47,33,36,34,37)]

names(PD.group.3)
names(FD.group.3)

######################################

PD.group.3.1 <- beta.vec.PD[, c(22,25)]
FD.group.3.1 <- beta.vec.FD.dist[, c(18,21)]

names(PD.group.3.1)
names(FD.group.3.1)

######################################

PD.group.3.2 <- beta.vec.PD[, c(46,47,33,36,34,37)]
FD.group.3.2 <- beta.vec.FD.dist[, c(46,47,33,36,34,37)]

names(PD.group.3.2)
names(FD.group.3.2)

######################################

PD.group.3.3 <- beta.vec.PD[, c(46,47,33,36)]
FD.group.3.3 <- beta.vec.FD.dist[, c(46,47,33,36)]

names(PD.group.3.3)
names(FD.group.3.3)

######################################


pair.cor.fun <- function(a,b){
    mat <- 1:dim(a)[2]
    for (i in 1:dim(a)[2]){
        mat[i] <- cor(a[,i], b[,i])
    }
    mat
}

mean(pair.cor.fun(PD.group.1.1, FD.group.1.1)) # 0.8491881
mean(pair.cor.fun(PD.group.1.2, FD.group.1.2)) # 0.7510966
mean(pair.cor.fun(PD.group.1.3, FD.group.1.3)) # 0.1646675

mean(pair.cor.fun(PD.group.1, FD.group.1)) # 0.7121427


mean(pair.cor.fun(PD.group.2, FD.group.2)) # 0.3225998


mean(pair.cor.fun(PD.group.3, FD.group.3)) # 0.2390903
mean(pair.cor.fun(PD.group.3.1, FD.group.3.1)) # -0.07349338
mean(pair.cor.fun(PD.group.3.2, FD.group.3.2)) # 0.3432849
mean(pair.cor.fun(PD.group.3.3, FD.group.3.3)) # 0.4770611

 
# 4) rename names in FD and PD data for the ordination plots


########################################

beta.vec.PD <- beta.vec2

save(beta.vec.PD, file = "beta.vec.PD.Rdata")
load("beta.vec.PD.Rdata")

# for FD
beta.vec.FD.dendro <- beta.vec2

save(beta.vec.FD.dendro, file = "beta.vec.FD.dendro.Rdata")
load("beta.vec.FD.dendro.Rdata")

#####

beta.vec.FD.dist <- beta.vec2

save(beta.vec.FD.dist, file = "beta.vec.FD.dist.Rdata")
load("beta.vec.FD.dist.Rdata")

########################################


###
phy$edge.length <- phy$edge.length+.01
pcd.pa <- pcd(com.pa, phy)
pcd.abu <- pcd(com.abu, phy)
###

# run pcd on a trait dendrogram (later compare with pcd on trait covariance matrix)

trait.dist <- dist(scale(trait122))
# cluster analysis on the distance matrix
cl <- hclust(trait.dist, "aver")
cl <- as.phylo(cl)
pcd.pa <- pcd(com.pa, cl)



######################

pdf("cor.beta.pdf", height = 25, width = 25)
CorTestPlot(beta.vec)
dev.off()

# plot pca 

pca.beta.scale.FD <- rda(beta.vec.FD, scale = T)

#Importance of components:
#                         PC1    PC2     PC3     PC4     PC5     PC6     PC7
#Eigenvalue            23.593 6.4089 4.24637 2.49439 2.33871 2.09935 1.61848
#Proportion Explained   0.502 0.1364 0.09035 0.05307 0.04976 0.04467 0.03444
#Cumulative Proportion  0.502 0.6383 0.72868 0.78176 0.83152 0.87618 0.91062

pca.beta.scale.FD.dendro <- rda(beta.vec.FD.dendro, scale = T)

#Importance of components:
#                          PC1    PC2    PC3     PC4     PC5     PC6     PC7
#Eigenvalue            23.7963 6.4072 4.2159 2.46990 2.35082 2.12587 1.69626
#Proportion Explained   0.5063 0.1363 0.0897 0.05255 0.05002 0.04523 0.03609
#Cumulative Proportion  0.5063 0.6426 0.7323 0.78488 0.83490 0.88013 0.91622

pca.beta.scale.FD.dist <- rda(beta.vec.FD.dist, scale = T)

#Importance of components:
#                          PC1    PC2     PC3     PC4     PC5     PC6    PC7
#Eigenvalue            23.8705 6.3893 4.55213 2.69365 1.93755 1.77996 1.4523
#Proportion Explained   0.5079 0.1359 0.09685 0.05731 0.04122 0.03787 0.0309
#Cumulative Proportion  0.5079 0.6438 0.74068 0.79799 0.83921 0.87709 0.9080

###############

pca.beta.scale.PD <- rda(beta.vec.PD, scale = T)

#Importance of components:
#                          PC1    PC2     PC3     PC4     PC5     PC6     PC7
#Eigenvalue            23.0462 6.9774 4.35932 3.08122 2.26810 1.75647 1.31386
#Proportion Explained   0.4904 0.1484 0.09275 0.06556 0.04826 0.03737 0.02795
#Cumulative Proportion  0.4904 0.6388 0.73155 0.79711 0.84537 0.88274 0.91069



#pdf("cor.beta.pca.pdf", height = 8, width = 8)
#png("cor.beta.pca.png", height = 8, width = 8)
postscript("cor.beta.pca.FD.eps", height = 8, width = 8, paper = "special", onefile = FALSE, horizontal = FALSE, pointsize=14)
fig <- ordiplot(pca.beta.scale.FD, type = "none", xlim = c(-2, 1), ylim = c(-1,2))
ordipointlabel(pca.beta.scale.FD, display = "species", add = TRUE)
dev.off()

postscript("cor.beta.pca.FD.dendro.eps", height = 8, width = 8, paper = "special", onefile = FALSE, horizontal = FALSE, pointsize=14)
fig <- ordiplot(pca.beta.scale.FD.dendro, type = "none", xlim = c(-2, 1), ylim = c(-1,2))
ordipointlabel(pca.beta.scale.FD.dendro, display = "species", add = TRUE)
dev.off()

postscript("cor.beta.pca.FD.dist.eps", height = 8, width = 8, paper = "special", onefile = FALSE, horizontal = FALSE, pointsize=14)
fig <- ordiplot(pca.beta.scale.FD.dist, type = "none", xlim = c(-2, 1), ylim = c(-1,2))
ordipointlabel(pca.beta.scale.FD.dist, display = "species", add = TRUE)
dev.off()

##########

postscript("cor.beta.pca.PD.eps", height = 8, width = 8, paper = "special", onefile = FALSE, horizontal = FALSE, pointsize=14)
fig <- ordiplot(pca.beta.scale.PD, type = "none", xlim = c(-2, 1), ylim = c(-1.5,1))
ordipointlabel(pca.beta.scale.PD, display = "species", add = TRUE)
dev.off()

# plot cluster diagram 

#pdf("cor.beta.cluster.pdf", height = 8, width = 8)
postscript("cor.beta.cluster.eps", height = 8, width = 8, paper = "special", onefile = FALSE, horizontal = FALSE, pointsize=14)
h <- hclust(dist(t(scale(beta.vec))), method = "complete")
plot(h)
dev.off()

#########

# co-correspondence plot:
library(cocorresp)  


data(beetles)
     
     ## log transform the bettle data
     beetles <- log(beetles + 1)
     
     data(plants)
     
     ## fit the model
     bp.sym <- coca(beetles ~ ., data = plants, method = "symmetric")
     ## draw the biplots
     
     ## draw a biplot of the response
     plot(bp.sym)
     
     ## plot of both
postscript("cocorresp.eps", height = 6, width = 12, paper = "special", onefile = FALSE, horizontal = FALSE, pointsize=14)
     layout(matrix(1:2, ncol = 2))
     plot(bp.sym, which = "response", main = "Beetles")
     plot(bp.sym, which = "predictor", main = "Plants")
     layout(1)
    dev.off()

   
#############################

##
DstSite <- cbind(colnames(befdat$com.order), befdat$SES.age.Dstar[,1])
Dst.site.sort <- DstSite[order(as.numeric(DstSite[,2])),]

PIstSite <- cbind(colnames(befdat$com.order), befdat$SES.age.Dplus[,1])
PIst.site.sort <- PIstSite[order(as.numeric(PIstSite[,2])),]

# low Dst: CSPs 26, 3, 7
# high Dst: CSPs 4, 20, 9

# map species abundances of the three most clustered and overdispersed sites, respectively on the phylogeny (take site names as traits) 

mat <- match.phylo.comm(phy=befdat$phy.gut.ultra.nongymnocult, comm=t(befdat$com.order))

herb.6 <- phylo4d(mat$phy, (t(mat$comm)[, c(Dst.site.sort[,1][1:3], Dst.site.sort[,1][25:27])])^0.25)

pdf("phytab.Dstar.6.pdf", width = 12, height = 20)
phytab <- table.phylo4d(herb.6, treetype="phylogram", show.node.label=F, box=F, ratio.tree=1/2, font=3, cex.label=.7, cex.symbol=.8,cex.legend = .8, scale = F)
dev.off()

# for all sites ordered according to (a) successional stages and (b) age of the oldest tree

# (a)
herb <- phylo4d(mat$phy, (t(mat$comm)[, c(Dst.site.sort[,1][1:3], Dst.site.sort[,1][25:27])])^0.25)

pdf("phytab.abu.ageHB.pdf", width = 12, height = 20)
phytab <- table.phylo4d(herb, treetype="phylogram", show.node.label=F, box=F, ratio.tree=1/3, font=3, cex.label=.7, cex.symbol=1.2,cex.legend = .8, scale = F, symbol = "squares", var.label=)
dev.off()

# (b)

herb.age <- phylo4d(mat$phy, (t(mat$comm)[,order(befdat$site.order[,57])])^0.25)

# pdf("phytab.abu.age.pdf", width = 12, height = 20)
postscript("phytab.abu.age.eps", width = 12, height = 26, paper = "special", onefile = FALSE, horizontal = FALSE, pointsize=14)
phytab <- table.phylo4d(herb.age, treetype="phylogram", show.node.label=F, box=F, ratio.tree=1/3.5, font=3, cex.label=.7, cex.symbol=1.4, cex.legend = 1, scale = F, symbol = "squares", var.label= ceiling(befdat$site.order[,57][order(befdat$site.order[,57])]))
dev.off()

# (c) CSP names instead of ages

#mat$comm[mat$comm==0] <- NA

######
## for NewPhyt submission: make node.labels:
## continue here:
csp.phy.143 <- makeNodeLabel(mat$phy, prefix = "N")
plot(csp.phy.143,  show.node.label = T)

plot(csp.phy.143); nodelabels(bg="white")

plot(csp.phy.143,font=1); nodelabels(bg="white")


# write tree into phylocom format
library(picante)
write.tree(csp.phy.143, file = "phycsp143")

## generate sample file:
# should look like this:

#                 Abutilon_theophrasti Acer_campestre Acer_negundo
#Alpine.subalpine                    0              0            0
#Aquatic                             0              0            0
#Cliffs                              0              4            0

# 

writesample(mat$comm, filename = "commcsp143")

# shell command to run nodesig:
oliver@thinkpad-oliver:~/phylocom-4.2$ ./src/phylocom nodesigl -f phycsp143 -s commcsp143 > resultsnodesigcsp.txt

# import results from nodesig analysis

# check whether csp codes are in right order:

nodesig <- read.table("/home/oliver/phylocom-4.2/resultsnodesigcsp.txt", sep = "\t", head = TRUE, row.names = NULL)
colnames(nodesig) <- c("plot", "node", "node_name", "ntaxa", "median", "rank", "sig", "sign")
# select rows (nodes per csp plot) that have significantly more or less taxa decending at that node, than expected by chance:
nodesig.select <- nodesig[nodesig$sign != " ", ]
nodesig.select

write.csv(nodesig.select, file = "nodesig.select.csv")

# plot phylogeny with nodenames

pdf("csp.phy.143.pdf", width = 10, height = 25)
plot(csp.phy.143,  show.node.label = T)
axisPhylo(lwd = 3, lwd.ticks = 2, cex.axis = 2, pos = -2, padj = .5)
mtext("Time (Myr)", at = 65, side = 1, line = 2.3, cex = 2)
dev.off()

##

herb.csp <- phylo4d(mat$phy, (t(mat$comm)^.25))
# orginial: width = 10, height = 21


postscript("phytab.abu.csp.long.eps", width = 10, height = 24, paper = "special", onefile = FALSE, horizontal = FALSE, pointsize=14)
#pdf("phytab.abu.csp.long.pdf", width = 10, height = 21)
phytab <- table.phylo4d(herb.csp, treetype="phylogram", show.node.label=F, box=F, ratio.tree=1/3.3, font=3, cex.label=.61, cex.symbol=1, cex.legend = 1, scale = F, symbol = "squares", center = F)
dev.off()

# with CSP labels
postscript("phytab.abu.csp.long.w.CSP.labels.eps", width = 10, height = 24, paper = "special", onefile = FALSE, horizontal = FALSE, pointsize=14)
#pdf("phytab.abu.csp.long.pdf", width = 10, height = 21)
phytab <- adephylo::table.phylo4d(herb.csp, treetype="phylogram", show.node.label=T, box=F, ratio.tree=1/3.3, font=3, cex.label=.7, cex.symbol=1, cex.legend = 1, scale = F, symbol = "squares", center = F)
dev.off()

########################################################################################
## plot overall phylogenetic turnover (within, between, within+between) in one figure
########################################################################################

cbind.fill <- function (alphalist) {
require(plyr) 
bind <- rbind.fill.matrix(t(as.matrix(as.vector(alphalist[[1]]))))
t(bind)
}

library(psych)

postscript("Turnover_all.eps", width = 3, height = 4, paper = "special", onefile = FALSE, horizontal = FALSE, pointsize=10)
# pdf("Succ.beta.bef.reg.pdf", width = 5.1, height = 3)
par(mfcol=c(2,3), mar=c(0,0,0.0,0.0),oma=c(0.1,4.5,5,0), tcl=.3, las=1, cex = .8)
#for (i in c(1,5,3)){
par(bty = "l")
error.bars(as.vector(befdat$spacodi.temp.PIst.All$Pairwise$All), bar=F, alpha = 0.05, sd = F, pch = 15, arrow.len = .00, lwd = 8, cex = 1.5, axes = FALSE, xlim = c(.5,1.5), ylim = c(-0.0025, 0.0032), main = "", xlab = "", ylab = expression(B[ST]), mgp=c(2.5,0,0))
polygon(y=rep(c(befdat$spacodi.temp.PIst.All$Results[1,4], befdat$spacodi.temp.PIst.All$Results[1,5]), each = 2), x=c(.5:1.5,1.5:.5), col="grey76", border = NA)
error.bars(as.vector(befdat$spacodi.temp.PIst.All$Pairwise$All), bar=F, alpha = 0.05, sd = F, pch = 15, arrow.len = .00, lwd = 3, cex = 1.5, axes = FALSE, xlim = c(.5,1.5), ylim = c(-0.0025, 0.0032), main = "", xlab = "", ylab = expression(B[ST]), mgp=c(2.5,0,0), add = T)
#text(1,52, "a");text(2,52, "b");text(3,52, "c");text(4,52, "c")
abline(h=befdat$spacodi.temp.PIst.All$Results[1,2], lty = 2, lwd = 2)
axis(side = 2, hadj=.75, at = c(-0.0015, 0, 0.0015, 0.003))
#axis(side = 1, 1:5, c("T1","T2","T3","T4","T5"), las = 1)
#text(1.9,55, "Taxonomic", cex = 1.4)
box()
error.bars(as.vector(befdat$spacodi.temp.Bst.All$Pairwise$All), bar=F, alpha = 0.05, sd = F, pch = 15, arrow.len = .00, lwd = 3, cex = 1.5, axes = FALSE, xlim = c(.5,1.5), ylim = c(-0.02, 0.02), main = "", xlab = "", ylab = expression(B[ST]), mgp=c(2.5,0,0))
polygon(y=rep(c(befdat$spacodi.temp.Bst.All$Results[1,4], befdat$spacodi.temp.Bst.All$Results[1,5]), each = 2), x=c(.5:1.5,1.5:.5), col="grey76", border = NA)
error.bars(as.vector(befdat$spacodi.temp.Bst.All$Pairwise$All), bar=F, alpha = 0.05, sd = F, pch = 15, arrow.len = .00, lwd = 3, cex = 1.5, axes = FALSE, xlim = c(.5,1.5), ylim = c(-0.02, 0.02), main = "", xlab = "", ylab = expression(B[ST]), mgp=c(2.5,0,0), add = T)
#text(1,52, "a");text(2,52, "b");text(3,52, "c");text(4,52, "c")
abline(h=befdat$spacodi.temp.Bst.All$Results[1,2], lty = 2, lwd = 2)
axis(side = 2, hadj=.7)
#axis(side = 1, 1:5, c("T1","T2","T3","T4","T5"), las = 1)
#text(1.9,55, "Taxonomic", cex = 1.4)
box()
error.bars(as.vector(befdat$spacodi.temp.PIst.All$Pairwise$Within), bar=F, alpha = 0.05, sd = F, pch = 15, arrow.len = .00, lwd = 3, cex = 1.5, axes = FALSE, xlim = c(.5,1.5), ylim = c(-0.0025, 0.0032), main = "", xlab = "", ylab = "", mgp=c(2.5,0,0))
polygon(y=rep(c(befdat$spacodi.temp.PIst.All$Results[2,4], befdat$spacodi.temp.PIst.All$Results[2,5]), each = 2), x=c(.5:1.5,1.5:.5), col="grey76", border = NA)
error.bars(as.vector(befdat$spacodi.temp.PIst.All$Pairwise$Within), bar=F, alpha = 0.05, sd = F, pch = 15, arrow.len = .00, lwd = 3, cex = 1.5, axes = FALSE, xlim = c(.5,1.5), ylim = c(-0.0025, 0.0032), main = "", xlab = "", ylab = "", mgp=c(2.5,0,0), add = T)
#text(1,52, "a");text(2,52, "b");text(3,52, "c");text(4,52, "c")
abline(h=befdat$spacodi.temp.PIst.All$Results[2,2], lty = 2, lwd = 2)
#axis(side = 2, hadj=.7)
#axis(side = 1, 1:5, c("T1","T2","T3","T4","T5"), las = 1)
#text(1.9,55, "Taxonomic", cex = 1.4)
box()
error.bars(as.vector(befdat$spacodi.temp.Bst.All$Pairwise$Within), bar=F, alpha = 0.05, sd = F, pch = 15, arrow.len = .00, lwd = 3, cex = 1.5, axes = FALSE, xlim = c(.5,1.5), ylim = c(-0.02, 0.02), main = "", xlab = "", ylab = "", mgp=c(2.5,0,0))
polygon(y=rep(c(befdat$spacodi.temp.Bst.All$Results[2,4], befdat$spacodi.temp.Bst.All$Results[2,5]), each = 2), x=c(.5:1.5,1.5:.5), col="grey76", border = NA)
error.bars(as.vector(befdat$spacodi.temp.Bst.All$Pairwise$Within), bar=F, alpha = 0.05, sd = F, pch = 15, arrow.len = .00, lwd = 3, cex = 1.5, axes = FALSE, xlim = c(.5,1.5), ylim = c(-0.02, 0.02), main = "", xlab = "", ylab = "", mgp=c(2.5,0,0), add = T)
#text(1,52, "a");text(2,52, "b");text(3,52, "c");text(4,52, "c")
abline(h=befdat$spacodi.temp.Bst.All$Results[2,2], lty = 2, lwd = 2)
#axis(side = 2, hadj=.7)
#axis(side = 1, 1:5, c("T1","T2","T3","T4","T5"), las = 1)
#text(1.9,55, "Taxonomic", cex = 1.4)
box()
error.bars(as.vector(befdat$spacodi.temp.PIst.All$Pairwise$Between), bar=F, alpha = 0.05, sd = F, pch = 15, arrow.len = .00, lwd = 3, cex = 1.5, axes = FALSE, xlim = c(.5,1.5), ylim = c(-0.0025, 0.0032), main = "", xlab = "", ylab = "", mgp=c(2.5,0,0))
polygon(y=rep(c(befdat$spacodi.temp.PIst.All$Results[3,4], befdat$spacodi.temp.PIst.All$Results[3,5]), each = 2), x=c(.5:1.5,1.5:.5), col="grey76", border = NA)
error.bars(as.vector(befdat$spacodi.temp.PIst.All$Pairwise$Between), bar=F, alpha = 0.05, sd = F, pch = 15, arrow.len = .00, lwd = 3, cex = 1.5, axes = FALSE, xlim = c(.5,1.5), ylim = c(-0.0025, 0.0032), main = "", xlab = "", ylab = "", mgp=c(2.5,0,0), add = T)
#text(1,52, "a");text(2,52, "b");text(3,52, "c");text(4,52, "c")
abline(h=befdat$spacodi.temp.PIst.All$Results[3,2], lty = 2, lwd = 2)
#axis(side = 2, hadj=.7)
#axis(side = 1, 1:5, c("T1","T2","T3","T4","T5"), las = 1)
#text(1.9,55, "Taxonomic", cex = 1.4)
box()
error.bars(as.vector(befdat$spacodi.temp.Bst.All$Pairwise$Between), bar=F, alpha = 0.05, sd = F, pch = 15, arrow.len = .00, lwd = 3, cex = 1.5, axes = FALSE, xlim = c(.5,1.5), ylim = c(-0.02, 0.02), main = "", xlab = "", ylab = "", mgp=c(2.5,0,0))
polygon(y=rep(c(befdat$spacodi.temp.Bst.All$Results[3,4], befdat$spacodi.temp.Bst.All$Results[3,5]), each = 2), x=c(.5:1.5,1.5:.5), col="grey76", border = NA)
error.bars(as.vector(befdat$spacodi.temp.Bst.All$Pairwise$Between), bar=F, alpha = 0.05, sd = F, pch = 15, arrow.len = .00, lwd = 3, cex = 1.5, axes = FALSE, xlim = c(.5,1.5), ylim = c(-0.02, 0.02), main = "", xlab = "", ylab = "", mgp=c(2.5,0,0), add = T)
#text(1,52, "a");text(2,52, "b");text(3,52, "c");text(4,52, "c")
abline(h=befdat$spacodi.temp.Bst.All$Results[3,2], lty = 2, lwd = 2)
#axis(side = 2, hadj=.7)
#axis(side = 1, 1:5, c("T1","T2","T3","T4","T5"), las = 1)
#text(1.9,55, "Taxonomic", cex = 1.4)
box()
mtext(c("Overall", "Spatial", "Temporal"), side=3, outer = T, line=.5, at = c(.16, .5, .82), cex = 1, las=2)
mtext(c(expression(Pi[ST]),expression(B[ST])), side=2, outer = T, line=3.3, at = c(.72,.25), cex = 1, las=3)
#mtext("SES_Beta", side=2, at = .5, outer = T, line=2, las = 3)
dev.off()

#################################


error.bars(as.vector(befdat$spacodi.temp.Bst.All$Pairwise$All), bar=F, alpha = 0.05, sd = F, pch = 15, arrow.len = .00, lwd = 3, cex = 1.2, axes = FALSE, xlim = c(.5,1.5), ylim = c(-0.0025, 0.0032), main = "", xlab = "", ylab = expression(B[ST]), mgp=c(2.5,0,0))
polygon(y=rep(c(befdat$spacodi.temp.Bst.All$Results[1,4], befdat$spacodi.temp.Bst.All$Results[1,5]), each = 2), x=c(.5:1.5,1.5:.5), col="grey76", border = NA)
error.bars(as.vector(befdat$spacodi.temp.Bst.All$Pairwise$All), bar=F, alpha = 0.05, sd = F, pch = 15, arrow.len = .00, lwd = 3, cex = 1.2, axes = FALSE, xlim = c(.5,1.5), ylim = c(-0.0025, 0.0032), main = "", xlab = "", ylab = expression(B[ST]), mgp=c(2.5,0,0), add = T)
#text(1,52, "a");text(2,52, "b");text(3,52, "c");text(4,52, "c")
abline(h=befdat$spacodi.temp.Bst.All$Results[1,2], lty = 2, lwd = 2)
axis(side = 2, hadj=.7)
#axis(side = 1, 1:5, c("T1","T2","T3","T4","T5"), las = 1)
#text(1.9,55, "Taxonomic", cex = 1.4)
box()

error.bars(as.vector(befdat$spacodi.temp.Bst.All$Pairwise$Within), bar=F, alpha = 0.05, sd = F, pch = 15, arrow.len = .00, lwd = 3, cex = 1.2, axes = FALSE, xlim = c(.5,1.5), ylim = c(-0.0025, 0.0032), main = "", xlab = "", ylab = "", mgp=c(2.5,0,0))
polygon(y=rep(c(befdat$spacodi.temp.Bst.All$Results[2,4], befdat$spacodi.temp.Bst.All$Results[2,5]), each = 2), x=c(.5:1.5,1.5:.5), col="grey76", border = NA)
error.bars(as.vector(befdat$spacodi.temp.Bst.All$Pairwise$Within), bar=F, alpha = 0.05, sd = F, pch = 15, arrow.len = .00, lwd = 3, cex = 1.2, axes = FALSE, xlim = c(.5,1.5), ylim = c(-0.0025, 0.0032), main = "", xlab = "", ylab = "", mgp=c(2.5,0,0), add = T)
#text(1,52, "a");text(2,52, "b");text(3,52, "c");text(4,52, "c")
abline(h=befdat$spacodi.temp.Bst.All$Results[2,2], lty = 2, lwd = 2)
#axis(side = 2, hadj=.7)
#axis(side = 1, 1:5, c("T1","T2","T3","T4","T5"), las = 1)
#text(1.9,55, "Taxonomic", cex = 1.4)
box()

error.bars(as.vector(befdat$spacodi.temp.Bst.All$Pairwise$Between), bar=F, alpha = 0.05, sd = F, pch = 15, arrow.len = .00, lwd = 3, cex = 1.2, axes = FALSE, xlim = c(.5,1.5), ylim = c(-0.0025, 0.0032), main = "", xlab = "", ylab = "", mgp=c(2.5,0,0))
polygon(y=rep(c(befdat$spacodi.temp.Bst.All$Results[3,4], befdat$spacodi.temp.Bst.All$Results[3,5]), each = 2), x=c(.5:1.5,1.5:.5), col="grey76", border = NA)
error.bars(as.vector(befdat$spacodi.temp.Bst.All$Pairwise$Between), bar=F, alpha = 0.05, sd = F, pch = 15, arrow.len = .00, lwd = 3, cex = 1.2, axes = FALSE, xlim = c(.5,1.5), ylim = c(-0.0025, 0.0032), main = "", xlab = "", ylab = "", mgp=c(2.5,0,0), add = T)
#text(1,52, "a");text(2,52, "b");text(3,52, "c");text(4,52, "c")
abline(h=befdat$spacodi.temp.Bst.All$Results[3,2], lty = 2, lwd = 2)
#axis(side = 2, hadj=.7)
#axis(side = 1, 1:5, c("T1","T2","T3","T4","T5"), las = 1)
#text(1.9,55, "Taxonomic", cex = 1.4)
box()





mtext("Successional stage (Years)", side=1, outer = T, line=4, at = .54, cex = .8)
#mtext("(a) Taxonomic", side=3, at = .152, outer = T, line=.4, cex = .9)
#mtext("(b) Phylogenetic", side=3, at = .494, outer = T, line=.4, cex = .9)
#mtext("(c) Functional", side=3, at = .815, outer = T, line=.4, cex = .9)
dev.off()





########################################################################################


# taxonomic evenness

# pdf("Tax.Phyl.eveness.pdf", width = 8.5, height = 3)
postscript("Tax.Phyl.eveness.eps", width = 8.5, height = 3, paper = "special", onefile = FALSE, horizontal = FALSE, pointsize=14)

par(mfrow = c(1,2))

eve <- as.data.frame(diversity(t(befdat$com.order.143), "shannon")/log(specnumber(t(befdat$com.order.143))))
site.order <- befdat$site.order
car <- c("16", "19", "20", "22", "26", "17", "23", "24", "25", "01" , "03" , "06",  "07" , "08" ,"11", "13" , "05" , "09" ,"10" ,"18" , "02" ,"15",  "04", "12", "14", "21", "27")
rownames(site.order) <- paste("CSP",car, sep = "")
mer <- merge(site.order[,c(58:59)], eve, by = "row.names")
mer2 <- mer[order(mer[,3]),]
agg <- aggregate(mer2[,4]~age_HB, data = mer2, FUN = mean)
plot(agg$age_HB, agg[,2], main = "Tax.Even.Simpson")

dev.off()

li <- list(T1=mer2[1:5,4], T2=mer2[6:9,4], T3=mer2[10:14,4], T4=mer2[15:20,4], T5=mer2[21:27,4])

cbind.fill <- function (alphalist) {
require(plyr) 
bind <- rbind.fill.matrix(t(as.matrix(as.vector(alphalist[[1]]))), t(as.matrix(as.vector(alphalist[[2]]))) ,t(as.matrix(as.vector(alphalist[[3]]))), t(as.matrix(as.vector(alphalist[[4]]))), t(as.matrix(as.vector(alphalist[[5]]))))
t(bind)
}


postscript("Succ.shannon.eps", width = 2.3, height = 2.6, paper = "special", onefile = FALSE, horizontal = FALSE, pointsize=12)
#pdf("Succ.alpha.rare.pdf", width = 6.5, height = 2.6)
par(mar=c(0,3.8,0.5,.6),oma=c(5.2,0,1.6,0), tcl=.3, las=1, cex = .75)
#for (i in c(1,5,3)){
par(bty = "l")
error.bars(cbind.fill(li), bar=F, alpha = 0.05, sd = F, pch = 15, arrow.len = .0, lwd = 3, cex = 1.2, axes = FALSE, xlim = c(0.9,5.2), ylim = c(0.45,.87), main = "", xlab = "", ylab = "Shannon evenness", mgp=c(2,0,0))
text(4,.5, "R² = 0.35 **")
abline(lm(mer2[,4] ~ mer2[,3]), lty = 1)
axis(side = 2, hadj=.5)
axis(side = 1, 1:5, c("T1","T2","T3","T4","T5"), las = 1)                                    #text(1.9,55, "Taxonomic", cex = 1.4
box()
dev.off()

summary(lm(mer2[,4] ~ mer2[,3]))

# spacodi.treeplot

# spacodi.treeplot(spacodi.permutations, phy, cex=list(pch = 1.5, tip = 0.5, legend = 0.75), transp=0.8, sig.plot = TRUE, cut.off = 0.05, cols = list("white", "gray", "black"), main = TRUE, outfile = NULL, add.id = FALSE, ...)

mat <- match.phylo.comm(befdat$phy.143.ultra, t(befdat$com.order.143))

PI=spacodi.by.nodes(sp.plot=t(mat$comm[19:27,]), sp.parm="PIst", phy=mat$phy, return.all=TRUE, method="1s")
spacodi.treeplot(PI, mat$phy, sig.plot=TRUE, cex=list(pch = 1.5, tip = 0.3, legend = 0.75), add.id=FALSE, outfile = "T3.PIst.sig.pdf")
   

# calculate Haed (Cadotte, 2010 Ecol Lett)

pd, hed, haed, iac, pae

phycom143 <- phylo4com(befdat$phy.143.ultra, befdat$com.order.143)
       
h.com143 <- pae(phycom143)
h.com143 <- h.com143[names(befdat$com.order)]
h.age <- cbind(befdat$site.order[,59], h.com143)
colnames(h.age) <- c("age", "h")
alpha <- cbind(alpha, h.age)

alpha <- alpha[,-c(3,5,7,9)]
colnames(alpha) <- c("Age","PD", "HED", "HAED", "IAC", "PAE")

befdat$AlphaCad <- alpha

agg <- aggregate(h~age, data = h.age, FUN = mean)
     
mntd.abu <- mpd(t(befdat$com.order.143), cophenetic(befdat$phy.143.ultra), abundance.weighted=TRUE)
names(mntd.abu) <- colnames(befdat$com.order.143)
mntd.abu <- mntd.abu[names(befdat$com.order)]
mntd.age <- cbind(befdat$site.order[,59], mntd.abu)
colnames(mntd.age) <- c("age", "h")
boxplot(h ~ age, data = mntd.age)
        
pdf("AlphaCadotte.pdf", width = 12, height = 3)
par(mfrow=c(1,5))
for (i in 2:6){
boxplot(alpha[,i] ~ Age, data = alpha, xlab = "Stage", ylab = colnames(alpha)[i], main =colnames(alpha)[i])
}
dev.off()

# calculate Bst and PIst in each of successional classes (age_HB)

colnames(befdat$com.order.143)



## Jost correction for Pst

Pstcorr <- function (alpha, gamma){
  alphacorr <- 1/(1-alpha)
  gammacorr <- 1/(1-gamma)
  Pst.corr <- (gammacorr-alphacorr)/gammacorr
  Pst.corr
}

Pstcorr(alpha = 0.9059, gamma = 0.9605)

###########################
# PD variables for Karin
#############################

# "phy.147.ultra", "phy.143.ultra", "phy.147.ml","phy.143.ml"    
befdat$phy.147.ultra$tip.label[befdat$phy.147.ultra$tip.label %in% befdat$phy.143.ultra$tip.label==F]

Diospyros_japonica"            "Cornus_kousa_subsp._chinensis"
 [7] "Serissa_serissoides"           "Quercus_phillyreoides"        
 [9] "Cyclobalanopsis_myrsinaefolia" "Photinia_hirsuta"             
[11] "Laurocerasus_spinulosa"        "Prunus_campanulata

befdat$phy.147.ultra$tip.label[befdat$phy.147.ultra$tip.label=="Diospyros_japonica"] <- "Diospyros_glaucifolia"
befdat$phy.147.ultra$tip.label[befdat$phy.147.ultra$tip.label=="Cornus_kousa_subsp._chinensis"] <- "Cornus_kousa"
befdat$phy.147.ultra$tip.label[befdat$phy.147.ultra$tip.label=="Serissa_serissoides"] <- "Serissa_foetida"
befdat$phy.147.ultra$tip.label[befdat$phy.147.ultra$tip.label=="Quercus_phillyreoides"] <- "Quercus_phillyraeoides"
befdat$phy.147.ultra$tip.label[befdat$phy.147.ultra$tip.label=="Cyclobalanopsis_myrsinaefolia"] <- "Quercus_myrsinifolia"
befdat$phy.147.ultra$tip.label[befdat$phy.147.ultra$tip.label=="Photinia_hirsuta"] <- "Pourthiaea_hirsuta"
befdat$phy.147.ultra$tip.label[befdat$phy.147.ultra$tip.label=="Laurocerasus_spinulosa"] <- "Prunus_spinulosa"
befdat$phy.147.ultra$tip.label[befdat$phy.147.ultra$tip.label=="Prunus_campanulata"] <- "Cerasus_campanulata"


# MPD
mat <- match.phylo.comm(befdat$phy.143.ultra, t(befdat$com.order))
mat$phy$edge.length <- mat$phy$edge.length+.001

ultra.mpd.143.abu <- mpd(mat$comm, cophenetic(mat$phy), abundance.weighted=TRUE)
ultra.mpd.143.pa <- mpd(mat$comm, cophenetic(mat$phy), abundance.weighted=FALSE)

# PD
ultra.pd.143 <- picante::pd(mat$comm, mat$phy)

# Rao.divc
ultra.rao.143.abu.divc <- divc(as.data.frame(t(mat$comm)), as.dist(cophenetic(mat$phy)), scale = T)
ultra.rao.143.pa.divc <- divc(decostand(as.data.frame(t(mat$comm)), "pa"), as.dist(cophenetic(mat$phy)), scale = T)   

cor(ultra.rao.143.abu.divc$diversity, ultra.rao.143.pa.divc$diversity)

# Rao.picante
ultra.rao.143.abu.picante <- raoD(mat$comm, mat$phy)$Dkk
ultra.rao.143.pa.picante <- raoD(decostand(mat$comm, "pa"), mat$phy)$Dkk

cor(ultra.rao.143.abu.picante, ultra.rao.143.pa.picante)

# Rao taxondiver

ultra.rao.143.taxdiv <- taxondive(mat$comm, dis = cophenetic(mat$phy))[c(1:3,5)]

##
PDmat.Anne <- cbind(ultra.pd.143[,2], ultra.pd.143[,1], ultra.rao.143.pa.picante, ultra.rao.143.abu.picante, ultra.rao.143.taxdiv[[3]], ultra.rao.143.taxdiv[[4]], 

ultra.pd.147[,2],ultra.pd.147[,1], ultra.rao.147.pa.picante, ultra.rao.147.abu.picante, ultra.rao.147.taxdiv[[3]], ultra.rao.147.taxdiv[[4]])

colnames(PDmat.Anne) <- c("SR.angio", "PD.angio","Rao.angio.pa", "Rao.angio.abu", "Dstar.angio", "Dplus.angio", 

"SR.all", "PD.all","Rao.all.pa", "Rao.all.abu", "Dstar.all", "Dplus.all")

# save data

PDmetrics.CSP <- list()

PDmetrics.CSP$PD.alpha.CSP <- PDmat.Anne

PDmetrics.CSP$SpecList.angio <- sort(befdat$phy.143.ultra$tip.label)
PDmetrics.CSP$SpecList.all <- sort(befdat$phy.147.ultra$tip.label)


save(PDmetrics.CSP, file = "PDmetrics.CSP.Rdata")

# plot correlations

pdf("cor.PD.alpha.CSP.pdf", width = 15, height = 15)
pairs(PDmetrics.CSP$PD.alpha.CSP, lower.panel = panel.smooth, upper.panel = panel.cor, diag.panel = panel.hist)
dev.off()


# ? PD abundance-based

PDmat <- cbind(ultra.pd.147, ultra.pd.147[,1], ultra.pd.143[,1], ultra.mpd.147, ultra.mpd.143, ultra.pd.147[,1], ultra.pd.143[,1], ultra.mpd.147, ultra.mpd.143)

PDmat <- PDmat[,-1]

colnames(PDmat) <- c("SR","PD.147.ultra","PD.143.ultra","MPD.147.ultra","MPD.143.ultra","PD.147.ultra","PD.143.ultra","MPD.147.ultra","MPD.143.ultra")

save(PDmat, file = "PD_Karin.Rdata")

befdat$PD <- PDmat

pdf("PDcor.pdf", width = 13, height = 13)
CorTestPlot(PDmat)
dev.off()

#####################################################

#ses.all <- ses.mpd(samp = mat$comm, dis = cophenetic(mat$phy), null.model = "independentswap", abundance.weighted = TRUE, runs = 999, iterations = 1000)
dat <- cbind(ses.all[, c(1,2,6)], befdat$site.order[, c(10,58,59)])


mpd(phylocom$sample, cophenetic(phylocom$phylo), abundance.weighted=TRUE)
pd(phylocom$sample, phylocom$phylo)


# import data community data
com120 <- read.csv(paste(path.species, "BEFChinaAbu120.csv", sep = ""), sep = "\t", row.names = 1)
com148 <- read.csv(paste(path.species, "BEFChinaAbu148.csv", sep = ""), sep = "\t", row.names = 1)
com148[is.na(com148)] <- 0

## site characteristics
site.all <- read.csv(paste(path.site, "CSP_4ALL5_HB.csv", sep = ""), sep = "\t", row.names = 2)
site.all$Tree_age_cat <- ordered(site.all$Tree_age_cat, levels = c("early","mid","late"))

# order community and site data according to "Tree_age_cat"

site.order <- site.all[order(site.all$Tree_age_cat),]
com.order <- befdat$com148[,match(rownames(site.order), colnames(befdat$com148))]

match(rownames(site.order), colnames(com.order))

befdat$com.order <- com.order
befdat$site.order <- site.order
    
## phylogenetic data

phy.full.ultra <- read.tree(paste(path.phylo, "Final_BEF_phylo_nprs.tre", sep = ""))
phy.full.ml <- read.tree(paste(path.phylo, "Final_BEF_phylo_ml2.tre", sep = ""))

phy.full.ultra.syn_sm <- read.tree(paste(path.phylo, "phy.full.ultra.syn_sm.tre", sep = ""))


pdf("phy143ultra.pdf", width = 8, height = 8.5)
plot(befdat$phy.143.ultra, type = "f", cex = .5)
dev.off()

postscript("phy.143.ultra.eps", width = 8, height = 8.5)
plot(befdat$phy.143.ultra, type = "f", cex = .5)
dev.off()

rownames(com148) <- gsub(" ", "_", rownames(com148))
rownames(com120) <- gsub(" ", "_", rownames(com120))

rownames(com148)[rownames(com148) %in%  phy.148.ultra$tip.label==FALSE]
rownames(com120)[rownames(com120) %in%  phy.120.ultra$tip.label==FALSE]

# 1 # syncronize synonyms in com148 and phylogeny
# 15 species 

# name in comm. data - name in phylogeny

"Acer_pubipalmatum"  - no synomyn     x       
"Cornus_kousa_subsp._chinensis" - "Cornus_kousa" x
"Cyclobalanopsis_myrsinaefolia" - "Quercus_myrsinifolia" x
"Diospyros_japonica" - "Diospyros_glaucifolia" x      
"Diospyros_kaki" -  ???          
"Ilex_chinensis"   -    "Ilex_purpurea"  x      
"Ilex_litseifolia"    -    "Ilex_litseafolia" x
"Laurocerasus_spinulosa"   -    "Prunus_spinulosa"
"Photinia_hirsuta"    - ???     
"Prunus_campanulata"   -   "Cerasus_campanulata"      
"Prunus_discoides"   -    "Prunus_discoidea"    
"Quercus_phillyreoides"  -    "Quercus_phillyraeoides"  
"Sapium_japonicum"     -     "Sapium_japonica"
"Serissa_serissoides"   -   "Serissa_foetida"    
"Vaccinium_mandarinorum"  -   "Vacciunium_mandarimorum"

# also missing: "Ilex_chinensis"

# ?! what about Ilex chinensis and I. purpurea?? should be the same species but here it it is listed twice/separately in the com148 -data
# here i have excluded ilex chinensis

phy.full.ml$tip.label[phy.full.ml$tip.label=="Vacciunium_mandarimorum"] <- "Vaccinium_mandarinorum"
phy.full.ml$tip.label[phy.full.ml$tip.label=="Cornus_kousa"] <- "Cornus_kousa_subsp._chinensis"
phy.full.ml$tip.label[phy.full.ml$tip.label=="Quercus_myrsinifolia"] <- "Cyclobalanopsis_myrsinaefolia"
phy.full.ml$tip.label[phy.full.ml$tip.label=="Diospyros_glaucifolia"] <- "Diospyros_japonica"
phy.full.ml$tip.label[phy.full.ml$tip.label=="Ilex_chinensis"] <- "Ilex_purpurea"
phy.full.ml$tip.label[phy.full.ml$tip.label=="Ilex_litseafolia"] <- "Ilex_litseifolia"
phy.full.ml$tip.label[phy.full.ml$tip.label=="Prunus_spinulosa"] <- "Laurocerasus_spinulosa"
phy.full.ml$tip.label[phy.full.ml$tip.label=="Cerasus_campanulata"] <- "Prunus_campanulata"
phy.full.ml$tip.label[phy.full.ml$tip.label=="Prunus_discoidea"] <- "Prunus_discoides"
phy.full.ml$tip.label[phy.full.ml$tip.label=="Quercus_phillyraeoides"] <- "Quercus_phillyreoides"
phy.full.ml$tip.label[phy.full.ml$tip.label=="Sapium_japonica"] <- "Sapium_japonicum"
phy.full.ml$tip.label[phy.full.ml$tip.label=="Serissa_foetida"] <- "Serissa_serissoides"

phy.full.ml$tip.label[phy.full.ml$tip.label=="Pourthiaea_hirsuta"] <- "Photinia_hirsuta"

##########
befdat$phy.full.ml <- phy.full.ml
phy.147.ml <- prune.sample(t(befdat$com.order),befdat$phy.full.ml)
# check for missing species in the phylogeny
rownames(befdat$com.order)[rownames(befdat$com.order) %in%  phy.147.ml$tip.label==FALSE]

phy.143.ml <- prune.sample(t(befdat$com.order.143), befdat$phy.full.ml)

befdat$phy.147.ml <- phy.147.ml
befdat$phy.143.ml <- phy.143.ml

pdf("phy.147.ml.fan.pdf", width = 8, height = 8.5)
plot(befdat$phy.147.ml, type = "f", cex = .4, label.offset = .005)
dev.off()

pdf("phy.147.ml.pdf", width = 8, height = 12)
plot(befdat$phy.147.ml, type = "p", cex = .35, label.offset = .002)
dev.off()

pdf("phy.143.ml.fan.pdf", width = 8, height = 8.5)
plot(befdat$phy.143.ml, type = "f", cex = .35, label.offset = .005)
dev.off()

pdf("phy.143.ml.pdf", width = 8, height = 12)
plot(befdat$phy.143.ml, type = "p", cex = .35, label.offset = .002)
dev.off()

# names still to syncronize in com120-data:
rownames(befdat$com120) <- gsub(" ", "_", rownames(befdat$com120))
phy.120.ultra <- prune.sample(t(befdat$com120), befdat$phy.full.ultra.syn)
rownames(befdat$com120)[rownames(befdat$com120) %in%  phy.120.ultra$tip.label==FALSE]
#[1] "Camellia_chekiang-oleosa" "Cornus_kousa"            
#[3] "Diospyros_kaki"           "Lauracerasus_spinulosa"  
#[5] "Photinia_hirsuta"         "Rhododendron_latouchea"  
#[7] "Styrax_odoratissima"      "Symplocos_olongifolia"


# contains the same synonyms as in Walters abundance data set
befdat$phy.full.ultra.syn <- phy.full.ultra.syn_sm

# still to resolve: 
# [1] "Acer_pubipalmatum" "Diospyros_kaki"    "Ilex_chinensis"   
# [4] "Photinia_hirsuta" 

# prune full phylogeny to comm. 148 data
rownames(befdat$com148) <- gsub(" ", "_", rownames(befdat$com148))
phy.148.ultra <- prune.sample(t(befdat$com148),befdat$phy.full.ultra.syn)
# still missing / to resolve: 
# [1] "Acer_pubipalmatum" "Diospyros_kaki"    "Ilex_chinensis" (maybe synonym of I. purpurea?)  
# [4] "Photinia_hirsuta" 

befdat$phy.148.ultra <- phy.148.ultra

write.tree(befdat$phy.full.ultra.syn, file = "phy.full.ultra.syn.tre")

write.tree(befdat$phy.147.ultra, file = "phy.147.ultra.tre")
write.tree(befdat$phy.143.ultra, file = "phy.143.ultra.tre")

########### harmonize 
# 0) import phylo 435 and guatianshan abundance
abu.gut <- read.csv(paste(path.species, "Gutianshan_species_list_abundances_woody_OP2.csv", sep = ""), sep = ",", row.names = 1, dec = ",")
abu.gut.438 <- abu.gut[-439,c(1,5,9,10)]

befdat$abu.gut.438 <- abu.gut.438
save(befdat, file = paste(path.data,"befdat.Rdata", sep = ""))

phy.gut.ml <- read.tree(paste(path.phylo, "Final_BEF_phylo_ml_438taxa.tre", sep = ""))
phy.gut.nprs <- read.tree(paste(path.phylo, "Final_BEF_phylo_nprs_438taxa.tre", sep = ""))

befdat$phy.gut.ml <- phy.gut.ml
befdat$phy.gut.nprs <- phy.gut.nprs

pdf("phy.438.ml.pdf", width = 8, height = 8.5)
plot(phy.gut.ml, type = "f", cex = .2)
dev.off()
                                        
# 1) include kaki and acer in walters baum (done)

# 1.1) exclude gynmosperms
phy.gut.ultra.nongymno <- drop.tip(phy.gut.nprs, 1:15)
phy.gut.ml.nongymno <- drop.tip(phy.gut.ml, 1:15)

# exclude the following gymnos. + the bamboo 'Pleioblastus_amarus':

# [1] "Pseudolarix_kaempferi"   "Pinus_massoniana"       
# [3] "Pinus_taiwanensis"       "Podocarpus_nagi"        
# [5] "Podocarpus_macrophyllus" "Cephalotaxus_fortunei"  
# [7] "Cephalotaxus_sinensis"   "Torreya_grandis"        
# [9] "Taxus_chinensis"         "Cunninghamia_lanceolata"
#[11] "Juniperus_formosana"     "Juniperus_chinensis"    
#[13] "Cryptomeria_fortunei"    "Taxodium_distichum"     
#[15] "Pleioblastus_amarus"

pdf("phygutultranongymnocult.pdf", width = 8, height = 8.5)
plot(befdat$phy.gut.ultra.nongymnocult, type = "f", cex = .25)
dev.off()

pdf("phygutmlnongymnocult.pdf", width = 8, height = 8.5)
plot(befdat$phy.gut.ml.nongymnocult, type = "f", cex = .2)
dev.off()

pdf("phy.143.ml.pdf", width = 8, height = 8.5)
plot(befdat$phy.143.ml, type = "f", cex = .3)
dev.off()


# 1.2) exclude cultivated species

rownames(befdat$abu.gut.438) <- gsub(" ", "_", rownames(befdat$abu.gut.438))

phy.gut.ultra.nongymnocult <- drop.tip(phy.gut.ultra.nongymno, rownames(befdat$abu.gut.438)[is.na(befdat$abu.gut.438[,4])])
phy.gut.ml.nongymnocult <- drop.tip(phy.gut.ml.nongymno, rownames(befdat$abu.gut.438)[is.na(befdat$abu.gut.438[,4])])


# !! continue here
# 1.3) add abundance classes for kaki and acer to abu.gut
abu.gut.410 <- befdat$abu.gut.438[phy.gut.ultra.nongymnocult$tip.label,]

befdat$phy.gut.ultra.nongymnocult <- phy.gut.ultra.nongymnocult
befdat$phy.gut.ml.nongymnocult <- phy.gut.ml.nongymnocult



befdat$abu.gut.410 <- abu.gut.410

rownames(befdat$abu.gut.410) %in% phy.gut.ml.nongymnocult$tip.label

match(rownames(abu.gut.410), phy.gut.ultra.nongymnocult$tip.label)

# 2) keep synonym from phylogeny/change in abundance data

rownames(befdat$com.order)[rownames(befdat$com.order) %in%  befdat$phy.gut.ultra.nongymnocult$tip.label==FALSE]

# [1] "Cephalotaxus_fortunei"         "Cornus_kousa_subsp._chinensis"
# [3] "Cunninghamia_lanceolata"       "Cyclobalanopsis_myrsinaefolia"
# [5] "Laurocerasus_spinulosa"        "Photinia_hirsuta"             
# [7] "Pinus_massoniana"              "Pinus_taiwanensis"            
# [9] "Prunus_campanulata"            "Quercus_phillyreoides"        
#[11] "Serissa_serissoides"           "Symplocos_oblongifolia"

rownames(befdat$com.order)[rownames(befdat$com.order)=="Cornus_kousa_subsp._chinensis"] <- "Cornus_kousa"
rownames(befdat$com.order)[rownames(befdat$com.order)=="Cyclobalanopsis_myrsinaefolia"] <- "Quercus_myrsinifolia"
rownames(befdat$com.order)[rownames(befdat$com.order)=="Diospyros_japonica"] <- "Diospyros_glaucifolia"
rownames(befdat$com.order)[rownames(befdat$com.order)=="Laurocerasus_spinulosa"] <- "Prunus_spinulosa"
rownames(befdat$com.order)[rownames(befdat$com.order)=="Photinia_hirsuta"] <- "Pourthiaea_hirsuta"
rownames(befdat$com.order)[rownames(befdat$com.order)=="Prunus_campanulata"] <-"Cerasus_campanulata"
rownames(befdat$com.order)[rownames(befdat$com.order)=="Quercus_phillyreoides"] <-"Quercus_phillyraeoides"
rownames(befdat$com.order)[rownames(befdat$com.order)=="Serissa_serissoides"] <-"Serissa_foetida"
 
# ask Walter about "Symplocos_oblongifolia", add manually to the tree

# !! Continue here!!
# !add manually to the tree

spa.apd <- spacodi.calc(sp.plot = sp.plot, phy = befdat$phy.gut.ultra.nongymnocult)

rownames(sp.plot) <- rownames(befdat$abu.gut.410)

phylosignal(scale(as.vector(sp.plot[,1])), befdat$phy.gut.ultra.nongymnocult)

phylosig(tree = befdat$phy.gut.ultra.nongymnocult,x = as.vector(sp.plot[,1]), method="lambda", test=TRUE)

# temporal distance (continuous, with dimnames in the same order as the site.names in commnunity data)

time.dist.cont.all <- dist(befdat$site.order[,57])

attr(time.dist.cont.all, "Labels") <- rownames(befdat$site.order)

# export com data and phylo.143 and phylo.410 ultrametric trees

write.tree(befdat$phy.gut.ml.nongymnocult, file = "phy.410.ml.txt")

mat <- match.phylo.comm(phy=befdat$phy.gut.ultra.nongymnocult, comm=t(befdat$com.order))

befdat$phy.143.ultra <- mat$phy

write.tree(mat$phy, file = "phy.143.ultra.txt")


com <- t(mat$comm)

com.1 <- com[,befdat$site.order[,59]==1]
com.2 <- com[,befdat$site.order[,59]==2]
com.3 <- com[,befdat$site.order[,59]==3]
com.4 <- com[,befdat$site.order[,59]==4]
com.5 <- com[,befdat$site.order[,59]==5]

write.table(com.5, file = "com.5.txt", sep = "\t", col.names = NA, quote = FALSE)

# PCNM analysis

quick.1 <- quickPCNM(decostand(t(befdat$com.order), "hellinger"), befdat$site.order[,70:71])
summary(quick.1)
   
 
# A. Usual case with defaut settings; works well in most situations
     quick.1 <- quickPCNM(as.matrix(dist(mite.hel)), mite.xy)
     summary(quick.1)
 
# run adonis 

phy.lor <- drop.tip(befdat$phy.143.ultra, "Loropetalum_chinense")

mat <- match.phylo.comm(phy=befdat$phy.143.ultra, comm=t(befdat$com.order))

mat.lor <- match.phylo.comm(phy=phy.lor, comm=t(befdat$com.order))


befdat$site.order$age_HB <- as.factor(befdat$site.order$age_HB)

spa.pi.1 <- spacodi.calc(sp.plot = t(mat$comm), phy = mat$phy, prune = TRUE, pairwise = TRUE)[[6]]
adonis(as.dist(spa.pi.1+1) ~ age_HB*Elevation, data=befdat$site.order, permutations=999)  
mod <- metaMDS(as.dist(spa.pi.1+1))
     plot(mod)
     ### Hulls show treatment
     ordihull(mod, group=befdat$site.order$age_HB, show="1")
     ordihull(mod, group=befdat$site.order$age_HB, show="2", col = "red")
     ordihull(mod, group=befdat$site.order$age_HB, show="3", col = "green")
     ordihull(mod, group=befdat$site.order$age_HB, show="4", col = "blue")
     ordihull(mod, group=befdat$site.order$age_HB, show="5", col = "gray")
    
ordispider(mod, group=befdat$site.order$age_HB, lty=3, col="red")

# run betadisper

spa.pi.1 <- spacodi.calc(sp.plot = t(mat$comm), phy = mat$phy, prune = TRUE, pairwise = TRUE)[[8]]

mod <- betadisper(as.dist(spa.pi.1+1), befdat$site.order$age_HB)

# create env. distances:
# env.dist <- dist(scale(befdat$site.order[,c(3,19,45,60,62,63,65)]))
# mod <- betadisper(env.dist, befdat$site.order$age_HB)

mod  
 ## Perform test
     anova(mod)
     
     ## Permutation test for F
     permutest(mod, pairwise = TRUE)

     ## Tukey's Honest Significant Differences
     (mod.HSD <- TukeyHSD(mod))

     plot(mod.HSD)
     ## Plot the groups and distances to centroids on the
     ## first two PCoA axes
     plot(mod)
     
     ## can also specify which axes to plot, ordering respected
     plot(mod, axes = c(3,1))
     
     ## Draw a boxplot of the distances to centroid for each group
     boxplot(mod)

# plot spacodi.by.nodes for PIst

simpleRDA2 <- vegan:::simpleRDA2

 quick.1 <- quickPCNM(befdat$Alpha[,2], befdat$site.order[,c(70,71)], alpha=0.7)
     summary(quick.1)

 quick.1 <- quickPCNM(mat$comm, befdat$site.order[,c(70,71)], alpha=0.9)

quick.1 <- forward.sel(befdat$Alpha[,3], befdat$site.order[,c(3,9,19,45,57,60,62,63,65,70,71)], alpha=0.05)
quick.1


quick.1 <- forward.sel(befdat$Alpha[,4], befdat$site.order[,-c(17,36,37,58,59,64)], alpha=0.05)
quick.1

quick.1 <- forward.sel(befdat$Alpha[,2], befdat$site.order[,18:30], alpha=0.1)
quick.1

#colnames(befdat$Alpha)
# [1] "SR"    "Dpw"   "Dstar" "Delta" "Age"   "PD"    "HED"   "HAED"  "IAC"  
#[10] "PAE"  

summary(step(lm(befdat$Alpha[,4] ~ Elevation+Inclination+Open_soil+Soil_moisture+Tree_age_max5+pH+N+C+C_N, data = befdat$site.order)))

# Calculated taxonomic distinctness


taxdiv <- taxondive(mat$comm, dis = cophenetic(mat$phy))[c(1:3,5)]

Alpha <- cbind(taxdiv[[1]], taxdiv[[2]], taxdiv[[3]], taxdiv[[4]])

colnames(Alpha) <- c("SR", "Dpw", "Dstar", "Delta")

Alpha <- cbind(Alpha, befdat$AlphaCad)

befdat$Alpha <- as.data.frame(Alpha)

# 
# taxa.labels, sample.pool, phylogeny.pool

# test whether taxa.label gives different results for depending on whether local or regional phylogeny is taken: yes it does

ses.mpd(mat$comm, cophenetic(befdat$phy.gut.ultra.nongymnocult), null.model="taxa.labels", abundance.weighted = TRUE)

ses.mpd(mat$comm, cophenetic(mat$phy),null.model="taxa.labels")

# rewrite null-model function for "D.PD.step5" for "taxaShuffle" (picante) to account for different species pool sizes

###############################################

##################
# 1) Null models #
##################

########################
# 1.1) Alpha diversity #
########################

########################
# 1.1.1 global, within stages
########################

nullmod <- "taxaShuffle"
com <- mat$comm
dis <- cophenetic(mat$phy)
value <- 8

# value: 2 - D (Dpw), 3 - Dstar (Dp*w), 5 - Dplus (DELTApw)

D.PD.step5.picante <- function(com, dis, value, nullmod, runs){  
  results <- matrix(NA, nrow = 5, ncol = 8)  
  alpha <- list("T1","T2","T3","T4","T5") # list because it should hold objects of varying length
  names(alpha) <- c("T1","T2","T3","T4","T5")  
  alpha.shuff <- function(com, runs){
  Res = NA
  for (r in 1:runs) {        
    Res <- c(Res, mean(taxondive(com, eval(parse(text=nullmod))(dis), match.force = TRUE)[[value]])) 
  }
  return(Res)
}  
for (i in 1:5){      
  obs <- taxondive(com[befdat$site.order[,59]==i,], dis = dis, match.force = TRUE) # single obsversed MPD value  
  obs.val <- mean(obs[[value]])/2    
  resamp <- (alpha.shuff(com = com[befdat$site.order[,59]==i,], runs = runs))/2
  resamp[1] <- obs.val
  obs.rank <- rank(resamp)[1]
  results[i,1] <- obs.val
  results[i,2] <- mean(resamp[2:(runs+1)], na.rm = TRUE)
  results[i,3] <- sd(resamp[2:(runs+1)], na.rm = TRUE)
  results[i,4] <- quantile(resamp[2:(runs+1)],  probs = c(2.5, 97.5)/100)[1]
  results[i,5] <- quantile(resamp[2:(runs+1)],  probs = c(2.5, 97.5)/100)[2]
  results[i,6] <- obs.rank/(runs+1) ## P(1-sided test, H1: obs<exp)
  results[i,7] <- 1-(obs.rank/(runs+1)) ## P(1-sided test, H1: obs>exp)
  results[i,8] <- (1-(obs.rank/(runs+1)))*2 ## P(2-sided test, H1: obs<>exp)
dimnames(results) <- list(c("T1", "T2", "T3", "T4", "T5"), c(names(obs)[value],"rand.mean","rand.sd","2.5%","97.5%","P.obs<exp","P.obs>exp","P.obs<>exp"))
  alpha[[i]] <- obs[[value]]/2
}
  return(list(Results = results, Alpha = alpha))
}

# ex
dis <- cophenetic(mat$phy)
befdat$Succ.alpha.Dpw <- D.PD.step5.picante(com = com, dis = dis, nullmod = "taxaShuffle", value=2, runs = 999)
befdat$Succ.alpha.Dstar <- D.PD.step5.picante(com = com, dis = dis, nullmod = "taxaShuffle", value=3, runs = 999)
befdat$Succ.alpha.Dplus <- D.PD.step5.picante(com = com, dis = dis, nullmod = "taxaShuffle", value=5, runs = 999)
save(befdat, file = paste(path.data,"befdat.Rdata", sep = ""))

# regional pool (410 species)
dis <- cophenetic(befdat$phy.gut.ultra.nongymnocult)
befdat$Succ.alpha.Dpw.reg <- D.PD.step5.picante(com = com, dis = dis, nullmod = "taxaShuffle", value=2, runs = 999)
befdat$Succ.alpha.Dstar.reg <- D.PD.step5.picante(com = com, dis = dis, nullmod = "taxaShuffle", value=3, runs = 999)
befdat$Succ.alpha.Dplus.reg <- D.PD.step5.picante(com = com, dis = dis, nullmod = "taxaShuffle", value=5, runs = 999)
save(befdat, file = paste(path.data,"befdat.Rdata", sep = ""))


obs <- taxondive(mat$comm, dis = cophenetic(mat$phy), match.force = TRUE)

alpha.distinct <- cbind(obs[[1]], obs[[2]], obs[[3]], obs[[5]])
colnames(alpha.distinct) <- c("SR", "Rao", "PDistincAbu", "PDistincOcc")
write.csv(alpha.distinct, file = "PD.alpha.distinct.csv")

########################
# 1.1.2 SES, for each site
########################

## SES for each plot:
rao.tax.shuff <- function(samp, phy, runs, value){
  Res = list()
  for (r in 1:runs) {     
    Res <- c(Res, list(taxondive(com, eval(parse(text=nullmod))(dis), match.force = TRUE)[[value]]))
    # Res <- c(Res, list(Rao(sample=t(samp.order), dfunc=NULL, dphyl=phy.shuff, weight=F, Jost=T, structure=NULL)$PD$Alpha))
  }
  return(Res)
}

ses.alpha <- function(obs, rand){
  rand <- t(as.data.frame(lapply(rand, as.vector)))
  physo.obs <- as.numeric(obs)
  physo.mean <- apply(rand, MARGIN = 2, FUN = mean, na.rm = TRUE)
  physo.sd <- apply(rand, MARGIN = 2, FUN = sd, na.rm = TRUE)
  physo.ses <- (physo.obs - physo.mean)/physo.sd
  physo.obs.rank <- apply(X = rbind(physo.obs, rand), MARGIN = 2, FUN = rank)[1, ]
  physo.obs.rank <- ifelse(is.na(physo.mean), NA, physo.obs.rank)
  data.frame(physo.obs, physo.mean, physo.sd, physo.obs.rank, physo.ses, physo.obs.p = physo.obs.rank/(dim(rand)[1] + 1))
}

# value: 2 - D (Dpw), 3 - Dstar (Dp*w), 5 - Dplus (DELTApw)

# regional pool
dis <- cophenetic(befdat$phy.gut.ultra.nongymnocult)
value <- 2
system.time(
  PD.taxshuff.alpha <- rao.tax.shuff(mat$comm, dis, runs = 999, value = value)
  )
PD.obs <- taxondive(com, dis, match.force = TRUE)[[value]]
ses.PD.alpha <- ses.alpha(PD.obs, PD.taxshuff.alpha)
ses.PD.alpha
aggregate(ses.PD.alpha$physo.mean/2, list(Stage = befdat$site.order$age_HB), mean)
befdat$SES.reg.Dpw <- ses.PD.alpha

value <- 3
system.time(
  PD.taxshuff.alpha <- rao.tax.shuff(mat$comm, dis, runs = 999, value = value)
  )
PD.obs <- taxondive(com, dis, match.force = TRUE)[[value]]
ses.PD.alpha <- ses.alpha(PD.obs, PD.taxshuff.alpha)
ses.PD.alpha
aggregate(ses.PD.alpha$physo.mean/2, list(Stage = befdat$site.order$age_HB), mean)
befdat$SES.reg.Dstar <- ses.PD.alpha

value <- 5
system.time(
  PD.taxshuff.alpha <- rao.tax.shuff(mat$comm, dis, runs = 999, value = value)
  )
PD.obs <- taxondive(com, dis, match.force = TRUE)[[value]]
ses.PD.alpha <- ses.alpha(PD.obs, PD.taxshuff.alpha)
ses.PD.alpha
aggregate(ses.PD.alpha$physo.mean/2, list(Stage = befdat$site.order$age_HB), mean)
befdat$SES.reg.Dplus <- ses.PD.alpha
save(befdat, file = paste(path.data,"befdat.Rdata", sep = ""))

# age pool
dis <- cophenetic(mat$phy)
value <- 2
system.time(
  PD.taxshuff.alpha <- rao.tax.shuff(mat$comm, dis, runs = 999, value = value)
 )
PD.obs <- taxondive(com, dis, match.force = TRUE)[[value]]
ses.PD.alpha <- ses.alpha(PD.obs, PD.taxshuff.alpha)
ses.PD.alpha
aggregate(ses.PD.alpha$physo.mean/2, list(Stage = befdat$site.order$age_HB), mean)
befdat$SES.age.Dpw <- ses.PD.alpha
value <- 3
system.time(
  PD.taxshuff.alpha <- rao.tax.shuff(mat$comm, dis, runs = 999, value = value)
 )
PD.obs <- taxondive(com, dis, match.force = TRUE)[[value]]
ses.PD.alpha <- ses.alpha(PD.obs, PD.taxshuff.alpha)
ses.PD.alpha
aggregate(ses.PD.alpha$physo.mean/2, list(Stage = befdat$site.order$age_HB), mean)
befdat$SES.age.Dstar <- ses.PD.alpha
value <- 5
system.time(
  PD.taxshuff.alpha <- rao.tax.shuff(mat$comm, dis, runs = 999, value = value)
 )
PD.obs <- taxondive(com, dis, match.force = TRUE)[[value]]
ses.PD.alpha <- ses.alpha(PD.obs, PD.taxshuff.alpha)
ses.PD.alpha
aggregate(ses.PD.alpha$physo.mean/2, list(Stage = befdat$site.order$age_HB), mean)
befdat$SES.age.Dplus <- ses.PD.alpha

save(befdat, file = paste(path.data,"befdat.Rdata", sep = ""))

#############################

########################
# 1.2) Beta diversity #
########################

########################
# 1.2.1 global, within stages
########################

spa.PD.step5 <- function(com, phy, value, nullmod, runs){
    results <- matrix(NA, nrow = 5, ncol = 8)
    pairwise <- list("T1","T2","T3","T4","T5") # list because it should hold objects of varying length
    names(pairwise) <- c("T1","T2","T3","T4","T5")

PI.shuff <- function(com, runs){
    Res = NA
    for (r in 1:runs) {      
        Res <- c(Res, mean(as.dist(spacodi.calc(sp.plot = com, phy = eval(parse(text=nullmod))(cophenetic(phy)), prune = FALSE, pairwise = TRUE)[[value]])))   
    }
    return(Res)
}

    for (i in 1:5){       
        obs <- spacodi.calc(sp.plot = com[,befdat$site.order[,59]==i], phy = cophenetic(phy), prune = FALSE, pairwise = TRUE) # single obsversed PIst value  
        obs.val <- mean(as.dist(obs[[value]]))   
        resamp <- PI.shuff(com = com[,befdat$site.order[,59]==i], runs = runs) 
        resamp[1] <- obs.val
        obs.rank <- rank(resamp)[1]
        results[i,1] <- obs.val
        results[i,2] <- mean(resamp[2:(runs+1)], na.rm = TRUE)
        results[i,3] <- sd(resamp[2:(runs+1)], na.rm = TRUE)
        results[i,4] <- quantile(resamp[2:(runs+1)],  probs = c(2.5, 97.5)/100)[1]
        results[i,5] <- quantile(resamp[2:(runs+1)],  probs = c(2.5, 97.5)/100)[2]
        results[i,6] <- obs.rank/(runs+1) ## P(1-sided test, H1: obs<exp)
        results[i,7] <- 1-(obs.rank/(runs+1)) ## P(1-sided test, H1: obs>exp)
        results[i,8] <- (1-(obs.rank/(runs+1)))*2 ## P(2-sided test, H1: obs<>exp)
        dimnames(results) <- list(c("T1", "T2", "T3", "T4", "T5"), c(names(obs)[value],"rand.mean","rand.sd","2.5%","97.5%","P.obs<exp","P.obs>exp","P.obs<>exp"))
        pairwise[[i]] <- as.dist(obs[[value]])
    }
    return(list(Results = results, Pairwise = pairwise))
}

# com <- t(mat$comm)
com <- t(rrarefy(mat$comm, 175)) # rarefied community data
com.lor <- t(mat.lor$comm)
phy1 <- mat$phy
phy2 <- befdat$phy.gut.ultra.nongymnocult

# try prune = FALSE, but save results for prune = TRUE
# regional phylogeny
#befdat$Succ.beta.PIst.reg.lor <- befdat$Succ.beta.PIst.reg

befdat$Succ.beta.PIst.reg <- spa.PD.step5(com = com, phy = phy2, value = 8, nullmod = "taxaShuffle", runs = 99)
save(befdat, file = paste(path.data,"befdat.Rdata", sep = ""))

# rarefied beta diversity

com <- t(rrarefy(mat$comm, 175))
befdat$Succ.beta.PIst.reg.rare <- spa.PD.step5(com = com, phy = phy2, value = 8, nullmod = "taxaShuffle", runs = 299)
befdat$Succ.beta.PIst.reg.rare$Results

com <- t(rrarefy(mat$comm, 175))
befdat$Succ.beta.PIst.reg.rare <- spa.PD.step5(com = com, phy = phy2, value = 8, nullmod = "taxaShuffle", runs = 299)
befdat$Succ.beta.PIst.reg.rare$Results

com <- t(rrarefy(mat$comm, 175))
befdat$Succ.beta.PIst.reg.rare <- spa.PD.step5(com = com, phy = phy2, value = 8, nullmod = "taxaShuffle", runs = 299)
befdat$Succ.beta.PIst.reg.rare$Results


befdat$Succ.beta.Bst.reg.rare <- spa.PD.step5(com = com, phy = phy2, value = 7, nullmod = "taxaShuffle", runs = 999)
save(befdat, file = paste(path.data,"befdat.Rdata", sep = ""))

############################################################
### try within stages BUT with gamma based on all 27 plots #
############################################################

li <- list(NA)
for (i in 1:5){
li <- c(li,list(rownames(befdat$site.order)[befdat$site.order[,59]==i]))
}

cbind.fill <- function (alphalist) {
require(plyr) 
bind <- rbind.fill.matrix(t(as.matrix(as.vector(alphalist[[1]]))), t(as.matrix(as.vector(alphalist[[2]]))) ,t(as.matrix(as.vector(alphalist[[3]]))), t(as.matrix(as.vector(alphalist[[4]]))), t(as.matrix(as.vector(alphalist[[5]]))))
t(bind)
}

namtab <- cbind.fill(li[2:6])

mat <- match.phylo.comm(phy=befdat$phy.143.ultra, comm=t(befdat$com.order))

com <- t(mat$comm)
phy1 <- mat$phy
phy2 <- befdat$phy.gut.ultra.nongymnocult

# PIst do not differ based on phylogeny size and not based on whether PIst was calculated within time step or the whole study landscape:

# gamma based on all 27 plots:
obs <- spacodi.calc(sp.plot = com, phy = cophenetic(phy2), prune = FALSE, pairwise = TRUE) # single obsversed PIst value  
i <- 5
mean(as.dist(obs[[value]][rownames(obs[[value]]) %in% namtab[,i], colnames(obs[[value]])%in%namtab[,i]]))

i <- 1
# different gamma for each time step:
obs <- spacodi.calc(sp.plot = com[,befdat$site.order[,59]==i], phy = cophenetic(phy2), prune = TRUE, pairwise = TRUE) # single obsversed PIst value  
mean(as.dist(obs[[value]]))

# ! however, try whether the null models results differ for gamma based on all 27 plots:

############################

spa.PD.step5.27 <- function(com, phy, value, nullmod, runs){
results <- matrix(NA, nrow = 5, ncol = 8)
pairwise <- list("T1","T2","T3","T4","T5") # list because it should hold objects of varying length
names(pairwise) <- c("T1","T2","T3","T4","T5")
for (i in 1:5){    
  obs <- spacodi.calc(sp.plot = com, phy = cophenetic(phy1), prune = FALSE, pairwise = TRUE) # single obsversed PIst value  
  obs.val <- mean(as.dist(obs[[value]][rownames(obs[[value]]) %in% namtab[,i], colnames(obs[[value]])%in%namtab[,i]]))  
  Res = NA 
  for (r in 1:runs) {      
    resamp <- Res <- c(Res, mean(as.dist(spacodi.calc(sp.plot = com, phy = eval(parse(text=nullmod))(cophenetic(phy)), prune = FALSE, pairwise = TRUE)[[value]][rownames(obs[[value]]) %in% namtab[,i], colnames(obs[[value]])%in%namtab[,i]])))   
  } 
resamp[1] <- obs.val
obs.rank <- rank(resamp)[1]
results[i,1] <- obs.val
results[i,2] <- mean(resamp[2:(runs+1)], na.rm = TRUE)
results[i,3] <- sd(resamp[2:(runs+1)], na.rm = TRUE)
results[i,4] <- quantile(resamp[2:(runs+1)],  probs = c(2.5, 97.5)/100)[1]
results[i,5] <- quantile(resamp[2:(runs+1)],  probs = c(2.5, 97.5)/100)[2]
results[i,6] <- obs.rank/(runs+1) ## P(1-sided test, H1: obs<exp)
results[i,7] <- 1-(obs.rank/(runs+1)) ## P(1-sided test, H1: obs>exp)
results[i,8] <- (1-(obs.rank/(runs+1)))*2 ## P(2-sided test, H1: obs<>exp)
dimnames(results) <- list(c("T1", "T2", "T3", "T4", "T5"), c(names(obs)[value],"rand.mean","rand.sd","2.5%","97.5%","P.obs<exp","P.obs>exp","P.obs<>exp"))
pairwise[[i]] <- as.dist(obs[[value]])
}
return(list(Results = results, Pairwise = pairwise))
}

spa.PD.step5.27.phy1.8 <- spa.PD.step5.27(com = com, phy = phy1, value = 8, nullmod = "taxaShuffle", runs = 199)
spa.PD.step5.27.phy1.8$Results

spa.PD.step5.27.phy2.8 <- spa.PD.step5.27(com = com, phy = phy2, value = 8, nullmod = "taxaShuffle", runs = 199)
spa.PD.step5.27.phy2.8$Results

spa.PD.step5.27.phy1.7 <- spa.PD.step5.27(com = com, phy = phy1, value = 7, nullmod = "taxaShuffle", runs = 999)
spa.PD.step5.27.phy1.7$Results

spa.PD.step5.27.phy2.7 <- spa.PD.step5.27(com = com, phy = phy2, value = 7, nullmod = "taxaShuffle", runs = 999)
spa.PD.step5.27.phy2.7$Results

# null models for each of the time steps BUT based on gamma all 27 plots gives similar results as for gamma based on gamma for the time steps only
# -> for between time-step comparisons i should use temporal turnover based on gamma for the two time-steps only

####################################
# A) Analysis of temporal turnover #
####################################

# 1) turnover between single time steps
# 1.1) temporal turnover in PIst between the first and all other time steps (+- done)

site <- befdat$site.order

timevec <- as.vector(dist(site$age_HB^3))
timevec[timevec==7] <- 1
timevec[timevec==26] <- 2
timevec[timevec==63] <- 3
timevec[timevec==124] <- 4

# rewrite null model for "taxa.shuffle":

spacodi.temp.pair.1.i.taxshuff <- function(com, phy, traits, value, nullmod, runs){
# mat <- matrix(1:220, nrow = 55, ncol = 4) # site vectors for the four different time steps
results <- matrix(NA, nrow = 4, ncol = 8)
pairwise <- list()[1:4]
names(pairwise) <- c("T1-T2", "T1-T3", "T1-T4", "T1-T5")
PI.tax.shuff <- function(com, runs){
  Res = NA
  for (r in 1:runs) {   
    Res <- c(Res, mean(as.dist(spacodi.calc(sp.plot = com, phy = eval(parse(text=nullmod))(cophenetic(phy)), prune = TRUE, pairwise = TRUE)[[value]])[timevec==i-1]))
  }
  return(Res)
}
for (i in 2:5){ 
  # new:  
  timevec <- as.vector(dist(site$age_HB[site$age_HB==1 | site$age_HB==i]))
  ##  
obs <- spacodi.calc(sp.plot = com[,site$age_HB==1 | site$age_HB==i], phy = phy, prune = TRUE, pairwise = TRUE) # single obsversed PIst value  
obs.val <- mean(as.dist(obs[[value]])[timevec==i-1]) 
resamp <- PI.tax.shuff(com = com[,site$age_HB==1 | site$age_HB==i], runs = runs)  
resamp[1] <- obs.val  
obs.rank <- rank(resamp)[1]
results[i-1,1] <- obs.val
results[i-1,2] <- mean(resamp[2:(runs+1)], na.rm = TRUE)
results[i-1,3] <- sd(resamp[2:(runs+1)], na.rm = TRUE)
results[i-1,4] <- quantile(resamp[2:(runs+1)],  probs = c(2.5, 97.5)/100)[1]
results[i-1,5] <- quantile(resamp[2:(runs+1)],  probs = c(2.5, 97.5)/100)[2]
results[i-1,6] <- obs.rank/(runs+1) ## P(1-sided test, H1: obs<exp)
results[i-1,7] <- 1-(obs.rank/(runs+1)) ## P(1-sided test, H1: obs>exp)
results[i-1,8] <- (1-(obs.rank/(runs+1)))*2 ## P(2-sided test, H1: obs<>exp)
dimnames(results) <- list(c("T1-T2", "T1-T3", "T1-T4", "T1-T5"), c(names(obs)[value],"rand.mean","rand.sd","2.5%","97.5%","P.obs<exp","P.obs>exp","P.obs<>exp"))
pairwise[[i-1]] <- as.dist(obs[[value]])[timevec==i-1]
}
return(list(Results = results, Pairwise = pairwise))
}

spacodi.temp.pair.Bst.1 <- spacodi.temp.pair.1.i.taxshuff(com=com, phy=phy, traits = NULL, value=7, nullmod="taxaShuffle", runs=999)

befdat$spacodi.temp.pair.Bst.1 <- spacodi.temp.pair.Bst.1 

# plot temporal turnover

cbind.fill.10 <- function (alphalist) {
require(plyr) 
bind <- rbind.fill.matrix(t(as.matrix(as.vector(alphalist[[1]]))), t(as.matrix(as.vector(alphalist[[2]]))), t(as.matrix(as.vector(alphalist[[3]]))), t(as.matrix(as.vector(alphalist[[4]]))), t(as.matrix(as.vector(alphalist[[5]]))), t(as.matrix(as.vector(alphalist[[6]]))), t(as.matrix(as.vector(alphalist[[7]]))), t(as.matrix(as.vector(alphalist[[8]]))), t(as.matrix(as.vector(alphalist[[9]]))), t(as.matrix(as.vector(alphalist[[10]]))))
t(bind)
}

cbind.fill.10(c(befdat$spacodi.temp.pair.Bst.1$Pairwise, befdat$spacodi.temp.pair.Bst.2.3.4$Pairwise))

rbind(befdat$spacodi.temp.pair.PD.1$Results, befdat$spacodi.temp.pair.PD.2.3.4$Results)

#postscript("Succ.beta.bef.temp.eps", width = 3, height = 3.1, paper = "special", onefile = FALSE, horizontal = FALSE, pointsize=12)
pdf("Succ.beta.bef.temp.Bst.1.2.3.4.5.pdf", width = 5, height = 3.1)
par(mar=c(0,3.8,0.5,.6),oma=c(5.2,0,1.6,0), tcl=.3, las=1, cex = .75)
#for (i in c(1,5,3)){
par(bty = "l")
error.bars(cbind.fill.10(c(befdat$spacodi.temp.pair.Bst.1$Pairwise, befdat$spacodi.temp.pair.Bst.2.3.4$Pairwise)), bar=F, alpha = 0.05, sd = F, pch = 15, arrow.len = .00, lwd = 3, cex = 1.2, axes = FALSE, xlim = c(0.9,10.2), ylim = c(-0.05,0.03), main = "", xlab = "", ylab = expression(B[ST]), mgp=c(2.7,0,0))
polygon(y=c(rbind(befdat$spacodi.temp.pair.Bst.1$Results, befdat$spacodi.temp.pair.Bst.2.3.4$Results)[,4], rev(rbind(befdat$spacodi.temp.pair.Bst.1$Results, befdat$spacodi.temp.pair.Bst.2.3.4$Results)[,5])), x=c(1:10,10:1), col="grey76", border = NA)
error.bars(cbind.fill.10(c(befdat$spacodi.temp.pair.Bst.1$Pairwise, befdat$spacodi.temp.pair.Bst.2.3.4$Pairwise)), bar=F, alpha = 0.05, sd = F, pch = 15, arrow.len = .00, lwd = 3, cex = 1.2, axes = FALSE, xlim = c(0.9,10.2), ylim = c(-0.05,0.03), main = "", xlab = "", ylab = expression(Pi[ST]), mgp=c(2.7,0,0), add = T)
lines(rbind(befdat$spacodi.temp.pair.Bst.1$Results, befdat$spacodi.temp.pair.Bst.2.3.4$Results)[,2], lty = 3)
#text(1,52, "a");text(2,52, "b");text(3,52, "c");text(4,52, "c")
axis(side = 2, hadj=.7)
axis(side = 1, 1:10, c("T1-T2","T1-T3","T1-T4","T1-T5", "T2-T3", "T2-T4", "T2-T5", "T3-T4", "T3-T5","T4-T5"), las = 2)
#text(1.9,55, "Taxonomic", cex = 1.4)
box()
mtext("Successional stage (Years)", side=1, outer = T, line=4, at = .54, cex = .8)
#mtext("(a) Taxonomic", side=3, at = .152, outer = T, line=.4, cex = .9)
#mtext("(b) Phylogenetic", side=3, at = .494, outer = T, line=.4, cex = .9)
#mtext("(c) Functional", side=3, at = .815, outer = T, line=.4, cex = .9)
dev.off()

# 1.2.) temporal turnover in PIst between all other pairs of time steps


# mat <- matrix(1:220, nrow = 55, ncol = 4) # site vectors for the four different time steps
results <- matrix(NA, nrow = 6, ncol = 8)
pairwise <- list()[1:6]
names(pairwise) <- c("T2-T3", "T2-T4", "T2-T5", "T3-T4", "T3-T5", "T4-T5")
PI.tax.shuff <- function(com, runs){
  
  Res = NA
  for (r in 1:runs) {   
    Res <- c(Res, mean(as.dist(spacodi.calc(sp.plot = com, phy = eval(parse(text=nullmod))(cophenetic(phy)), prune = TRUE, pairwise = TRUE)[[value]])[timevec==i-2]))
  }
  return(Res)  
}
for (i in 3:5){ 
  # new:  
  timevec <- as.vector(dist(site$age_HB[site$age_HB==2 | site$age_HB==i]))
  ##    
obs <- spacodi.calc(sp.plot = com[,site$age_HB==2 | site$age_HB==i], phy = phy, prune = TRUE, pairwise = TRUE) # single obsversed PIst value  
obs.val <- mean(as.dist(obs[[value]])[timevec==i-2])  
resamp <- PI.tax.shuff(com = com[,site$age_HB==2 | site$age_HB==i], runs = runs)  
resamp[1] <- obs.val  
obs.rank <- rank(resamp)[1]
results[i-2,1] <- obs.val
results[i-2,2] <- mean(resamp[2:(runs+1)], na.rm = TRUE)
results[i-2,3] <- sd(resamp[2:(runs+1)], na.rm = TRUE)
results[i-2,4] <- quantile(resamp[2:(runs+1)],  probs = c(2.5, 97.5)/100)[1]
results[i-2,5] <- quantile(resamp[2:(runs+1)],  probs = c(2.5, 97.5)/100)[2]
results[i-2,6] <- obs.rank/(runs+1) ## P(1-sided test, H1: obs<exp)
results[i-2,7] <- 1-(obs.rank/(runs+1)) ## P(1-sided test, H1: obs>exp)
results[i-2,8] <- (1-(obs.rank/(runs+1)))*2 ## P(2-sided test, H1: obs<>exp)
dimnames(results) <- list(c("T2-T3", "T2-T4", "T2-T5", "T3-T4", "T3-T5", "T4-T5"), c(names(obs)[value],"rand.mean","rand.sd","2.5%","97.5%","P.obs<exp","P.obs>exp","P.obs<>exp"))
pairwise[[i-2]] <- as.dist(obs[[value]])[timevec==i-2]
}

out <- list(Results = results, Pairwise = pairwise)

# for T3 

PI.tax.shuff <- function(com, runs){  
  Res = NA
  for (r in 1:runs) {   
    Res <- c(Res, mean(as.dist(spacodi.calc(sp.plot = com, phy = eval(parse(text=nullmod))(cophenetic(phy)), prune = TRUE, pairwise = TRUE)[[value]])[timevec==i-3]))
  }
  return(Res)  
}

for (i in 4:5){ 
  # new:  
  timevec <- as.vector(dist(site$age_HB[site$age_HB==3 | site$age_HB==i]))
  ##    
obs <- spacodi.calc(sp.plot = com[,site$age_HB==3 | site$age_HB==i], phy = phy, prune = TRUE, pairwise = TRUE) # single obsversed PIst value  
obs.val <- mean(as.dist(obs[[value]])[timevec==i-3])  
resamp <- PI.tax.shuff(com = com[,site$age_HB==3 | site$age_HB==i], runs = runs)  
resamp[1] <- obs.val  
obs.rank <- rank(resamp)[1]
results[i,1] <- obs.val
results[i,2] <- mean(resamp[2:(runs+1)], na.rm = TRUE)
results[i,3] <- sd(resamp[2:(runs+1)], na.rm = TRUE)
results[i,4] <- quantile(resamp[2:(runs+1)],  probs = c(2.5, 97.5)/100)[1]
results[i,5] <- quantile(resamp[2:(runs+1)],  probs = c(2.5, 97.5)/100)[2]
results[i,6] <- obs.rank/(runs+1) ## P(1-sided test, H1: obs<exp)
results[i,7] <- 1-(obs.rank/(runs+1)) ## P(1-sided test, H1: obs>exp)
results[i,8] <- (1-(obs.rank/(runs+1)))*2 ## P(2-sided test, H1: obs<>exp)
pairwise[[i]] <- as.dist(obs[[value]])[timevec==i-3]
out <- list(Results = results, Pairwise = pairwise)
}


# for T4
PI.tax.shuff <- function(com, runs){  
  Res = NA
  for (r in 1:runs) {   
    Res <- c(Res, mean(as.dist(spacodi.calc(sp.plot = com, phy = eval(parse(text=nullmod))(cophenetic(phy)), prune = TRUE, pairwise = TRUE)[[value]])[timevec==i-4]))
  }
  return(Res)  
}
for (i in 5){ 
  # new:  
  timevec <- as.vector(dist(site$age_HB[site$age_HB==4 | site$age_HB==i]))
  ##    
obs <- spacodi.calc(sp.plot = com[,site$age_HB==4 | site$age_HB==i], phy = phy, prune = TRUE, pairwise = TRUE) # single obsversed PIst value  
obs.val <- mean(as.dist(obs[[value]])[timevec==i-4])  
resamp <- PI.tax.shuff(com = com[,site$age_HB==4 | site$age_HB==i], runs = runs)  
resamp[1] <- obs.val  
obs.rank <- rank(resamp)[1]
results[i+1,1] <- obs.val
results[i+1,2] <- mean(resamp[2:(runs+1)], na.rm = TRUE)
results[i+1,3] <- sd(resamp[2:(runs+1)], na.rm = TRUE)
results[i+1,4] <- quantile(resamp[2:(runs+1)],  probs = c(2.5, 97.5)/100)[1]
results[i+1,5] <- quantile(resamp[2:(runs+1)],  probs = c(2.5, 97.5)/100)[2]
results[i+1,6] <- obs.rank/(runs+1) ## P(1-sided test, H1: obs<exp)
results[i+1,7] <- 1-(obs.rank/(runs+1)) ## P(1-sided test, H1: obs>exp)
results[i+1,8] <- (1-(obs.rank/(runs+1)))*2 ## P(2-sided test, H1: obs<>exp)
pairwise[[i+1]] <- as.dist(obs[[value]])[timevec==i-4]
out <- list(Results = results, Pairwise = pairwise)
}

befdat$spacodi.temp.pair.Bst.2.3.4 <- out


# 2) overall turnover (within and between time steps)

results <- matrix(NA, nrow = 3, ncol = 8)
pairwise <- list()[1:3]
rand <- list()[1:3]
names(pairwise) <- c("All", "Within", "Between")
names(rand) <- c("All", "Within", "Between")

#PI.tax.shuff <- function(com, runs){
  
  Res = NA
  for (r in 1:runs) {   
    Res <- c(Res, mean(as.dist(spacodi.calc(sp.plot = com, phy = eval(parse(text=nullmod))(cophenetic(phy)), prune = TRUE, pairwise = TRUE)[[value]])))
  }
 # return(Res)  
#}

obs <- spacodi.calc(sp.plot = com, phy = phy, prune = TRUE, pairwise = TRUE) # single obsversed PIst value  
obs.val <- mean(as.dist(obs[[value]]))  

# resamp <- PI.tax.shuff(com = com, runs = runs)  

resamp <- Res
resamp[1] <- obs.val  

obs.rank <- rank(resamp)[1]
results[1,1] <- obs.val
results[1,2] <- mean(resamp[2:(runs+1)], na.rm = TRUE)
results[1,3] <- sd(resamp[2:(runs+1)], na.rm = TRUE)
results[1,4] <- quantile(resamp[2:(runs+1)],  probs = c(2.5, 97.5)/100)[1]
results[1,5] <- quantile(resamp[2:(runs+1)],  probs = c(2.5, 97.5)/100)[2]
results[1,6] <- obs.rank/(runs+1) ## P(1-sided test, H1: obs<exp)
results[1,7] <- 1-(obs.rank/(runs+1)) ## P(1-sided test, H1: obs>exp)
results[1,8] <- (1-(obs.rank/(runs+1)))*2 ## P(2-sided test, H1: obs<>exp)
dimnames(results) <- list(c("All", "Within", "Between"), c(names(obs)[value],"rand.mean","rand.sd","2.5%","97.5%","P.obs<exp","P.obs>exp","P.obs<>exp"))
pairwise[[1]] <- as.dist(obs[[value]])
rand[[1]] <- resamp

# out <- list(Results = results, Pairwise = pairwise, Rand = resamp)

befdat$spacodi.temp.Bst.All <- out
save(befdat, file = paste(path.data,"befdat.Rdata", sep = ""))

plot(density(rand[[1]][2:999]))
abline(v=results[1,1], col = "red", lwd = 2)
abline(v=results[1,4], lty = 2)
abline(v=results[1,5], lty = 2)

########################################
# 3) overall turnover within time steps
########################################

# this bit is for the rarefied communities only:
################################################
mat <- match.phylo.comm(phy=befdat$phy.143.ultra, comm=t(befdat$com.order))
com <- t(mat$comm)

#com <- t(rrarefy(mat$comm, 175))
phy1 <- mat$phy
phy <- befdat$phy.gut.ultra.nongymnocult
nullmod = "taxaShuffle"
runs = 999
value = 7
############################

site <- befdat$site.order
timevec <- as.vector(dist(site$age_HB^3))

#PI.tax.shuff <- function(com, runs){
  
  Res = NA
  for (r in 1:runs) {   
    Res <- c(Res, mean(as.dist(spacodi.calc(sp.plot = com, phy = eval(parse(text=nullmod))(cophenetic(phy)), prune = TRUE, pairwise = TRUE)[[value]])[timevec==0]))
  }
#  return(Res)  
#}

obs <- spacodi.calc(sp.plot = com, phy = phy, prune = TRUE, pairwise = TRUE) # single obsversed PIst value  
obs.val <- mean(as.dist(obs[[value]])[timevec==0])  

# resamp <- PI.tax.shuff(com = com, runs = runs)  
resamp <- Res
resamp[1] <- obs.val  

obs.rank <- rank(resamp)[1]
results[2,1] <- obs.val
results[2,2] <- mean(resamp[2:(runs+1)], na.rm = TRUE)
results[2,3] <- sd(resamp[2:(runs+1)], na.rm = TRUE)
results[2,4] <- quantile(resamp[2:(runs+1)],  probs = c(2.5, 97.5)/100)[1]
results[2,5] <- quantile(resamp[2:(runs+1)],  probs = c(2.5, 97.5)/100)[2]
results[2,6] <- obs.rank/(runs+1) ## P(1-sided test, H1: obs<exp)
results[2,7] <- 1-(obs.rank/(runs+1)) ## P(1-sided test, H1: obs>exp)
results[2,8] <- (1-(obs.rank/(runs+1)))*2 ## P(2-sided test, H1: obs<>exp)
pairwise[[2]] <- as.dist(obs[[value]])[timevec==0]
rand[[2]] <- resamp

plot(density(rand[[2]][2:999]))
abline(v=results[2,1], col = "red", lwd = 2)
abline(v=results[2,4], lty = 2)
abline(v=results[2,5], lty = 2)

##########################################
# 4) overall turnover between time steps
##########################################

#PI.tax.shuff <- function(com, runs){
  
  Res = NA
  for (r in 1:runs) {   
    Res <- c(Res, mean(as.dist(spacodi.calc(sp.plot = com, phy = eval(parse(text=nullmod))(cophenetic(phy)), prune = TRUE, pairwise = TRUE)[[value]])[timevec!=0]))
  }
#  return(Res)  
#}

obs <- spacodi.calc(sp.plot = com, phy = phy, prune = TRUE, pairwise = TRUE) # single obsversed PIst value  
obs.val <- mean(as.dist(obs[[value]])[timevec!=0])  

# resamp <- PI.tax.shuff(com = com, runs = runs)  
resamp <- Res
resamp[1] <- obs.val  

obs.rank <- rank(resamp)[1]
results[3,1] <- obs.val
results[3,2] <- mean(resamp[2:(runs+1)], na.rm = TRUE)
results[3,3] <- sd(resamp[2:(runs+1)], na.rm = TRUE)
results[3,4] <- quantile(resamp[2:(runs+1)],  probs = c(2.5, 97.5)/100)[1]
results[3,5] <- quantile(resamp[2:(runs+1)],  probs = c(2.5, 97.5)/100)[2]
results[3,6] <- obs.rank/(runs+1) ## P(1-sided test, H1: obs<exp)
results[3,7] <- 1-(obs.rank/(runs+1)) ## P(1-sided test, H1: obs>exp)
results[3,8] <- (1-(obs.rank/(runs+1)))*2 ## P(2-sided test, H1: obs<>exp)
pairwise[[3]] <- as.dist(obs[[value]])[timevec!=0]
rand[[3]] <- resamp

out <- list(Results = results, Pairwise = pairwise, Rand = rand)

# plot overall turnover

pdf("Bst.pair.overall.pdf", width = 8, height = 2.8)
par(mfrow = c(1,3))
plot(density(rand[[1]][2:999]), main = "Overall")
abline(v=results[1,1], col = "red", lwd = 2)
abline(v=results[1,4], lty = 2)
abline(v=results[1,5], lty = 2)
plot(density(rand[[2]][2:999]), main = "Within")
abline(v=results[2,1], col = "red", lwd = 2)
abline(v=results[2,4], lty = 2)
abline(v=results[2,5], lty = 2)
plot(density(rand[[3]][2:999]), main = "Between")
abline(v=results[3,1], col = "red", lwd = 2)
abline(v=results[3,4], lty = 2)
abline(v=results[3,5], lty = 2)
dev.off()

###############################################################
# B) Analysis of temporal turnover and environmental distance #
###############################################################

# 1.1 overall environmental distance (within and between time steps)

vec2dist <- function(betavec, com){
  mat <- matrix(NA, nrow = dim(com)[1], ncol = dim(com)[1])
  rownames(mat) <- rownames(com) 
  colnames(mat) <- rownames(com) 
  d <- as.dist(mat)
  for (i in 1:length(betavec)){
      d[i] <- betavec[i]
    }
  d
}


spatdist.all <- (dist(befdat$site.order[,70:71]))

# enviromental (soil) variables
#names(befdat$site.order[,c(3,9,19,45,  60,62,63,65)])
#[1] "Elevation"     "Inclination"   "Open_soil"     "Soil_moisture"
#[5] "pH"            "N"             "C"             "C_N"  

csp13 <- read.csv("/home/oliver/Dokumente/PhD/PostPhD/Halle/BEF-China/Data/von_Helge/csp_variables13.csv")

site.order.csp13 <- merge(x=befdat$site.order, y=csp13, by.x = "CSP", by.y = "Plot", sort = FALSE)
site.order.csp13[, c(1,2,10,57:59, 72)]
plot(site.order.csp13[,3], site.order.csp13[,82])


pdf("env.large.pdf", height = 22, width = 22)
CorTestPlot(befdat$site.order[,c(3,5,6,9,19,45,50,62,63,65,73:76,86,87)])
dev.off()




##############################################
########### Rarefaction-Analysis #############
##############################################

# ‘rrarefy’ generates one randomly rarefied community data frame

rare.200 <- rowSums(decostand(rrarefy(t(befdat$com.order), 207), "pa"))
norm <- rowSums(decostand(t(befdat$com.order), "pa"))
plot(rare.200, norm)
cor.test(rare.200, norm)

befdat$site.order



# pairwise.PIst
# All       0.001283295

mat <- match.phylo.comm(phy=befdat$phy.143.ultra, comm=t(befdat$com.order))
com <- t(mat$comm)
phy1 <- mat$phy
phy2 <- befdat$phy.gut.ultra.nongymnocult

min(rowSums(mat$comm))
rowSums(decostand(rrarefy(mat$comm, 175), "pa"))

res <- NA
for (i in 1:10){
rare.175 <- rrarefy(mat$comm, 175)
obs <- spacodi.calc(sp.plot = t(rare.175), phy = phy2, prune = TRUE, pairwise = TRUE) # single obsversed PIst value  
out <- mantel(as.dist(obs[[8]]), as.dist(obs.non[[8]]))$statistic
res <- c(res, out)
out.mean <- mean(res, na.rm=TRUE)
out.sd <- sd(res, na.rm=TRUE)
}
#res
out.mean
out.sd

# modify rarefaction plot each stage in a particular color:

rarec <- function(x, step = 1, sample, xlab = "Sample Size", ylab = "Species",label = TRUE,...)
{
    tot <- rowSums(x)
    S <- specnumber(x)
    nr <- nrow(x)
    ## Rarefy
    out <- lapply(seq_len(nr), function(i) {
        n <- seq(1, tot[i], by = step)
        if (n[length(n)] != tot[i])
            n <- c(n, tot[i])
        drop(rarefy(x[i,], n))
    })
    Nmax <- sapply(out, function(x) max(attr(x, "Subsample")))
    Smax <- sapply(out, max)
    ## set up plot
    plot(c(1, max(Nmax)), c(1, max(Smax)), xlab = xlab, ylab = ylab,
         type = "n", ...)
    ## rarefied richnesses for given 'sample'
    if (!missing(sample)) {
        abline(v = sample)
        rare <- sapply(out, function(z) approx(x = attr(z, "Subsample"), y = z,
                                             xout = sample, rule = 1)$y)
        abline(h = rare, lwd=0.5)
    }
    ## rarefaction curves
    # for(ln in seq_len(length(out))) {
    for(ln in 1:5) {
        N <- attr(out[[ln]], "Subsample")
        lines(N, out[[ln]],  col = "red", ...)
    }
    for(ln in 6:9) {
        N <- attr(out[[ln]], "Subsample")
        lines(N, out[[ln]],  col = "orange", ...)
    }
    for(ln in 10:14) {
        N <- attr(out[[ln]], "Subsample")
        lines(N, out[[ln]],  col = "yellow", ...)
    }
    for(ln in 15:20) {
        N <- attr(out[[ln]], "Subsample")
        lines(N, out[[ln]],  col = "green", ...)
    }
    for(ln in 21:27) {
        N <- attr(out[[ln]], "Subsample")
        lines(N, out[[ln]],  col = "blue", ...)
    }
    legend("topright", c("Stage 1", "Stage 2", "Stage 3", "Stage 4", "Stage 5"), col = c("red", "orange","yellow", "green","blue" ), lty = 1, lwd = 2)
    ## label curves at their endpoitns
  #  if (label) {
  #      ordilabel(cbind(tot, S), labels=rownames(x), ...)
  #  }
    invisible(out)
}
rarec(mat$comm, step = 10, sample = 175, lwd=2, cex = 0.6, xlab = "Number of individuals", ylab = "Species richness", label = TRUE)   

# plot rarefaction curce
postscript("rarecurve2.eps", width = 7, height = 5.5, paper = "special", onefile = FALSE, horizontal = FALSE, pointsize=12)
#pdf("rarecurve.pdf", width = 10, height = 7)
#rarecurve(mat$comm, step = 10, sample = 175, col = "blue", cex = 0.6, xlab = "Number of individuals", ylab = "Species richness", label = TRUE)   
rarec(mat$comm, step = 10, sample = 175, lwd=2, cex = 0.6, xlab = "Number of individuals", ylab = "Species richness", label = TRUE)   
dev.off()

# Bst                                  
# out.mean
# 0.9674985
# out.sd
# 0.004198444

# PIst
# out.mean
# 0.6320845
# out.sd
# 0.04956704


rare.175 <- rrarefy(mat$comm, 175)
obs <- spacodi.calc(sp.plot = t(rare.175), phy = phy2, prune = TRUE, pairwise = TRUE)
obs.non <- spacodi.calc(sp.plot = com, phy = phy2, prune = TRUE, pairwise = TRUE) #
cor.test(as.dist(obs[[8]]), as.dist(obs.non[[8]]))
plot(as.dist(obs[[8]]), as.dist(obs.non[[8]]), cex = .5)
abline(lm(as.vector(as.dist(obs.non[[8]]) ~ as.vector(as.dist(obs[[8]])))))

###########################################
# rarefaction analysis - alpha diversity ##
###########################################

dis <- cophenetic(befdat$phy.gut.ultra.nongymnocult)
obs.non <- taxondive(com = mat$comm, dis = dis, match.force = TRUE)$Species

#$ Species
#$ D
#$ Dstar
#$ Dplus

res <- NA
for (i in 1:10){
rare.175 <- rrarefy(mat$comm, 175)
obs <- taxondive(com = rare.175, dis = dis, match.force = TRUE)$Species
out <- cor.test(obs, obs.non)$estimate
res <- c(res, out)
out.mean <- mean(res, na.rm=TRUE)
out.sd <- sd(res, na.rm=TRUE)
}
res
out.mean
out.sd


#$ Species
# out.mean
#[1] 0.8410816
#> out.sd
#[1] 0.02341295

#$ Dstar
# out.mean
#[1] 0.9701329
#> out.sd
#[1] 0.006402352

#$ Dplus
# out.mean
#[1] 0.8205828
#> out.sd
#[1] 0.03623435

###########################################
# plot rarefied alpha diversity
############################################
rare.alpha <- function(runs){
obs <- NA
for (i in 1:runs){
rare.175 <- rrarefy(mat$comm, 175)
res <- taxondive(com = rare.175, dis = dis, match.force = TRUE)$Dstar
obs <- rbind(obs, res)
}
rare.mean <- apply(obs[-1,], 2, "mean")
rare.mean
}
dstar.rare <- rare.alpha(runs=100)

alpha <- rare <- cbind(sr.rare ,dstar.rare/2, dplus.rare/2)

sr.list <- list(T1=sr.rare[1:5], T2=sr.rare[6:9], T3=sr.rare[10:14], T4=sr.rare[15:20], T5=sr.rare[21:27])
dstar.list <- list(T1=dstar.rare[1:5]/2, T2=dstar.rare[6:9]/2, T3=dstar.rare[10:14]/2, T4=dstar.rare[15:20]/2, T5=dstar.rare[21:27]/2)
dplus.list <- list(T1=dplus.rare[1:5]/2, T2=dplus.rare[6:9]/2, T3=dplus.rare[10:14]/2, T4=dplus.rare[15:20]/2, T5=dplus.rare[21:27]/2)

#######

cbind.fill <- function (alphalist) {
require(plyr) 
bind <- rbind.fill.matrix(t(as.matrix(as.vector(alphalist[[1]]))), t(as.matrix(as.vector(alphalist[[2]]))) ,t(as.matrix(as.vector(alphalist[[3]]))), t(as.matrix(as.vector(alphalist[[4]]))), t(as.matrix(as.vector(alphalist[[5]]))))
t(bind)
}

cbind.fill(sr.list)

summary(lm(sr.rare ~ befdat$site.order$age_HB))
summary(lm(dstar.rare ~ befdat$site.order$age_HB))
summary(lm(dplus.rare ~ befdat$site.order$age_HB))

postscript("Succ.alpha.rare.eps", width = 6.5, height = 2.6, paper = "special", onefile = FALSE, horizontal = FALSE, pointsize=12)
#pdf("Succ.alpha.rare.pdf", width = 6.5, height = 2.6)
par(mfcol=c(1,3), mar=c(0,3.8,0.5,.6),oma=c(5.2,0,1.6,0), tcl=.3, las=1, cex = .75)
#for (i in c(1,5,3)){
par(bty = "l")
error.bars(cbind.fill(sr.list), bar=F, alpha = 0.05, sd = F, pch = 15, arrow.len = .0, lwd = 3, cex = 1.2, axes = FALSE, xlim = c(0.9,5.2), ylim = c(12,40), main = "", xlab = "", ylab = "Species richness", mgp=c(2,0,0))
text(4,15, "R² = 0.31 **")
abline(lm(sr.rare ~ befdat$site.order$age_HB), lty = 1)
axis(side = 2, hadj=.5)
axis(side = 1, 1:5, c("T1","T2","T3","T4","T5"), las = 1)
                                        #text(1.9,55, "Taxonomic", cex = 1.4
box()
error.bars(cbind.fill(dstar.list), bar=F, alpha = 0.05, sd = F, pch = 15, arrow.len = .00, lwd = 3, cex = 1.2, axes = FALSE, xlim = c(0.9,5.2), ylim = c(95,117), main = "", xlab = "", ylab = expression(Delta[italic(W)]^{symbol("\052")[italic(P)]}), mgp=c(2,0,0))
text(4,97, "R² = 0.01, n.s.")
#abline(lm(dstar.rare/2 ~ befdat$site.order$age_HB), lty = 3)
axis(side = 2, hadj=.5)
axis(side = 1, 1:5, c("T1","T2","T3","T4","T5"), las = 1)
#text(1.9,55, "Taxonomic", cex = 1.4)
box()
error.bars(cbind.fill(dplus.list), bar=F, alpha = 0.05, sd = F, pch = 15, arrow.len = .00, lwd = 3, cex = 1.2, axes = FALSE, xlim = c(0.9,5.2), ylim = c(104,112.5), main = "", xlab = "", ylab = expression(Delta[italic(W)]^{italic(P)}), mgp=c(2,0,0))
text(4,105, "R² = 0.17 *")
abline(lm(dplus.rare/2 ~ befdat$site.order$age_HB), lty = 1)
axis(side = 2, hadj=.5)
axis(side = 1, 1:5, c("T1","T2","T3","T4","T5"), las = 1)
#text(1.9,55, "Taxonomic", cex = 1.4)
box()
mtext("Successional stage (Years)", side=1, outer = T, line=4, at = .54, cex = .8)
#mtext("(a) Taxonomic", side=3, at = .152, outer = T, line=.4, cex = .9)
#mtext("(b) Phylogenetic", side=3, at = .494, outer = T, line=.4, cex = .9)
#mtext("(c) Functional", side=3, at = .815, outer = T, line=.4, cex = .9)
dev.off()

##############################################
###########################################
# rarefaction analysis - beta diversity ##
###########################################

mat <- match.phylo.comm(phy=befdat$phy.143.ultra, comm=t(befdat$com.order))

com <- t(rrarefy(mat$comm, 175))
phy1 <- mat$phy
phy <- befdat$phy.gut.ultra.nongymnocult
nullmod = "taxaShuffle"
runs = 999
value = 8

results <- matrix(NA, nrow = 3, ncol = 8)
pairwise <- list()[1:3]
rand <- list()[1:3]
names(pairwise) <- c("All", "Within", "Between")
names(rand) <- c("All", "Within", "Between")

# 2) overall turnover (within and between time steps)

#PI.tax.shuff <- function(com, runs){
  
  Res = NA
  for (r in 1:runs) {   
    Res <- c(Res, mean(as.dist(spacodi.calc(sp.plot = com, phy = eval(parse(text=nullmod))(cophenetic(phy)), prune = TRUE, pairwise = TRUE)[[value]])))
  }
 # return(Res)  
#}

obs <- spacodi.calc(sp.plot = com, phy = phy, prune = TRUE, pairwise = TRUE) # single obsversed PIst value  
obs.val <- mean(as.dist(obs[[value]]))  

# resamp <- PI.tax.shuff(com = com, runs = runs)  

resamp <- Res
resamp[1] <- obs.val 

obs.rank <- rank(resamp)[1]
results[1,1] <- obs.val
results[1,2] <- mean(resamp[2:(runs+1)], na.rm = TRUE)
results[1,3] <- sd(resamp[2:(runs+1)], na.rm = TRUE)
results[1,4] <- quantile(resamp[2:(runs+1)],  probs = c(2.5, 97.5)/100)[1]
results[1,5] <- quantile(resamp[2:(runs+1)],  probs = c(2.5, 97.5)/100)[2]
results[1,6] <- obs.rank/(runs+1) ## P(1-sided test, H1: obs<exp)
results[1,7] <- 1-(obs.rank/(runs+1)) ## P(1-sided test, H1: obs>exp)
results[1,8] <- (1-(obs.rank/(runs+1)))*2 ## P(2-sided test, H1: obs<>exp)
dimnames(results) <- list(c("All", "Within", "Between"), c(names(obs)[value],"rand.mean","rand.sd","2.5%","97.5%","P.obs<exp","P.obs>exp","P.obs<>exp"))
pairwise[[1]] <- as.dist(obs[[value]])
rand[[1]] <- resamp



##############################################
# analysis of environmental distance using the full enviromental data
##############################################

# plotting the partial residuals of phylogenetic turnover (accounting for space) against environmental distance

# overall turnover: within + between, within, between

#pdf("Succ.PIst.overall.pdf", width = 6.8, height = 2.6)
postscript("Succ.PIst.overall.oeco.eps", width = 6.8, height = 2.6, paper = "special", onefile = FALSE, horizontal = FALSE, pointsize=12)
par(mfcol=c(1,3), mar=c(0,3.8,0.1,.1),oma=c(5.2,0,1.6,0), tcl=.3, las=1, cex = .75)
#for (i in c(1,5,3)){
par(bty = "l")
res <- lm(as.vector(befdat$spacodi.temp.PIst.All$Pairwise$All) ~ as.vector(spatdist.all))$residuals
summary(lmp(res ~ as.vector(soildist.all)))
plot(as.vector(soildist.all), res, axes = FALSE, pch = 19, xlab = "", ylab = expression(paste(Pi[ST], " (partial residuals)", sep = " ")), mgp=c(2,0,0), ylim=c(-0.011, 0.015))
#abline(lm(as.vector(as.dist(as.matrix(pivec)[10:14,10:14])) ~ as.vector(as.dist(as.matrix(soildist.all)[10:14,10:14]))), lty = 1, col = "red")
text(.6, -0.009, "R² = 0.013 .")
axis(side = 2, hadj=.5)
axis(side = 1, las = 1)
#text(1.9,55, "Taxonomic", cex = 1.4)
box()
res <- lmp(as.vector(befdat$spacodi.temp.PIst.All$Pairwise$Within) ~ as.vector(spatdist.all)[timevec==0])$residuals
summary(lmp(res ~ as.vector(soildist.all)[timevec==0]))
plot(as.vector(soildist.all)[timevec==0], res, axes = FALSE, pch = 19, xlab = "", ylab = "", mgp=c(2,0,0), ylim=c(-0.009, 0.015))
abline(lm(res ~ as.vector(soildist.all)[timevec==0]), lty = 1, col = "red")
text(.5, -0.007, "R² = 0.08*")
axis(side = 2, hadj=.5)
axis(side = 1, las = 1)
#text(1.9,55, "Taxonomic", cex = 1.4)
box()
res <- lmp(as.vector(befdat$spacodi.temp.PIst.All$Pairwise$Between) ~ as.vector(spatdist.all)[timevec!=0])$residuals
summary(lmp(res ~ as.vector(soildist.all)[timevec!=0]))
plot(as.vector(soildist.all)[timevec!=0], res, axes = FALSE, pch = 19, xlab = "", ylab = "", mgp=c(2,0,0), ylim=c(-0.011, 0.015))
#abline(lm(res ~ as.vector(soildist.all)[timevec!=0]), lty = 1, col = "red")
text(.7, -0.009, "R² = 0.007, n.s.")
axis(side = 2, hadj=.5)
axis(side = 1, las = 1)
#text(1.9,55, "Taxonomic", cex = 1.4)
box()
mtext("Environmental distance", side=1, outer = T, line=2.5, at = .54, cex = .8)
mtext("Overall", side=3, at = .2, outer = T, line=.4, cex = .9)
mtext("Within", side=3, at = .54, outer = T, line=.4, cex = .9)
mtext("Between", side=3, at = .88, outer = T, line=.4, cex = .9)
dev.off()

#######################

# turnover (PIst): within single time steps

pdf("Succ.PIst.env.single.pdf", width = 9.5, height = 2.4)
#postscript("Succ.PIst.env.single.eps", width = 9.5, height = 2.4, paper = "special", onefile = FALSE, horizontal = FALSE, pointsize=12)
#env11 <- befdat$site.order[,c(3,5,6,9,45,50,62,63,65,  86,87)]
## do the PCA:

#env11N <- befdat$site.order[,c(3,5,6,9,45,50,65,  86, 89,90,91)]

env11N <- befdat$site.order[,c(3,5,6,9,45,50,65,  86, 89,90,91)]
colnames(env11N)

pca.soil.log.scale <- rda(env11N, scale = T)
summary(pca.soil.log.scale)
soildist.all <- dist(pca.soil.log.scale$CA$u[,1:7])

#names(env11)
#soildist.all <- dist(env11[,11])
par(mfcol=c(1,5), mar=c(0,3.8,0.1,.1),oma=c(5.2,0,1.6,0), tcl=.3, las=1, cex = .75)
#for (i in c(1,5,3)){
par(bty = "l")
res <- lmp(as.vector(as.dist(as.matrix(befdat$spacodi.temp.PIst.All$Pairwise$All)[1:5,1:5])) ~ as.vector(as.dist(as.matrix(spatdist.all)[1:5,1:5])))$residuals
# stage 1
summary(lmp(res ~ as.vector(as.dist(as.matrix(soildist.all)[1:5,1:5]))))
plot(as.vector(as.dist(as.matrix(soildist.all)[1:5,1:5])), res, axes = FALSE, pch = 19, xlab = "", ylab = expression(paste(Pi[ST], " (partial residuals)")), mgp=c(2,0,0), ylim = c(-0.01, 0.011))
abline(lm(res ~ as.vector(as.dist(as.matrix(soildist.all)[1:5,1:5]))), lty = 1, col = "red")
text(.5, -.005, "R² = 0.08, n.s.")
axis(side = 2, hadj=.5)
axis(side = 1, las = 1)
#text(1.9,55, "Taxonomic", cex = 1.4)
box()
res <- lmp(as.vector(as.dist(as.matrix(befdat$spacodi.temp.PIst.All$Pairwise$All)[6:9,6:9])) ~ as.vector(as.dist(as.matrix(spatdist.all)[6:9,6:9])))$residuals
# stage 2
summary(lmp(res ~ as.vector(as.dist(as.matrix(soildist.all)[6:9,6:9]))))
plot(as.vector(as.dist(as.matrix(soildist.all)[6:9,6:9])), res, axes = FALSE, pch = 19, xlab = "", ylab = "", mgp=c(2,0,0), ylim = c(-0.01, 0.011))
abline(lm(res ~ as.vector(as.dist(as.matrix(soildist.all)[6:9,6:9]))), lty = 1, col = "red")
text(.6, -.0025, "R² = 0.52, n.s.")
axis(side = 2, hadj=.5)
axis(side = 1, las = 1)
#text(1.9,55, "Taxonomic", cex = 1.4)
box()
res <- lm(as.vector(as.dist(as.matrix(befdat$spacodi.temp.PIst.All$Pairwise$All)[10:14,10:14])) ~ as.vector(as.dist(as.matrix(spatdist.all)[10:14,10:14])))$residuals
# stage 3
summary(lmp(res ~ as.vector(as.dist(as.matrix(soildist.all)[10:14,10:14]))))
plot(as.vector(as.dist(as.matrix(soildist.all)[10:14,10:14])), res, axes = FALSE, pch = 19, xlab = "", ylab = "", mgp=c(2,0,0), ylim = c(-0.01, 0.011))
abline(lm(res ~ as.vector(as.dist(as.matrix(soildist.all)[10:14,10:14]))), lty = 1, col = "red")
text(.8, -.005, "R² = 0.16, n.s.")
axis(side = 2, hadj=.5)
axis(side = 1, las = 1)
#text(1.9,55, "Taxonomic", cex = 1.4)
box()
res <- lm(as.vector(as.dist(as.matrix(befdat$spacodi.temp.PIst.All$Pairwise$All)[15:20,15:20])) ~ as.vector(as.dist(as.matrix(spatdist.all)[15:20,15:20])))$residuals
# stage 4
summary(lmp(res ~ as.vector(as.dist(as.matrix(soildist.all)[15:20,15:20]))))
plot(as.vector(as.dist(as.matrix(soildist.all)[15:20,15:20])), res, axes = FALSE, pch = 19, xlab = "", ylab = "", mgp=c(2,0,0), ylim = c(-0.01, 0.011))
abline(lm(res ~ as.vector(as.dist(as.matrix(soildist.all)[15:20,15:20]))), lty = 1, col = "red")
text(.95,-.01, "R² = 0.19*")
axis(side = 2, hadj=.5)
axis(side = 1, las = 1)
#text(1.9,55, "Taxonomic", cex = 1.4)
box()

names(befdat$site.order[,c(3,5,6,  9,45,50,  62,63,65,  86,87,95,  96,97,98,  100,101,102,  19,76)])
 [1] "Elevation.x"       "Aspect_E"          "Aspect_N"         
 [4] "Inclination.x"     "Soil_moisture"     "ph_H2O"           
 [7] "N"                 "C"                 "C_N"              
[10] "Light"             "Red_far_red_ratio" "P.tot.all"        
[13] "P.tot.1"           "P.tot.2"           "P.tot.3"          
[16] "NO3"               "NH4"               "Nmin"             


## next step: play around with
# request P-data from bauhus

env14 <- befdat$site.order[,c(3,5,6,  9,45,50,  62,63,65,  86,87,  19,76)]
env14[,7] <- log(env14[,7])
env14[,8] <- log(env14[,8])

pairs(env14[1:5], lower.panel=panel.smooth, upper.panel=panel.cor, diag.panel=panel.hist)

pca.soil.log.scale <- rda(env14, scale = T)
#summary(pca.soil.log.scale)
soildist.all <- dist(pca.soil.log.scale$CA$u[,1:8])
##


res <- lm(as.vector(as.dist(as.matrix(befdat$spacodi.temp.PIst.All$Pairwise$All)[21:27,21:27])) ~ as.vector(as.dist(as.matrix(spatdist.all)[21:27,21:27])))$residuals
# stage 5
summary(lmp(res ~ as.vector(as.dist(as.matrix(soildist.all)[21:27,21:27]))))
plot(as.vector(as.dist(as.matrix(soildist.all)[21:27,21:27])), res, axes = FALSE, pch = 19, xlab = "", ylab = "", mgp=c(2,0,0), ylim = c(-0.01, 0.011))
abline(lm(res ~ as.vector(as.dist(as.matrix(soildist.all)[21:27,21:27]))), lty = 1, col = "red")
text(.8, -.0058, "R² = 0.39**")
axis(side = 2, hadj=.5)
axis(side = 1, las = 1)
#text(1.9,55, "Taxonomic", cex = 1.4)
box()

mtext("Environmental distance", side=1, outer = T, line=2.5, at = .54, cex = .8)
mtext("Stage 1", side=3, at = .13, outer = T, line=.4, cex = .9)
mtext("Stage 2", side=3, at = .33, outer = T, line=.4, cex = .9)
mtext("Stage 3", side=3, at = .53, outer = T, line=.4, cex = .9)
mtext("Stage 4", side=3, at = .73, outer = T, line=.4, cex = .9)
mtext("Stage 5", side=3, at = .92, outer = T, line=.4, cex = .9)

dev.off()


######################################

names(befdat$site.order[,c(3,5,6,9,19,45,50,62,63,65,73:76,86,87)])

pca.soil.log.scale <- rda(scale(log(befdat$site.order[,c(3,9,19,45,  60,62,63,65)])))
soildist.all <- dist(pca.soil.log.scale$CA$u[,1:4])

library(ncf)

partial.mantel.test(M1=as.matrix(befdat$spacodi.temp.Bst.All$Pairwise$All), M2=as.matrix(spatdist.all), M3=as.matrix(soildist.all), resamp=999, quiet=T)

pivec <- vec2dist(befdat$SES.reg.Bst$physo.ses, mat$comm)
partial.mantel.test(M1=as.matrix(pivec), M2=as.matrix(spatdist.all), M3=as.matrix(soildist.all), resamp=999, quiet=T)

library(lmPerm)

res <- lmp(as.vector(befdat$spacodi.temp.PIst.All$Pairwise$All) ~ as.vector(spatdist.all))$residuals
summary(lmp(res ~ as.vector(soildist.all)))

cor.test(res, as.vector(soildist.all))

summary(lm(res ~ as.vector(soildist.all)))

plot(as.vector(soildist.all), res)

library(smatr)

summary(sma(as.vector(befdat$spacodi.temp.PIst.All$Pairwise$All) ~ as.vector(soildist.all)))

plot(sma(res ~ as.vector(soildist.all)))

library(lmodel2)
lmodel2(res ~ as.vector(soildist.all), nperm = 2999)

# MA-regression or GLM??:
# see Smith 2009 (Am. J. ...): depending on whether bivariate relationship between Y and X is symmetric or asymmetric
# if measurement error is in both Y and X
# however, if relationship is asymmetric BUT there is measurement error in both Y and X, OLS should be used but appropropriate correction for measurement error in X should be applied!!

# PIst
# $MantelR
#       r12        r13        r23      r12.3      r13.2 
#-0.1668841  0.1702963  0.1499216 -0.1974997  0.2003583 

#$p
#[1] 0.053 0.074 0.084 0.025 0.047

##############################

# Bst
#$MantelR
#        r12         r13         r23       r12.3       r13.2 
#-0.36761703 -0.11881307  0.14992165 -0.35632710 -0.06927856 

#$p
#[1] 0.003 0.133 0.101 0.004 0.254


############################################################
## 1.2 overall environmental distance (within time steps) ##
############################################################
# include phosphorus from todt and bauhus:

phos <- read.csv("/home/oliver/Dokumente/PhD/PostPhD/Projects/BEF_China/Data/von_Bjorn/TP_CSP.csv",dec = ",")

# calculate for each depth class respectively
phos.1 <- phos[phos$Depth==1,]
colnames(phos.1)[4] <- "P.tot.1"

phos.2 <- phos[phos$Depth==2,]
colnames(phos.2)[4] <- "P.tot.2"

phos.3 <- phos[phos$Depth==3,]
colnames(phos.3)[4] <- "P.tot.3"

#  average over all all depth classes
phos.all <- aggregate(P_Initial_mg_kg ~ CSP, phos, FUN = mean)
colnames(phos.all)[2] <- "P.tot.all"

# include nitrogen-fractions from stefan:
nitro <- read.csv("/home/oliver/Dokumente/PhD/PostPhD/Projects/BEF_China/iDiv_BEF_Phylo/1_PhylostructSpatTemp/Data/SP5_Mineral_N_final_kn.csv")

(nitro[1:30,c(1,2,6,7,8,9,10)])
which(nitro$Layer_cm=="mean25")
nit.mean25 <- nitro[which(nitro$Layer_cm=="mean25"),c(1,2,6,7,8,9,10)]

NO3agg <- aggregate(NO3 ~ CSP, data = nit.mean25, mean)
NH4agg <- aggregate(NH4 ~ CSP, data = nit.mean25, mean)
Nminagg <- aggregate(Nmin ~ CSP, data = nit.mean25, mean)

Nbind <- cbind(NO3agg,NH4agg,Nminagg)

Nbind2 <- Nbind[,c(1,2,4,6)]

Nbind.order <- Nbind2[as.factor(rownames(mat$comm)), ]

befdat$site.order <- cbind(befdat$site.order, Nbind.order)

# prepare nitrogen data:
# 1) mean per layer (averaging across all seasons) (! summer CSP15) -> 4 seasons
NO3.5.all <- aggregate(NO3 ~ CSP, data = nitro[which(nitro$Layer_cm=="5"),c(1,2,6,7,8,9,10)], mean)
colnames(NO3.5.all)[2] <- "NO3.5.all"
NO3.2.5.all <- aggregate(NO3 ~ CSP, data = nitro[which(nitro$Layer_cm=="2.5"),c(1,2,6,7,8,9,10)], mean)
colnames(NO3.2.5.all)[2] <- "NO3.2.5.all"
NO3.7.5.all <- aggregate(NO3 ~ CSP, data = nitro[which(nitro$Layer_cm=="7.5"),c(1,2,6,7,8,9,10)], mean)
colnames(NO3.7.5.all)[2] <- "NO3.7.5.all"
NO3.15.all <- aggregate(NO3 ~ CSP, data = nitro[which(nitro$Layer_cm=="15"),c(1,2,6,7,8,9,10)], mean)
colnames(NO3.15.all)[2] <- "NO3.15.all"
NO3.25.all <- aggregate(NO3 ~ CSP, data = nitro[which(nitro$Layer_cm=="25"),c(1,2,6,7,8,9,10)], mean)
colnames(NO3.25.all)[2] <- "NO3.25.all"
NO3.35.all <- aggregate(NO3 ~ CSP, data = nitro[which(nitro$Layer_cm=="35"),c(1,2,6,7,8,9,10)], mean)
colnames(NO3.35.all)[2] <- "NO3.35.all"
NO3.45.all <- aggregate(NO3 ~ CSP, data = nitro[which(nitro$Layer_cm=="45"),c(1,2,6,7,8,9,10)], mean)
colnames(NO3.45.all)[2] <- "NO3.45.all"

NH4.5.all <- aggregate(NH4 ~ CSP, data = nitro[which(nitro$Layer_cm=="5"),c(1,2,6,7,8,9,10)], mean)
colnames(NH4.5.all)[2] <- "NH4.5.all"
NH4.2.5.all <- aggregate(NH4 ~ CSP, data = nitro[which(nitro$Layer_cm=="2.5"),c(1,2,6,7,8,9,10)], mean)
colnames(NH4.2.5.all)[2] <- "NH4.2.5.all"
NH4.7.5.all <- aggregate(NH4 ~ CSP, data = nitro[which(nitro$Layer_cm=="7.5"),c(1,2,6,7,8,9,10)], mean)
colnames(NH4.7.5.all)[2] <- "NH4.7.5.all"
NH4.15.all <- aggregate(NH4 ~ CSP, data = nitro[which(nitro$Layer_cm=="15"),c(1,2,6,7,8,9,10)], mean)
colnames(NH4.15.all)[2] <- "NH4.15.all"
NH4.25.all <- aggregate(NH4 ~ CSP, data = nitro[which(nitro$Layer_cm=="25"),c(1,2,6,7,8,9,10)], mean)
colnames(NH4.25.all)[2] <- "NH4.25.all"
NH4.35.all <- aggregate(NH4 ~ CSP, data = nitro[which(nitro$Layer_cm=="35"),c(1,2,6,7,8,9,10)], mean)
colnames(NH4.35.all)[2] <- "NH4.35.all"
NH4.45.all <- aggregate(NH4 ~ CSP, data = nitro[which(nitro$Layer_cm=="45"),c(1,2,6,7,8,9,10)], mean)
colnames(NH4.45.all)[2] <- "NH4.45.all"

Nmin.5.all <- aggregate(Nmin ~ CSP, data = nitro[which(nitro$Layer_cm=="5"),c(1,2,6,7,8,9,10)], mean)
colnames(Nmin.5.all)[2] <- "Nmin.5.all"
Nmin.2.5.all <- aggregate(Nmin ~ CSP, data = nitro[which(nitro$Layer_cm=="2.5"),c(1,2,6,7,8,9,10)], mean)
colnames(Nmin.2.5.all)[2] <- "Nmin.2.5.all"
Nmin.7.5.all <- aggregate(Nmin ~ CSP, data = nitro[which(nitro$Layer_cm=="7.5"),c(1,2,6,7,8,9,10)], mean)
colnames(Nmin.7.5.all)[2] <- "Nmin.7.5.all"
Nmin.15.all <- aggregate(Nmin ~ CSP, data = nitro[which(nitro$Layer_cm=="15"),c(1,2,6,7,8,9,10)], mean)
colnames(Nmin.15.all)[2] <- "Nmin.15.all"
Nmin.25.all <- aggregate(Nmin ~ CSP, data = nitro[which(nitro$Layer_cm=="25"),c(1,2,6,7,8,9,10)], mean)
colnames(Nmin.25.all)[2] <- "Nmin.25.all"
Nmin.35.all <- aggregate(Nmin ~ CSP, data = nitro[which(nitro$Layer_cm=="35"),c(1,2,6,7,8,9,10)], mean)
colnames(Nmin.35.all)[2] <- "Nmin.35.all"
Nmin.45.all <- aggregate(Nmin ~ CSP, data = nitro[which(nitro$Layer_cm=="45"),c(1,2,6,7,8,9,10)], mean)
colnames(Nmin.45.all)[2] <- "Nmin.45.all"

#
NPbind <- cbind(phos.all,phos.1,phos.2,phos.3,NO3agg,NH4agg,Nminagg,Nmin.2.5.all,Nmin.5.all)
names(NPbind)
NPbind2 <- NPbind[,c(1,2,6,10,14,16,18,20,22,24)]

NPbind.order <- NPbind2[as.factor(rownames(mat$comm)), ]

befdat$site.order <- cbind(befdat$site.order, NPbind.order)
names(befdat$site.order)

befdat$site.order <- befdat$site.order[,-c(88:90,92:103)]

# combine upper two soil layers (0-5, 5-10cm) for P
befdat$site.order$P.tot.1.2 <- apply(befdat$site.order[,90:91], 1, mean)



# 2) mean per season
# 2.1) average across all layers
# 0-10 cm (5) (summer, autumn, spring, winter)
# summer
nitro.sum <- nitro[which(nitro$Season=="Sum08"),]
Nmin.5.sum <- aggregate(Nmin ~ CSP, data = nitro.sum[which(nitro$Layer_cm=="5"),c(1,2,6,7,8,9,10)], mean)
colnames(Nmin.5.sum)[2] <- "Nmin.5.sum"

nitro.aut <- nitro[which(nitro$Season=="Aut08"),]
Nmin.5.aut <- aggregate(Nmin ~ CSP, data = nitro.aut[which(nitro$Layer_cm=="5"),c(1,2,6,7,8,9,10)], mean)
colnames(Nmin.5.aut)[2] <- "Nmin.5.aut"

nitro.spr <- nitro[which(nitro$Season=="Spr09"),]
Nmin.5.spr <- aggregate(Nmin ~ CSP, data = nitro.spr[which(nitro$Layer_cm=="5"),c(1,2,6,7,8,9,10)], mean)
colnames(Nmin.5.spr)[2] <- "Nmin.5.spr"

nitro.win <- nitro[which(nitro$Season=="Win10"),]
Nmin.5.win <- aggregate(Nmin ~ CSP, data = nitro.win[which(nitro$Layer_cm=="5"),c(1,2,6,7,8,9,10)], mean)
colnames(Nmin.5.win)[2] <- "Nmin.5.win"

# 0-50 cm (25) (summer, autumn, spring, winter)
nitro.sum <- nitro[which(nitro$Season=="Sum08"),]
Nmin.25.sum <- aggregate(Nmin ~ CSP, data = nitro.sum[which(nitro$Layer_cm=="mean25"),c(1,2,6,7,8,9,10)], mean, na.action = NULL)
colnames(Nmin.25.sum)[2] <- "Nmin.25.sum"
Nmin.25.sum[15,2] <- mean(Nmin.25.sum[,2], na.rm = T)

nitro.aut <- nitro[which(nitro$Season=="Aut08"),]
Nmin.25.aut <- aggregate(Nmin ~ CSP, data = nitro.aut[which(nitro$Layer_cm=="mean25"),c(1,2,6,7,8,9,10)], mean)
colnames(Nmin.25.aut)[2] <- "Nmin.25.aut"

nitro.spr <- nitro[which(nitro$Season=="Spr09"),]
Nmin.25.spr <- aggregate(Nmin ~ CSP, data = nitro.spr[which(nitro$Layer_cm=="mean25"),c(1,2,6,7,8,9,10)], mean)
colnames(Nmin.25.spr)[2] <- "Nmin.25.spr"

nitro.win <- nitro[which(nitro$Season=="Win10"),]
Nmin.25.win <- aggregate(Nmin ~ CSP, data = nitro.win[which(nitro$Layer_cm=="mean25"),c(1,2,6,7,8,9,10)], mean)
colnames(Nmin.25.win)[2] <- "Nmin.25.win"

############

NPbindseason <- cbind(Nmin.5.sum, Nmin.5.aut, Nmin.5.spr, Nmin.5.win, Nmin.25.sum, Nmin.25.aut, Nmin.25.spr, Nmin.25.win)

names(NPbindseason)

NPbind2 <- NPbindseason[,c(1,2,4,6,8,10,12,14,16)]

NPbind.order <- NPbind2[as.factor(rownames(mat$comm)), ]

befdat$site.order <- cbind(befdat$site.order, NPbind.order)
names(befdat$site.order)

################

pca.soil.log.scale <- rda(scale(log(befdat$site.order[,c(3,9,19,45,  60,62,63,65)])))
soildist.all <- dist(pca.soil.log.scale$CA$u[,1:4]) # change to 4 (the first 4 of the eight explain > 91% of the total variation):


names(befdat$site.order[,c(3,5,6,9,19,45,50,62,63,65,  73,74,75,  76,86,87)]) 

names(befdat$site.order[,c(3,5,6,9,45,50,62,63,65,  86,87, 19,76)]) # without "open soil", "prop_deciduous", ""Num_Species", "Num_Species_R", "Num_Ind"
# [1] "Elevation.x"       "Aspect_E"          "Aspect_N"         
# [4] "Inclination.x"     "Open_soil"         "Soil_moisture"    
# [7] "ph_H2O"            "N"                 "C"                
#[10] "C_N"               "Num_Species"       "Num_Species_R"    
#[13] "Num_Ind"           "Prop_Deciduous"    "Light"            
#[16] "Red_far_red_ratio"

env.old <- befdat$site.order[,c(3,5,6,9,19,45,50,62,63,65,   76,86,87)]
env.old.log <- log(env.old[,-c(2:3)])

env.old.2 <- cbind(env.old[,2:3], env.old.log)



env.old[,7] <- log(env.old[,7])
env.old[,8] <- log(env.old[,8])

env8 <- befdat$site.order[,c(3,5,6,9,45,50,65,  86)]
env11N <- befdat$site.order[,c(3,5,6,9,45,50,65,  86, 89,90,91)]

env11 <- befdat$site.order[,c(3,5,6,9,45,50,62,63,65,  86,87)]
env13 <- befdat$site.order[,c(3,5,6,9,45,50,62,63,65,  86,87, 19,76)]

env11[,7] <- log(env11[,7])
env11[,8] <- log(env11[,8])

env13[,7] <- log(env13[,7])
env13[,8] <- log(env13[,8])

env13[,12] <- log(env13[,12])
env13[,13] <- log(env13[,13])

pairs(env.old, lower.panel=panel.smooth, upper.panel=panel.cor, diag.panel=panel.hist)

rownames(env8) <- befdat$site.order[,1]
rownames(env11) <- befdat$site.order[,1]
rownames(env13) <- befdat$site.order[,1]

rownames(env.old) <- befdat$site.order[,1]

pdf("env.old.pairs.pdf")
pairs(env.old, lower.panel=panel.smooth, upper.panel=panel.cor, diag.panel=panel.hist)
dev.off()

pca.soil.log.scale <- rda(env.old.2, scale = T)
summary(pca.soil.log.scale)

pca.soil.log.scale <- rda(env11, scale = T)
summary(pca.soil.log.scale)

pca.soil.log.scale <- rda(env13, scale = T)
summary(pca.soil.log.scale)

pdf("pca.soil.scree.pdf", width = 5, height = 5)
screeplot(pca.soil.log.scale, bstick = T, "lines")
dev.off()

soildist.all <- dist(pca.soil.log.scale$CA$u[,1:8])

soildist.all <- dist(env8)

#Importance of components:
#                         PC1    PC2    PC3     PC4    PC5    PC6    PC7     PC8
#Eigenvalue            3.6635 2.4816 1.6734 1.05103 0.6391 0.5566 0.4026 0.32264
#Proportion Explained  0.3331 0.2256 0.1521 0.09555 0.0581 0.0506 0.0366 0.02933
#Cumulative Proportion 0.3331 0.5586 0.7108 0.80632 0.8644 0.9150 0.9516 0.98095
#                          PC9    PC10      PC11
#Eigenvalue            0.11521 0.09363 0.0006572
#Proportion Explained  0.01047 0.00851 0.0000600
#Cumulative Proportion 0.99143 0.99994 1.0000000

#Scaling 2 for species and site scores
#* Species are scaled proportional to eigenvalues
#* Sites are unscaled: weighted dispersion equal on all dimensions
#* General scaling constant of scores:  4.112364 


#Species scores
#
#                      PC1      PC2     PC3      PC4      PC5      PC6
#Elevation.x        0.7182  0.43218 -0.2955 -0.60164  0.16137 -0.46565
#Aspect_E          -0.2646 -0.66606  0.5959  0.03195  0.71015 -0.37077
#Aspect_N           0.3556 -0.47044  0.7126 -0.33851 -0.60322 -0.37925
#Inclination.x      0.6237 -0.40098  0.6400  0.56643 -0.12487  0.06226
#Soil_moisture      1.0919 -0.27120 -0.3720 -0.05104  0.03306  0.03481
#ph_H2O            -0.6841 -0.30195 -0.3991  0.67056 -0.13111 -0.40390
#N                  1.1733 -0.14697 -0.1083  0.25749  0.09162  0.03575
#C                  1.1678 -0.01496  0.1330  0.22398  0.12198  0.08118
#C_N               -0.2721  0.53108  0.8972 -0.20676  0.07738  0.23494
#Light             -0.1287 -1.07475 -0.1133 -0.35402  0.10658  0.35225
#Red_far_red_ratio  0.1993  1.08581  0.2606  0.28395  0.11745 -0.04734

pdf("pca.soil.pdf", width = 5, height = 5)
biplot(pca.soil.log.scale)
dev.off()


site <- befdat$site.order
timevec <- as.vector(dist(site$age_HB^3))

sum(timevec==0) # 62

library(lmPerm)
res <- lmp(as.vector(befdat$spacodi.temp.PIst.All$Pairwise$Within) ~ as.vector(spatdist.all)[timevec==0])$residuals
summary(lmp(res ~ as.vector(soildist.all)[timevec==0]))
plot(as.vector(soildist.all)[timevec==0], res)
abline(lm(res ~ as.vector(soildist.all)[timevec==0]))

# end

# main result:
# - overall, there is significant env. turnover within sites with respect to PIst, but no turnover with respect to Bst

# alternatively, if we take the first four of the eight axes (which explain 91 % of the total variation), we find that there is no env. turnover within time steps both with respect to PI and Bst

# PIst: significant positive env. turnover within time steps:

#Coefficients:
#                                      Estimate Iter Pr(Prob)    
#as.vector(soildist.all)[timevec == 0]  0.00733 5000    4e-04 ***
#---
#Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1 #

#Residual standard error: 0.003156 on 60 degrees of freedom
#Multiple R-Squared: 0.1644,	Adjusted R-squared: 0.1505 
#F-statistic:  11.8 on 1 and 60 DF,  p-value: 0.001079 

############################################################

# Bst:

#Coefficients:
#Estimate Iter Pr(Prob)  
#as.vector(soildist.all)[timevec == 0]  -0.0217 1382    0.068 .
#---
#Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1 

#Residual standard error: 0.01469 on 60 degrees of freedom
#Multiple R-Squared: 0.07371,	Adjusted R-squared: 0.05827 
#F-statistic: 4.774 on 1 and 60 DF,  p-value: 0.0328 


############################################################
# 1.3 overall environmental distance (between time steps)
############################################################

sum(timevec!=0) # 289

res <- lmp(as.vector(befdat$spacodi.temp.Bst.All$Pairwise$Between) ~ as.vector(spatdist.all)[timevec!=0])$residuals
summary(lmp(res ~ as.vector(soildist.all)[timevec!=0]))
plot(as.vector(soildist.all)[timevec!=0], res)
abline(lm(res ~ as.vector(soildist.all)[timevec!=0]))

end

# main result:
# overall, there is no significant env. turnover between timesteps with respect to PI and Bst


# to do: 
# 1) easy: show and plot distance decay (for four of eight axis) within time steps (Bst and PIst) - lets hope there is some significant turnover within the last stages using PIst # Yes, there is significant PIst has significant positive turn (BUT re-run analysis using SES of PIst)

# 2) monday: turnover between pairs of successional stages

# to 1) # with 8 axis from the env.small data set we find a relationship

pivec <- vec2dist(befdat$SES.reg.PIst$physo.ses, mat$comm)
pivec <- befdat$spacodi.temp.PIst.All$Pairwise$All

# 1 # 
partial.mantel.test(M1=as.matrix(pivec)[1:5,1:5], M2=as.matrix(spatdist.all)[1:5,1:5], M3=as.matrix(soildist.all)[1:5,1:5], resamp=999, quiet=T)

#$MantelR
#       r12        r13        r23      r12.3      r13.2 
#0.17382024 0.26493173 0.47832972 0.05561584 0.21020559 
#
#$p
#[1] 0.243 0.311 0.092 0.472 0.311


# 2 #
partial.mantel.test(M1=as.matrix(pivec)[6:9,6:9], M2=as.matrix(spatdist.all)[6:9,6:9], M3=as.matrix(soildist.all)[6:9,6:9], resamp=999, quiet=T)

#$MantelR
#       r12        r13        r23      r12.3      r13.2 
#-0.5907687 -0.2919344 -0.3044487 -0.7460171 -0.6138829 
#
#$p
#[1] 0.052 0.402 0.181 0.052 0.174

# 3 #
partial.mantel.test(M1=as.matrix(pivec)[10:14,10:14], M2=as.matrix(spatdist.all)[10:14,10:14], M3=as.matrix(soildist.all)[10:14,10:14], resamp=999, quiet=T)

#$MantelR
#        r12         r13         r23       r12.3       r13.2 
# 0.37789356 -0.07904188  0.82591389  0.78852285 -0.74934237 

#$p
#[1] 0.119 0.465 0.022 0.039 0.068

# 4 #
partial.mantel.test(M1=as.matrix(pivec)[15:20,15:20], M2=as.matrix(spatdist.all)[15:20,15:20], M3=as.matrix(soildist.all)[15:20,15:20], resamp=999, quiet=T)
#$MantelR
#       r12        r13        r23      r12.3      r13.2 
#-0.3482801  0.2435611  0.4359848 -0.5206711  0.4687080 

#$p
#[1] 0.115 0.294 0.128 0.022 0.047

# 5 #
partial.mantel.test(M1=as.matrix(pivec)[21:27,21:27], M2=as.matrix(spatdist.all)[21:27,21:27], M3=as.matrix(soildist.all)[21:27,21:27], resamp=999, quiet=T)
#$MantelR
#       r12        r13        r23      r12.3      r13.2 
#-0.4079314  0.3887781  0.1600169 -0.5169472  0.5038060 
#
#$p
#[1] 0.124 0.089 0.268 0.019 0.049



# significant environmental turnover (PIst shows positive turnover along env. distance in the last successional time step)
# what does it mean that spatial phylogenetic clustering (PIst) in the fourth successional time step has nothing to do with environmental distance

timevec <- as.vector(dist(site$age_HB[site$age_HB==3 | site$age_HB==4]))

sum(timevec!=0)

res <- lmp(as.vector(befdat$spacodi.temp.PIst.All$Pairwise$All) ~ as.vector(spatdist.all)[timevec!=0])$residuals
summary(lmp(res ~ as.vector(soildist.all)[timevec!=0]))

end

# statistical comparison of sets of values by randomization

res <- resamp.test(obs=befdat$spacodi.temp.PIst.All$Pairwise$All, exp=befdat$spacodi.temp.PIst.All$Pairwise$Within, iter=100, two.tailed=TRUE)

# compares means by bootstrap resampling of differences between empirical distributions


############################################################
############################################################
############################################################



## continue here
# !!! change back to without using Loropetalum chi.
#befdat$Succ.beta.Bst.reg.lor <- befdat$Succ.beta.Bst.reg

befdat$Succ.beta.Bst.reg <- spa.PD.step5(com = com, phy = phy, value = 7, nullmod = "taxaShuffle", runs = 99)
save(befdat, file = paste(path.data,"befdat.Rdata", sep = ""))




befdat$Succ.beta.Pst.reg <- spa.PD.step5(com = com, phy = phy, value = 6, nullmod = "taxaShuffle", runs = 999)
save(befdat, file = paste(path.data,"befdat.Rdata", sep = ""))

# age-class phylogeny
phy <- mat$phy
befdat$Succ.beta.PIst <- spa.PD.step5(com = com, phy = phy, value = 8, nullmod = "taxaShuffle", runs = 999)
save(befdat, file = paste(path.data,"befdat.Rdata", sep = ""))
befdat$Succ.beta.Bst <- spa.PD.step5(com = com, phy = phy, value = 7, nullmod = "taxaShuffle", runs = 999)
save(befdat, file = paste(path.data,"befdat.Rdata", sep = ""))
befdat$Succ.beta.Pst <- spa.PD.step5(com = com, phy = phy, value = 6, nullmod = "taxaShuffle", runs = 999)
save(befdat, file = paste(path.data,"befdat.Rdata", sep = ""))

########################
# 1.2.2 SES, for each site
########################

beta.tax.shuff <- function(samp, phy, runs, value, nullmod){
  Res = list()
  for (r in 1:runs) {
    Res <- c(Res, list(as.dist(spacodi.calc(sp.plot = samp, phy = eval(parse(text=nullmod))(cophenetic(phy)), prune = TRUE, pairwise = TRUE)[[value]])))
    # Res <- c(Res, list(Rao(sample=t(samp.order), dfunc=NULL, dphyl=phy.shuff, weight=F, Jost=T, structure=NULL)$PD$Alpha))
  }
  return(Res)
}

ses.alpha <- function(obs, rand){
  rand <- t(as.data.frame(lapply(rand, as.vector)))
  physo.obs <- as.numeric(obs)
  physo.mean <- apply(rand, MARGIN = 2, FUN = mean, na.rm = TRUE)
  physo.sd <- apply(rand, MARGIN = 2, FUN = sd, na.rm = TRUE)
  physo.ses <- (physo.obs - physo.mean)/physo.sd
  physo.obs.rank <- apply(X = rbind(physo.obs, rand), MARGIN = 2, FUN = rank)[1, ]
  physo.obs.rank <- ifelse(is.na(physo.mean), NA, physo.obs.rank)
  data.frame(physo.obs, physo.mean, physo.sd, physo.obs.rank, physo.ses, physo.obs.p = physo.obs.rank/(dim(rand)[1] + 1))
}

com <- t(mat$comm)

# regional
phy <- befdat$phy.gut.ultra.nongymnocult

value <- 8
PD.taxshuff.beta <- beta.tax.shuff(samp = com, phy = phy, runs = 999, value = value, nullmod = "taxaShuffle")
beta.obs <- as.dist(spacodi.calc(sp.plot = com, phy = phy, prune = TRUE, pairwise = TRUE)[[value]])
ses.PD.beta <- ses.alpha(beta.obs, PD.taxshuff.beta)
befdat$SES.reg.PIst <- ses.PD.beta

value <- 7
PD.taxshuff.beta <- beta.tax.shuff(samp = com, phy = phy, runs = 999, value = value, nullmod = "taxaShuffle")
beta.obs <- as.dist(spacodi.calc(sp.plot = com, phy = phy, prune = TRUE, pairwise = TRUE)[[value]])
ses.PD.beta <- ses.alpha(beta.obs, PD.taxshuff.beta)
befdat$SES.reg.Bst <- ses.PD.beta

value <- 6
PD.taxshuff.beta <- beta.tax.shuff(samp = com, phy = phy, runs = 999, value = value, nullmod = "taxaShuffle")
beta.obs <- as.dist(spacodi.calc(sp.plot = com, phy = phy, prune = TRUE, pairwise = TRUE)[[value]])
ses.PD.beta <- ses.alpha(beta.obs, PD.taxshuff.beta)
befdat$SES.reg.Pst <- ses.PD.beta

save(befdat, file = paste(path.data,"befdat.Rdata", sep = ""))

# age pool
phy <- mat$phy

value <- 8
PD.taxshuff.beta <- beta.tax.shuff(samp = com, phy = phy, runs = 999, value = value, nullmod = "taxaShuffle")
beta.obs <- as.dist(spacodi.calc(sp.plot = com, phy = phy, prune = TRUE, pairwise = TRUE)[[value]])
ses.PD.beta <- ses.alpha(beta.obs, PD.taxshuff.beta)
befdat$SES.PIst <- ses.PD.beta

value <- 7
PD.taxshuff.beta <- beta.tax.shuff(samp = com, phy = phy, runs = 999, value = value, nullmod = "taxaShuffle")
beta.obs <- as.dist(spacodi.calc(sp.plot = com, phy = phy, prune = TRUE, pairwise = TRUE)[[value]])
ses.PD.beta <- ses.alpha(beta.obs, PD.taxshuff.beta)
befdat$SES.Bst <- ses.PD.beta

value <- 6
PD.taxshuff.beta <- beta.tax.shuff(samp = com, phy = phy, runs = 999, value = value, nullmod = "taxaShuffle")
beta.obs <- as.dist(spacodi.calc(sp.plot = com, phy = phy, prune = TRUE, pairwise = TRUE)[[value]])
ses.PD.beta <- ses.alpha(beta.obs, PD.taxshuff.beta)
befdat$SES.Pst <- ses.PD.beta

save(befdat, file = paste(path.data,"befdat.Rdata", sep = ""))

###############
# 2) Analysis #
###############
# alpha diversity

# forward.selection
library(PCNM)

[1] "SR"    "Dpw"   "Dstar" "Delta" "Age"   "PD"    "HED"   "HAED"  "IAC"  
[10] "PAE"

i <- 4
sel.env <- forward.sel(befdat$Alpha[,i], befdat$site.order[,c(3,9,19,45,57,60,62,63,65,70,71)], alpha=0.05)
sel.soil <- forward.sel(befdat$Alpha[,i], befdat$site.order[,c(45,60,62,63,65,70,71)], alpha=0.05)
sel.all <- forward.sel(befdat$Alpha[,i], befdat$site.order[,-c(17,36,37,58,59,64)], alpha=0.05)
sel.env
sel.soil
sel.all

SR: no variables selected
Dpw: Tree_age_max5, Elevation
Dstar: nothing selected
Delta: N_common_adults

# varpart
# transform data ? 
# alpha raw
mm.soil <- model.matrix(~ Soil_moisture + pH + N + C + C_N, befdat$site.order)[,-1]
mm.age <- model.matrix(~ Tree_age_max5, befdat$site.order)[,-1]
mm.ele <- model.matrix(~ Elevation, befdat$site.order)[,-1]
i <- 4

mod <-  varpart(befdat$SES.reg.Dplus$physo.ses, mm.soil, mm.age, mm.ele)
mod
showvarparts(3, bg = col2)
plot(mod, bg = col2)

pdf("varpart.alpha.ses.delta.pdf")
plot(mod, bg = col2)
dev.off()

# multivariate regression

#######################
# partial mantel test #
#######################

vec2dist <- function(betavec, com){
  mat <- matrix(NA, nrow = dim(com)[1], ncol = dim(com)[1])
  rownames(mat) <- rownames(com) 
  colnames(mat) <- rownames(com) 
  d <- as.dist(mat)
  for (i in 1:length(betavec)){
      d[i] <- betavec[i]
    }
  d
}


time.dist.cont.all <- dist(befdat$site.order[,57])
spatdist.all <- (dist(befdat$site.order[,70:71]))
elevdist.all <- (dist(befdat$site.order[,3]))
soildist.all <- (befdat$pca.soil.dist)
cndist.all <- dist(befdat$site.order[,65])

cor(befdat$SES.reg.PIst$physo.ses, as.vector(time.dist.cont.all))

library(ncf)

pivec <- vec2dist(befdat$SES.reg.PIst$physo.ses, mat$comm)

partial.mantel.test(M1=as.matrix(pivec)[1:5,1:5], M2=as.matrix(spatdist.all)[1:5,1:5], M3=as.matrix(soildist.all)[1:5,1:5], resamp=999, quiet=T)

partial.mantel.test(M1=as.matrix(pivec)[6:9,6:9], M2=as.matrix(spatdist.all)[6:9,6:9], M3=as.matrix(soildist.all)[6:9,6:9], resamp=999, quiet=T)

partial.mantel.test(M1=as.matrix(pivec)[10:14,10:14], M2=as.matrix(spatdist.all)[10:14,10:14], M3=as.matrix(soildist.all)[10:14,10:14], resamp=999, quiet=T)

partial.mantel.test(M1=as.matrix(pivec)[15:20,15:20], M2=as.matrix(spatdist.all)[15:20,15:20], M3=as.matrix(soildist.all)[15:20,15:20], resamp=999, quiet=T)

partial.mantel.test(M1=as.matrix(pivec)[21:27,21:27], M2=as.matrix(spatdist.all)[21:27,21:27], M3=as.matrix(soildist.all)[21:27,21:27], resamp=999, quiet=T)


as.vector(as.dist(as.matrix(soildist.all)[21:27,21:27]))

# plot phylogenetic diversity over time:
befdat$site.order$age_HB <- as.numeric(befdat$site.order$age_HB)

summary(lm(befdat$Alpha[,4] ~ befdat$site.order$age_HB))

# next step: create env.dist with more variables and less vectors

# enviromental (soil) variables
#names(befdat$site.order[,c(3,9,19,45,  60,62,63,65)])
#[1] "Elevation"     "Inclination"   "Open_soil"     "Soil_moisture"
#[5] "pH"            "N"             "C"             "C_N"          

pca.soil.log.scale <- rda(scale(log(befdat$site.order[,c(45,  60,62,63,65)])))
soildist.all <- dist(pca.soil.log.scale$CA$u[,1:2])

befdat$pca.soil.dist <- pca.soil.dist

##
# variation partitioning
###

mm.soil <- model.matrix(~ Soil_moisture + pH + N + C + C_N, befdat$site.order)[,-1]
mm.age <- model.matrix(~ Tree_age_max5, befdat$site.order)[,-1]
mm.ele <- model.matrix(~ Elevation, befdat$site.order)[,-1]

pivec <- vec2dist(befdat$SES.reg.PIst$physo.ses, mat$comm)

mod <- varpart(pcoa(pivec)$vectors[6:9,1:10], mm.soil[6:9,], mm.ele[6:9])

vare.cap <- capscale(pcoa(pivec)$vectors[1:5,1:5] ~  C_N, befdat$site.order[1:5,], dist="euclidean")
anova(vare.cap)

vare.cap <- varpart(pcoa(pivec)$vectors[21:27,1:5], mm.soil[21:27,], mm.ele[21:27])


mod
showvarparts(2, bg = col2)
plot(mod, bg = col2)

pdf("varpart.alpha.ses.delta.pdf")
plot(mod, bg = col2)
dev.off())

########################################
# plot beta diversity
############################

cbind.fill <- function (alphalist) {
require(plyr) 
bind <- rbind.fill.matrix(t(as.matrix(as.vector(alphalist[[1]]))), t(as.matrix(as.vector(alphalist[[2]]))) ,t(as.matrix(as.vector(alphalist[[3]]))), t(as.matrix(as.vector(alphalist[[4]]))), t(as.matrix(as.vector(alphalist[[5]]))))
t(bind)
}

library(psych)

postscript("Succ.beta.bef.reg.eps", width = 5.1, height = 3, paper = "special", onefile = FALSE, horizontal = FALSE, pointsize=12)
# pdf("Succ.beta.bef.reg.pdf", width = 5.1, height = 3)
par(mfcol=c(1,2), mar=c(0,3.8,0.5,.6),oma=c(5.2,0,1.6,0), tcl=.3, las=1, cex = .75)
#for (i in c(1,5,3)){
par(bty = "l")
error.bars(cbind.fill(befdat$Succ.beta.Bst.reg$Pairwise), bar=F, alpha = 0.05, sd = F, pch = 15, arrow.len = .00, lwd = 3, cex = 1.2, axes = FALSE, xlim = c(0.9,5.2), ylim = c(-0.04, 0.026), main = "", xlab = "", ylab = expression(B[ST]), mgp=c(2.5,0,0))
polygon(y=c(befdat$Succ.beta.Bst.reg$Results[,4], rev(befdat$Succ.beta.Bst.reg$Results[,5])), x=c(1:5,5:1), col="grey76", border = NA)
error.bars(cbind.fill(befdat$Succ.beta.Bst.reg$Pairwise), bar=F, alpha = 0.05, sd = F, pch = 15, arrow.len = .00, lwd = 3, cex = 1.2, axes = FALSE, xlim = c(0.9,5.2), ylim = c(-0.04, 0.026), main = "", xlab = "", ylab = expression(B[ST]), mgp=c(2.5,0,0), add = T)
lines(befdat$Succ.beta.Bst.reg$Results[,2], lty = 3)
#text(1,52, "a");text(2,52, "b");text(3,52, "c");text(4,52, "c")
abline(h = 0, lty = 1, lwd = .5)
axis(side = 2, hadj=.7)
axis(side = 1, 1:5, c("T1","T2","T3","T4","T5"), las = 1)
#text(1.9,55, "Taxonomic", cex = 1.4)
box()
error.bars(cbind.fill(befdat$Succ.beta.PIst.reg$Pairwise), bar=F, alpha = 0.05, sd = F, pch = 15, arrow.len = .00, lwd = 3, cex = 1.2, axes = FALSE, xlim = c(0.9,5.2), ylim = c(-0.003, 0.0065), main = "", xlab = "", ylab = expression(Pi[ST]), mgp=c(2.5,0,0))
polygon(y=c(befdat$Succ.beta.PIst.reg$Results[,4], rev(befdat$Succ.beta.PIst.reg$Results[,5])), x=c(1:5,5:1), col="grey76", border = NA)
error.bars(cbind.fill(befdat$Succ.beta.PIst.reg$Pairwise), bar=F, alpha = 0.05, sd = F, pch = 15, arrow.len = .00, lwd = 3, cex = 1.2, axes = FALSE, xlim = c(0.9,5.2), ylim = c(-0.003, 0.0065), main = "", xlab = "", ylab = expression(Pi[ST]), mgp=c(2.5,0,0), add = T)
lines(befdat$Succ.beta.Bst.reg$Results[,2], lty = 3)
#text(1,52, "a");text(2,52, "b");text(3,52, "c");text(4,52, "c")
abline(h = 0, lty = 1, lwd = .5)
axis(side = 2, hadj=0.7)
axis(side = 1, 1:5, c("T1","T2","T3","T4","T5"), las = 1)
#text(1.9,55, "Taxonomic", cex = 1.4)
box()
mtext("Successional stage (Years)", side=1, outer = T, line=4, at = .54, cex = .8)
#mtext("(a) Taxonomic", side=3, at = .152, outer = T, line=.4, cex = .9)
#mtext("(b) Phylogenetic", side=3, at = .494, outer = T, line=.4, cex = .9)
#mtext("(c) Functional", side=3, at = .815, outer = T, line=.4, cex = .9)
dev.off()


#############################################
#### plot alpha #############################
#############################################

postscript("Succ.alpha.bef.eps", width = 6.5, height = 2.6, paper = "special", onefile = FALSE, horizontal = FALSE, pointsize=12)
# pdf("Succ.alpha.bef.pdf", width = 6.5, height = 2.6)
par(mfcol=c(1,3), mar=c(0,3.8,0.5,.6),oma=c(5.2,0,1.6,0), tcl=.3, las=1, cex = .75)
#for (i in c(1,5,3)){
par(bty = "l")
error.bars(befdat$SR, bar=F, alpha = 0.05, sd = F, pch = 15, arrow.len = .0, lwd = 3, cex = 1.2, axes = FALSE, xlim = c(0.9,5.2), ylim = c(18,61), main = "", xlab = "", ylab = "Species richness", mgp=c(2,0,0))
text(4,20, "R² = 0.08, n.s.")
abline(lm(colSums(befdat$com.order!=0) ~ befdat$site.order$age_HB), lty = 3)
axis(side = 2, hadj=.5)
axis(side = 1, 1:5, c("T1","T2","T3","T4","T5"), las = 1)
#text(1.9,55, "Taxonomic", cex = 1.4)
box()
error.bars(cbind.fill(befdat$Alpha.step.Dstar.w.1a$Alpha), bar=F, alpha = 0.05, sd = F, pch = 15, arrow.len = .00, lwd = 3, cex = 1.2, axes = FALSE, xlim = c(0.9,5.2), ylim = c(95,117), main = "", xlab = "", ylab = expression(Delta[italic(W)]^{symbol("\052")[italic(P)]}), mgp=c(2,0,0))
text(4,96, "R² = 0.01, n.s.")
abline(lm(unlist(befdat$Alpha.step.Dstar.w.1a$Alpha) ~ befdat$site.order$age_HB), lty = 3)
axis(side = 2, hadj=.5)
axis(side = 1, 1:5, c("T1","T2","T3","T4","T5"), las = 1)
#text(1.9,55, "Taxonomic", cex = 1.4)
box()
error.bars(cbind.fill(befdat$Alpha.step.Delta.pw.1a$Alpha), bar=F, alpha = 0.05, sd = F, pch = 15, arrow.len = .00, lwd = 3, cex = 1.2, axes = FALSE, xlim = c(0.9,5.2), ylim = c(105,113), main = "", xlab = "", ylab = expression(Delta[italic(W)]^{italic(P)}), mgp=c(2,0,0))
text(4,105.3, "R² = 0.05, n.s.")
abline(lm(unlist(befdat$Alpha.step.Delta.pw.1a$Alpha) ~ befdat$site.order$age_HB), lty = 3)
axis(side = 2, hadj=.5)
axis(side = 1, 1:5, c("T1","T2","T3","T4","T5"), las = 1)
#text(1.9,55, "Taxonomic", cex = 1.4)
box()
mtext("Successional stage (Years)", side=1, outer = T, line=4, at = .54, cex = .8)
#mtext("(a) Taxonomic", side=3, at = .152, outer = T, line=.4, cex = .9)
#mtext("(b) Phylogenetic", side=3, at = .494, outer = T, line=.4, cex = .9)
#mtext("(c) Functional", side=3, at = .815, outer = T, line=.4, cex = .9)
dev.off()


summary(lm(unlist(befdat$Alpha.step.Dstar.w.1a$Alpha) ~ scale(befdat$site.order$age_HB)))
summary(lm(unlist(befdat$Alpha.step.Delta.pw.1a$Alpha) ~ befdat$site.order$age_HB))
summary(lm(scale(colSums(befdat$com.order!=0)) ~ scale(befdat$site.order$age_HB)))
# R-squared: 0.0758, p-value: 0.1645

################
## regression on distance matrices
################
pivec <- vec2dist(befdat$SES.reg.PIst$physo.ses, mat$comm)

mrm.4 <- MRM(dist(as.matrix(pivec)[15:20,15:20]) ~ dist(as.matrix(soildist.all)[15:20,15:20]), nperm=1000)
mrm.4

mrm.5 <- MRM(dist(as.matrix(pivec)[21:27,21:27]) ~ dist(as.matrix(soildist.all)[21:27,21:27]), nperm=1000)
mrm.5   

# for plotting mantel correlations:
# show rM (mantel):

# pdf("Succ.PIst.env.pdf", width = 9.5, height = 2.4)
postscript("Succ.PIst.env.eps", width = 9.5, height = 2.4, paper = "special", onefile = FALSE, horizontal = FALSE, pointsize=12)

par(mfcol=c(1,5), mar=c(0,3.8,0.1,.1),oma=c(5.2,0,1.6,0), tcl=.3, las=1, cex = .75)
#for (i in c(1,5,3)){
par(bty = "l")

plot(as.vector(as.dist(as.matrix(soildist.all)[1:5,1:5])), as.vector(as.dist(as.matrix(befdat$spacodi.temp.PIst.All$Pairwise$All)[1:5,1:5])), axes = FALSE, pch = 19, xlab = "", ylab = expression(Pi[ST_Stand]), mgp=c(2,0,0))
#abline(lm(as.vector(as.dist(as.matrix(pivec)[1:5,1:5])) ~ as.vector(as.dist(as.matrix(soildist.all)[1:5,1:5]))), lty = 1, col = "red")

text(.7,3.5, "rM = -0.35, n.s.")
axis(side = 2, hadj=.5)
axis(side = 1, las = 1)
#text(1.9,55, "Taxonomic", cex = 1.4)
box()

plot(as.vector(as.dist(as.matrix(soildist.all)[6:9,6:9])), as.vector(as.dist(as.matrix(pivec)[6:9,6:9])), axes = FALSE, pch = 19, xlab = "", ylab = "", mgp=c(2,0,0), ylim = c(-0.5,1.5))
#abline(lm(as.vector(as.dist(as.matrix(pivec)[6:9,6:9])) ~ as.vector(as.dist(as.matrix(soildist.all)[6:9,6:9]))), lty = 1, col = "red")
text(.62,1.3, "rM = -0.01, n.s.")
axis(side = 2, hadj=.5)
axis(side = 1, las = 1)
#text(1.9,55, "Taxonomic", cex = 1.4)
box()
plot(as.vector(as.dist(as.matrix(soildist.all)[10:14,10:14])), as.vector(as.dist(as.matrix(pivec)[10:14,10:14])), axes = FALSE, pch = 19, xlab = "", ylab = "", mgp=c(2,0,0), ylim = c(-1,6))
#abline(lm(as.vector(as.dist(as.matrix(pivec)[10:14,10:14])) ~ as.vector(as.dist(as.matrix(soildist.all)[10:14,10:14]))), lty = 1, col = "red")
text(.82,5.5, "rM = 0.05, n.s.")
axis(side = 2, hadj=.5)
axis(side = 1, las = 1)
#text(1.9,55, "Taxonomic", cex = 1.4)
box()
plot(as.vector(as.dist(as.matrix(soildist.all)[15:20,15:20])), as.vector(as.dist(as.matrix(pivec)[15:20,15:20])), axes = FALSE, pch = 19, xlab = "", ylab = "", mgp=c(2,0,0), ylim = c(-1,5.5))
abline(lm(as.vector(as.dist(as.matrix(pivec)[15:20,15:20])) ~ as.vector(as.dist(as.matrix(soildist.all)[15:20,15:20]))), lty = 1, col = "red")
text(1.05,4.8, "rM = 0.27 .")
axis(side = 2, hadj=.5)
axis(side = 1, las = 1)
#text(1.9,55, "Taxonomic", cex = 1.4)
box()
plot(as.vector(as.dist(as.matrix(soildist.all)[21:27,21:27])), as.vector(as.dist(as.matrix(pivec)[21:27,21:27])), axes = FALSE, pch = 19, xlab = "", ylab = "", mgp=c(2,0,0), ylim = c(-2,5))
abline(lm(as.vector(as.dist(as.matrix(pivec)[21:27,21:27])) ~ as.vector(as.dist(as.matrix(soildist.all)[21:27,21:27]))), lty = 1, col = "red")
text(.65,4.4, "rM = 0.53 *")
axis(side = 2, hadj=.5)
axis(side = 1, las = 1)
#text(1.9,55, "Taxonomic", cex = 1.4)
box()
mtext("Environmental distance", side=1, outer = T, line=4, at = .54, cex = .8)
mtext("Stage 1", side=3, at = .13, outer = T, line=.4, cex = .9)
mtext("Stage 2", side=3, at = .33, outer = T, line=.4, cex = .9)
mtext("Stage 3", side=3, at = .53, outer = T, line=.4, cex = .9)
mtext("Stage 4", side=3, at = .73, outer = T, line=.4, cex = .9)
mtext("Stage 5", side=3, at = .92, outer = T, line=.4, cex = .9)

dev.off()

###########################
mat <- match.phylo.comm(phy=befdat$phy.143.ultra, comm=t(befdat$com.order))

PI=spacodi.by.nodes(sp.plot=t(mat$comm[1:5,]), sp.parm="PIst", phy=mat$phy, return.all=TRUE, method="1s")
spacodi.treeplot(PI, mat$phy, sig.plot=TRUE, cex=list(pch = 1.5, tip = 0.3, legend = 0.75), add.id=FALSE, outfile = "T1.PIst.sig.pdf")
   
###########################

###################################################

#############

# try different null models taking species pool into account
# 1) model 2 in phylocom ("phylogeny.pool" in picante) (is it the same as model 1p in spacodi?, and the same as "taxa.labels" (but using regional tree) in picante?)

mat <- match.phylo.comm(phy=befdat$phy.143.ultra, comm=t(befdat$com.order))

sp.permut=spacodi.by.nodes(sp.plot=t(mat$comm)[,21:27], phy=mat$phy, n.rep=10, sp.parm = "PIst", method = "1s")
pdf("PIst_permutplot_T5.pdf", width = 7, height = 8)
spacodi.permutplot(sp.permut,bty="n", cex=list(pch=1.2, rand=0.1, node=.1, legend=0.7), transp=1)
dev.off()


################################################################
# plot SES from partial PI-randomization for each time step
#############################################################

PIst.part <- read.csv(paste(path.results,"PIst_part.csv", sep = ""), head = T)
PIst.part$ses <- (PIst.part$obs - PIst.part$mean.rand)/PIst.part$sd.rand

befdat$PIst.part <- PIst.part
save(befdat, file = paste(path.data,"befdat.Rdata", sep = ""))

# max. divergence size is 128.1, therefore breaking up the tree in 11 equidistant pieces ranging from 28 to 128 

#!!! try 11 eleven steps, but 30-130

library(lattice)
befdat$PIst.part$stage <- as.factor(befdat$PIst.part$stage)

levels(befdat$PIst.part$stage) <- c("Stage 1","Stage 2","Stage 3","Stage 4","Stage 5")

# grey-scale version:
div <- xyplot(ses ~ interval, groups=stage, data = befdat$PIst.part, type = "smooth", xlim = c(17, 130), ylim = c(-2.5, 3.5), lty = c(3,2,1,2,1), par.settings = list(axis.line = list(col = 0)),scales=list(col=1,tck=c(-1,0)),  # remove top and right axes
              panel=function(...){
                lims <- current.panel.limits()
                panel.xyplot(...)
                panel.abline(h=lims$ylim[1],v=lims$xlim[1], lwd = 2)
                panel.abline(h=c(2,-2), lty = 2)
              },
              layout.heights=list(axis.xlab.padding = 1),
lwd = 2.5, col = c("grey","grey","grey","black","black"), xlab = "Time (Myr)", ylab = expression(Pi[ST_Stand]), key=list(space="inside",  between = 1, padding.text = 2, just = c(.7, .5), columns = 2, lines = list(lty = c(3,2,1,2,1), lwd = 2.5, col = c("grey","grey","grey","black","black")),text = list(levels(befdat$PIst.part$stage))))
plot(div)

#pdf(file = "PIst_part_succ_smooth.pdf",width = 4.8, height = 4.8)
postscript(file = "PIst_part_succ_smooth.eps",width = 4.8, height = 4.8, paper = "special", onefile = FALSE, horizontal = FALSE, pointsize=12)
plot(div)
dev.off()

######### color version

div <- xyplot(ses ~ interval, groups=stage, data = befdat$PIst.part, type = "l", xlim = c(17, 130), ylim = c(-2.5, 4.5), lty = c(1,1,1,1,1), par.settings = list(axis.line = list(col = 0)),scales=list(col=1,tck=c(-1,0)),  # remove top and right axes
              panel=function(...){
                lims <- current.panel.limits()
                panel.xyplot(...)
                panel.abline(h=lims$ylim[1],v=lims$xlim[1], lwd = 2)
                panel.abline(h=c(2,-2), lty = 2)
              },
              layout.heights=list(axis.xlab.padding = 1),
lwd = 2.5, col = c("red", "orange","yellow", "green","blue"), xlab = "Time (Myr)", ylab = expression(Pi[ST_Stand]), key=list(space="inside",  between = 1, padding.text = 2, just = c(.7, .5), columns = 2, lines = list(lty = c(1,1,1,1,1), lwd = 2.5, col = c("red", "orange","yellow", "green","blue")),text = list(levels(befdat$PIst.part$stage))))
plot(div)

# pdf(file = "PIst_part_succ_col_discrete.pdf",width = 6, height = 6)
postscript(file = "PIst_part_succ_col_discrete.eps",width = 5, height = 5, paper = "special", onefile = FALSE, horizontal = FALSE, pointsize=12)
plot(div)
dev.off()


###############################
###############################

data(sp.example)
attach(sp.example)
plot(phy)
mtext("original phylogeny")
# reshuffle within a time range
time=1/5
bb=branching.times(phy)
bb=bb/max(bb)
nodes=(Ntip(phy)+1):max(phy$edge)
nodes[bb<=time]=1
dev.new()
plot(resamp.phy(phy, time.threshold=time, proportion=TRUE))
mtext("reshuffled phylogeny showing affected nodes")
nodelabels(cex=ifelse(nodes==1, 2, NA), col=ifelse(nodes==1, 1, NA), pch=19)



## altered function to fit smoothing line

spacodi.permutplot <- function (spacodi.permutations, cex = list(pch = 1.5, rand = 0.1, 
    node = 0.5, legend = 0.75), transp = 0.8, col = list("black", 
    "lightgray"), bg = list("white", "lightgray", "black"), all.points = TRUE, 
    add.id = FALSE, sig.plot = TRUE, cut.off = 0.05, envelope = FALSE, 
    outfile = NULL, ...) 
{
    sp.parm = strsplit(names(spacodi.permutations)[1], ".", fixed = TRUE)[[1]][2]
    if (is.atomic(cex)) 
        cex = list(cex, cex/10, cex/2)
    o.orig = spacodi.permutations[[paste("observed", sp.parm, 
        sep = ".")]][which(!is.na(spacodi.permutations[[paste("observed", 
        sp.parm, sep = ".")]][[sp.parm]])), ]
    o = as.vector(o.orig[[sp.parm]])
    e = spacodi.permutations[[paste("expected", sp.parm, sep = ".")]]
    lim.set <- function(obj, scl) {
        out = lapply(obj, function(x) {
            foo = x + (x * scl)
            return(foo)
        })
        return(unlist(out))
    }
    x.lim = lim.set(c(min(-o.orig$node.time), max(-o.orig$node.time)), 
        0.05)
    if (all.points == TRUE) {
        range.array = array(dim = c(nrow(e), 2))
        for (rr in 1:nrow(e)) {
            r.foo = e[rr, which(!is.na(e[rr, ]))]
            if (length(r.foo) > 0) {
                range.array[rr, 1] = min(r.foo)
                range.array[rr, 2] = max(r.foo)
            }
            else {
                lapply(range.array[rr, ], function(obj) obj = NA)
            }
        }
        Bst.lim.y = c(l.b <- min(as.vector(o), as.vector(unlist(e)), 
            na.rm = TRUE), u.b <- max(as.vector(o), as.vector(unlist(e)), 
            na.rm = TRUE))
        y.scl = 0.35
        y.lim.exp = lim.set(Bst.lim.y, y.scl)
        y.lim = lim.set(c(min(o, na.rm = TRUE), max(o, na.rm = TRUE)), 
            y.scl)
        if (diff(y.lim.exp) > diff(y.lim)) 
            warning(paste("Some expected ", sp.parm, " were excluded from the plot.", 
                sep = ""))
    }
    else {
        y.lim = lim.set(c(min(o, na.rm = TRUE), max(o, na.rm = TRUE)), 
            y.scl)
    }
    if (!is.null(outfile)) 
        pdf(file = outfile)
    plot(-o.orig$node.time, o.orig[[sp.parm]], main = paste(sp.parm, 
        " permutations through time", sep = ""), xlab = "branching times", 
        ylab = sp.parm, ylim = y.lim, xlim = c(x.lim[1], 0), 
        type = "n", ...)
    if (all.points == TRUE) {
        e = as.data.frame(e)
        for (pp in 1:nrow(e)) {
            b.time = o.orig$node.time[which(o.orig$node.ID == 
                row.names(e)[pp])]
            points(rep(-b.time, length(e[pp, ])), e[pp, ], cex = cex$rand, 
                col = col[[2]], bg = bg[[2]], pch = 21)
        }
    }
    if (envelope == TRUE) {
        poor = which(is.na(range.array[, 1]))
        if (length(poor) > 0) 
            min.array = range.array[-poor, 1]
        else min.array = range.array[, 1]
        if (length(poor) > 0) 
            max.array = range.array[-poor, 2]
        else max.array = range.array[, 2]
        if (length(poor) > 0) 
            o.nodes = -o.orig$node.time[-poor]
        else o.nodes = -o.orig$node.time
        lines(smooth.spline(o.nodes, min.array), lty = 2)
        lines(smooth.spline(o.nodes, max.array), lty = 2)
    }
    if (sig.plot == TRUE) {
        if (any(names(spacodi.permutations) == "randomization.test")) {
            rr = spacodi.permutations$randomization.test
        }
        else {
            stop("Must have randomization.test results supplied with spacodi.permutations.")
        }
        bg.sig = vector()
        if (length(bg) == 3) 
            bg.cols = bg
        else bg.cols = list("white", "black", "gray")
        for (node in 1:nrow(rr)) {
            if (rr[node, "p.value"] > cut.off || is.na(rr[node, 
                "p.value"])) {
                bg.sig[node] = bg.cols[[1]]
            }
            else if (rr[node, "p.value"] <= cut.off && ((rr[node, 
                paste("obs", sp.parm, sep = ".")] - rr[node, 
                paste("m.exp", sp.parm, sep = ".")]) > 0)) {
                bg.sig[node] = bg.cols[[2]]
            }
            else {
                bg.sig[node] = bg.cols[[3]]
            }
        }
        points(-o.orig$node.time, o.orig[[sp.parm]], cex = cex$pch, 
            col = col[[1]], pch = 21, bg = add.transparency(bg.sig, 
                transp), ...)
        #abline(lm(o.orig[[sp.parm]] ~ -o.orig$node.time)) # added line
        smoothingSpline <- smooth.spline(-o.orig$node.time, o.orig[[sp.parm]], spar=1) #
        lines(smoothingSpline) #
        legend("topleft", legend = c(paste(sp.parm, ": as expected", 
            sep = ""), paste(sp.parm, ": larger than expected", 
            sep = ""), paste(sp.parm, ": smaller than expected", 
            sep = "")), fill = add.transparency(c(bg.cols[[1]], 
            bg.cols[[2]], bg.cols[[3]]), transp), bg = add.transparency("white", 
            0.5), box.lty = "blank", border = "gray", cex = cex$legend)
    }
    else if (sig.plot == FALSE) {
        points(-o.orig$node.time, o.orig[[sp.parm]], cex = cex$pch, 
            col = col[[1]], pch = 21, bg = add.transparency(bg[[1]], 
                transp), ...)
    }
    if (add.id == TRUE) {
        textxy(-o.orig$node.time, o.orig[[sp.parm]], o.orig$node.ID, 
            m = c(mean(-o.orig$node.time), mean(o.orig[[sp.parm]])), 
            cx = cex$node)
    }
    if (!is.null(outfile)) 
        dev.off()
}





#############


##########################################


save(befdat, file = paste(path.data,"befdat.Rdata", sep = ""))
load(paste(path.data,"befdat.Rdata", sep = ""))

pdf("phy.147.ultra.pdf", width = 8, height = 12)
plot(befdat$phy.147.ultra, cex = .45)
dev.off()

## extract successional-stage variables
befdat$site.order[, c(10,57:59)]

## 1) MPD and null models for different successional classifications
# 1.1 for full phylo
# sum up abundance for I. purpurea and I. chinensis
befdat$com.order[rownames(befdat$com.order)=="Ilex_purpurea", ] <- befdat$com.order[rownames(befdat$com.order)=="Ilex_purpurea", ] + befdat$com.order[rownames(befdat$com.order)=="Ilex_chinensis", ]

# delete "Ilex_chinensis"
befdat$com.order <- befdat$com.order[rownames(befdat$com.order)!="Ilex_chinensis", ]

phy.147.ultra <- prune.sample(t(befdat$com.order),befdat$phy.full.ultra.syn)

phy.143.ultra <- drop.tip(phy.147.ultra, c("Pinus_massoniana","Pinus_taiwanensis","Cephalotaxus_fortunei","Cunninghamia_lanceolata"))

pdf("phy.147.ultra.pdf", width = 8, height = 8.5)
plot(phy.147.ultra, type = "f", cex = .6)
dev.off()

befdat$phy.147.ultra <- phy.147.ultra
befdat$phy.143.ultra <- phy.143.ultra

# 

ses.all <- ses.mpd(samp = t(befdat$com.order), dis = cophenetic(befdat$phy.147.ultra), null.model = "taxa.labels", abundance.weighted = FALSE, runs = 999)
dat <- cbind(ses.all[, c(1,2,6)], befdat$site.order[, c(10,58,59)])
aggregate(dat[, 1:3], list(Age = dat$Tree_age_cat), FUN = mean)


#############
# MPD for all species (com147)
ses.all <- ses.mpd(samp = t(befdat$com.order), dis = cophenetic(befdat$phy.147.ultra), null.model = "trialswap", abundance.weighted = TRUE, runs = 999, iterations = 1000)
dat <- cbind(ses.all[, c(1,2,6)], befdat$site.order[, c(10,58,59)])

write.csv(aggregate(dat[, 1:3], list(Stage = dat$Tree_age_cat), FUN = mean), file = "3.csv")
write.csv(aggregate(dat[, 1:3], list(Stage = dat$Successional_stage), FUN = mean), file = "5.csv")
write.csv(aggregate(dat[, 1:3], list(Stage = dat$age_HB), FUN = mean), file = "5HB.csv")

#############
# MPD excluding non-angiosperms species (com143, see Letcher, 2009)

mat <- match.phylo.comm(befdat$phy.143.ultra, t(befdat$com.order))

ses.all <- ses.mpd(samp = mat$comm, dis = cophenetic(mat$phy), null.model = "independentswap", abundance.weighted = TRUE, runs = 999)

dat <- cbind(ses.all[, c(1,2,6)], befdat$site.order[, c(10,58,59)])

write.csv(aggregate(dat[, 1:3], list(Stage = dat$Tree_age_cat), FUN = mean), file = "3.csv")
write.csv(aggregate(dat[, 1:3], list(Stage = dat$Successional_stage), FUN = mean), file = "5.csv")
write.csv(aggregate(dat[, 1:3], list(Stage = dat$age_HB), FUN = mean), file = "5HB.csv")

# are gynosperms more abundant in mid successional stages?

befdat$com.order[c(20,28,99,100), ]

# 1.2 reduced phylo (excluding )


## once optimal successional classification and species set is defined run Rao-partitioning and "spacodiR"-analysis

## 

pdf("ntaxa.143.taxlab.inc.pdf", width = 8, height = 9)
par(mfrow = c(3,3))
for (i in c(5,6,4)){ 
boxplot(ntaxa ~ dat[, i], data = dat, main = names(dat)[i], ylab = "Species richness")
}
for (i in c(5,6,4)){
boxplot(mpd.obs ~ dat[, i], data = dat, main = names(dat)[i], ylab = "MPD")
}
for (i in c(5,6,4)){
boxplot(mpd.obs.z ~ dat[, i], data = dat, main = names(dat)[i], ylab = "SES")
abline(h=0)
}
dev.off()


plot1 <- ggplot(data=dat, aes(x=age_HB, y=ntaxa, group=age_HB)) + geom_boxplot() + stat_smooth(method="glm", family="poisson", formula = y ~ ns(x, 2), aes(group = 1)) +  xlab("Stage") +  ylab("Species richness")
plot2 <- ggplot(data=dat, aes(x=age_HB, y=mpd.obs, group=age_HB)) + geom_boxplot() + stat_smooth(method="glm", family="gaussian", formula = y ~ ns(x, 2), aes(group = 1))+  xlab("Stage")+  ylab(expression(D[PW]))
plot3 <- ggplot(data=dat, aes(x=age_HB, y=mpd.obs.z, group=age_HB)) + geom_boxplot() + stat_smooth(method="glm", family="gaussian", formula = y ~ ns(x, 2), aes(group = 1))+  xlab("Stage")+  ylab(expression(SES.D[PW])) + geom_hline(yintercept=0, linetype="dashed", colour = "red", size = .5)

library(gridExtra)

pdf("gg3.pdf", width = 9, height = 3)
#postscript("gg3.eps", width = 9, height = 3, paper = "special", onefile = FALSE, horizontal = FALSE, pointsize=12)
grid.arrange(plot1, plot2, plot3, ncol=3)
dev.off()

## phylogeny dotplot

mat <- match.phylo.comm(befdat$phy.147.ultra, t(befdat$com.order))

phy.dotplot(sp.plot=t(mat$comm[1:9,]), phy=mat$phy, lab.adj=c(-4,-.5), tips.cex = .5, edge.width = 0.3, outfile = paste(getwd(),"/T1.147.pdf", sep = ""))
phy.dotplot(sp.plot=t(mat$comm[10:18,]), phy=mat$phy, lab.adj=c(-4,-.5), tips.cex = .5, edge.width = 0.3, outfile = paste(getwd(),"/T2.147.pdf", sep = ""))
phy.dotplot(sp.plot=t(mat$comm[19:27,]), phy=mat$phy, lab.adj=c(-4,-.5), tips.cex = .5, edge.width = 0.3, outfile = paste(getwd(),"/T3.147.pdf", sep = ""))
  PI=spacodi.by.nodes(sp.plot=t(phycom09$com.lp), sp.parm="PIst", phy=phycom09$phyl.herb, return.all=TRUE, method="1s")


# spacodi.by.nodes - test
mat <- match.phylo.comm(befdat$phy.143.ultra, t(befdat$com.order))

sort(rowSums(befdat$com.order))

PI1=spacodi.by.nodes(sp.plot=t(mat$comm[1:9,]), sp.parm="PIst", phy=mat$phy, return.all=TRUE, method="1s", rand.test = TRUE, r.rep = 1000)



spacodi.treeplot(PI1, mat$phy, sig.plot=FALSE, add.id=FALSE, cex=list(pch = .8, tip = 0.25, legend = 0.7), outfile = paste(getwd(),"/treeplot_1.pdf", sep = ""), edge.width = 0.2)

##########################

befdat$site.order <- befdat$site.order[order(befdat$site.order[,59]),]

match(colnames(befdat$com.order),rownames(befdat$site.order))

befdat$com.order <- befdat$com.order[,match(rownames(befdat$site.order),colnames(befdat$com.order))]

#table(befdat$site.order[,59])
# 1 2 3 4 5 
# 5 4 5 6 7 

# 1)  Rao-partitioning for PD
mat <- match.phylo.comm(phy=befdat$phy.143.ultra, comm=t(befdat$com.order))

write.table(t(mat$comm[1:9,]), "com1.txt", sep = "\t", col.names = NA, quote = FALSE)
write.table(t(mat$comm[10:18,]), "com2.txt", sep = "\t", col.names = NA, quote = FALSE)
write.table(t(mat$comm[19:27,]), "com3.txt", sep = "\t", col.names = NA, quote = FALSE)

write.tree(mat$phy, "phy143.txt")

#####

com.1 <- com[,befdat$site.order[,59]==1]
com.2 <- com[,befdat$site.order[,59]==2]
com.3 <- com[,befdat$site.order[,59]==3]
com.4 <- com[,befdat$site.order[,59]==4]
com.5 <- com[,befdat$site.order[,59]==5]

write.table(com.1, file = "com.1.txt", sep = "\t", col.names = NA, quote = FALSE)

distinct <- taxondive(t(com[,befdat$site.order[,59]==1]), cophenetic(befdat$phy.143.ultra))

#######

spacodi.calc(sp.plot=t(mat$comm[befdat$site.order[,59]==5,]), phy=mat$phy)[1]

spacodi.calc(sp.plot=t(mat$comm[befdat$site.order[,59]==1,]))[2]

match(colnames(befdat$com.order),rownames(befdat$site.order))

mean(comdistnt(mat$comm[befdat$site.order[,59]==1,], cophenetic(mat$phy), abundance.weighted=TRUE))


Rao.PD <- Rao(sample=t(mat$comm), dfunc=NULL, dphyl=cophenetic(mat$phy), weight=F, Jost=T, structure=NULL)

Rao.PD.1 <- Rao(sample=t(mat$comm[befdat$site.order[,59]==5,]), dfunc=NULL, dphyl=cophenetic(mat$phy), weight=F, Jost=T, structure=NULL)
#mean(Rao.PD.1$TD$Richness_per_plot)
mean(Rao.PD.1$TD$Pairwise_sample$Beta_prop)
mean(Rao.PD.1$PD$Pairwise_sample$Beta_prop)

Rao.PD.2 <- Rao(sample=t(mat$comm[10:18,]), dfunc=NULL, dphyl=cophenetic(mat$phy), weight=F, Jost=T, structure=NULL)
Rao.PD.3 <- Rao(sample=t(mat$comm[19:27,]), dfunc=NULL, dphyl=cophenetic(mat$phy), weight=F, Jost=T, structure=NULL)

mean(Rao.PD.1$PD$Pairwise_sample$Beta_prop)

mean(Rao.PD.1$TD$Richness_per_plot)

#######################
## MPD ################
#######################
mat <- match.phylo.comm(phy=befdat$phy.143.ultra, comm=t(befdat$com.order))

com <- t(mat$comm)
phy <- mat$phy
dis <- cophenetic(phy)

MPD.PD.step5 <- function(com, dis, nullmod, runs){  
  results <- matrix(NA, nrow = 5, ncol = 8)  
  alpha <- list("T1","T2","T3","T4","T5") # list because it should hold objects of varying length
  names(alpha) <- c("T1","T2","T3","T4","T5")  
  alpha.shuff <- function(com, runs){
  Res = NA
  for (r in 1:runs) {      
    Res <- c(Res, mean(mpd(samp = t(eval(parse(text=paste("resamp.", nullmod, sep = "")))(com, level=0.2)), dis = dis, abundance.weighted = FALSE))) # !!! for null model 3x   
  }
  return(Res)
}  
for (i in 1:5){  
  obs <- mpd(samp = t(com[,befdat$site.order[,59]==i]), dis = dis, abundance.weighted = FALSE) # single obsversed MPD value   
  obs.val <- mean(obs)/2 
  resamp <- (alpha.shuff(com = com[,befdat$site.order[,59]==i], runs = runs))/2
  resamp[1] <- obs.val
  obs.rank <- rank(resamp)[1]
  results[i,1] <- obs.val
  results[i,2] <- mean(resamp[2:(runs+1)], na.rm = TRUE)
  results[i,3] <- sd(resamp[2:(runs+1)], na.rm = TRUE)
  results[i,4] <- quantile(resamp[2:(runs+1)],  probs = c(2.5, 97.5)/100)[1]
  results[i,5] <- quantile(resamp[2:(runs+1)],  probs = c(2.5, 97.5)/100)[2]
  results[i,6] <- obs.rank/(runs+1) ## P(1-sided test, H1: obs<exp)
  results[i,7] <- 1-(obs.rank/(runs+1)) ## P(1-sided test, H1: obs>exp)
  results[i,8] <- (1-(obs.rank/(runs+1)))*2 ## P(2-sided test, H1: obs<>exp)
dimnames(results) <- list(c("T1", "T2", "T3", "T4", "T5"), c("mpd.obs","rand.mean","rand.sd","2.5%","97.5%","P.obs<exp","P.obs>exp","P.obs<>exp"))
  alpha[[i]] <- obs/2
}
  return(list(Results = results, Alpha = alpha))
}

# example
Succ.alpha <- MPD.PD.step5(com = com, dis = dis, nullmod = "3x", runs = 9)
befdat$Alpha.step.3x.occ <- Succ.alpha

#Alpha.step.1a.abu: MPD, within each timestep (age pool), null model 1a, abund.weighted

###################################
# rewrite MPD.PD.step5 to obtain D (Dpw), Dstar (Dp*w) and Dplus (DELTApw) for D-statistics in taxodiver (vegan)
#####################################

mat <- match.phylo.comm(phy=befdat$phy.143.ultra, comm=t(befdat$com.order))
com <- t(mat$comm)
phy <- mat$phy
dis <- cophenetic(phy)

distinct <- taxondive(t(com[,befdat$site.order[,59]==1]), cophenetic(befdat$phy.143.ultra))

# value: 2 - D (Dpw), 3 - Dstar (Dp*w), 5 - Dplus (DELTApw)

D.PD.step5 <- function(com, dis, value, nullmod, runs){  
  results <- matrix(NA, nrow = 5, ncol = 8)  
  alpha <- list("T1","T2","T3","T4","T5") # list because it should hold objects of varying length
  names(alpha) <- c("T1","T2","T3","T4","T5")  
  alpha.shuff <- function(com, runs){
  Res = NA
  for (r in 1:runs) {      
    Res <- c(Res, mean(taxondive(t(eval(parse(text=paste("resamp.", nullmod, sep = "")))(com, level=0.2)), dis = dis)[[value]])) # !!! for null model 3x   
  }
  return(Res)
}  
for (i in 1:5){  
  obs <- taxondive(t(com[,befdat$site.order[,59]==i]), dis = dis) # single obsversed MPD value   
  obs.val <- mean(obs[[value]])/2
  resamp <- (alpha.shuff(com = com[,befdat$site.order[,59]==i], runs = runs))/2
  resamp[1] <- obs.val
  obs.rank <- rank(resamp)[1]
  results[i,1] <- obs.val
  results[i,2] <- mean(resamp[2:(runs+1)], na.rm = TRUE)
  results[i,3] <- sd(resamp[2:(runs+1)], na.rm = TRUE)
  results[i,4] <- quantile(resamp[2:(runs+1)],  probs = c(2.5, 97.5)/100)[1]
  results[i,5] <- quantile(resamp[2:(runs+1)],  probs = c(2.5, 97.5)/100)[2]
  results[i,6] <- obs.rank/(runs+1) ## P(1-sided test, H1: obs<exp)
  results[i,7] <- 1-(obs.rank/(runs+1)) ## P(1-sided test, H1: obs>exp)
  results[i,8] <- (1-(obs.rank/(runs+1)))*2 ## P(2-sided test, H1: obs<>exp)
dimnames(results) <- list(c("T1", "T2", "T3", "T4", "T5"), c(names(obs)[value],"rand.mean","rand.sd","2.5%","97.5%","P.obs<exp","P.obs>exp","P.obs<>exp"))
  alpha[[i]] <- obs[[value]]/2
}
  return(list(Results = results, Alpha = alpha))
}

# example
Succ.alpha <- D.PD.step5(com = com, dis = dis, nullmod = "3x", value=5, runs = 99)
# take D-name convention from "spacodi"
befdat$Alpha.step.Delta.pw <- Succ.alpha


#########################################
#######################
## PIst and co. ################
#######################

spa.PD.step5 <- function(com, phy, value, nullmod, runs){
results <- matrix(NA, nrow = 5, ncol = 8)
pairwise <- list("T1","T2","T3","T4","T5") # list because it should hold objects of varying length
names(pairwise) <- c("T1","T2","T3","T4","T5")
  PI.shuff <- function(com, runs){
  Res = NA
  for (r in 1:runs) {      
    Res <- c(Res, mean(as.dist(spacodi.calc(sp.plot = eval(parse(text=paste("resamp.", nullmod, sep = "")))(com, abund.class.ratio = 4), phy = phy, prune = TRUE, pairwise = TRUE)[[value]])))   
  }
  return(Res)
}
for (i in 1:5){    
  obs <- spacodi.calc(sp.plot = com[,befdat$site.order[,59]==i], phy = phy, prune = TRUE, pairwise = TRUE) # single obsversed PIst value  
  obs.val <- mean(as.dist(obs[[value]]))   
   resamp <- PI.shuff(com = com[,befdat$site.order[,59]==i], runs = runs) 
  resamp[1] <- obs.val
  obs.rank <- rank(resamp)[1]
results[i,1] <- obs.val
results[i,2] <- mean(resamp[2:(runs+1)], na.rm = TRUE)
results[i,3] <- sd(resamp[2:(runs+1)], na.rm = TRUE)
results[i,4] <- quantile(resamp[2:(runs+1)],  probs = c(2.5, 97.5)/100)[1]
results[i,5] <- quantile(resamp[2:(runs+1)],  probs = c(2.5, 97.5)/100)[2]
results[i,6] <- obs.rank/(runs+1) ## P(1-sided test, H1: obs<exp)
results[i,7] <- 1-(obs.rank/(runs+1)) ## P(1-sided test, H1: obs>exp)
results[i,8] <- (1-(obs.rank/(runs+1)))*2 ## P(2-sided test, H1: obs<>exp)
dimnames(results) <- list(c("T1", "T2", "T3", "T4", "T5"), c(names(obs)[value],"rand.mean","rand.sd","2.5%","97.5%","P.obs<exp","P.obs>exp","P.obs<>exp"))
pairwise[[i]] <- as.dist(obs[[value]])
}
return(list(Results = results, Pairwise = pairwise))
}

# 1a for Bst
Succ.spa.4 <- spa.PD.step5(com=com, phy=phy, value=7, nullmod="1a", runs=99)
Succ.spa.4$Results

# swap for Bst
Succ.spa.5 <- spa.PD.step5(com=com, phy=phy, value=7, nullmod="3x", runs=999)
Succ.spa.5$Results

Succ.spa.4 <- spa.PD.step5(com=com, phy=phy, value=8, nullmod="1a", runs=199)
Succ.spa.4$Results
Succ.spa.4 <- spa.PD.step5(com=com, phy=phy, value=8, nullmod="1a", runs=199)
Succ.spa.4$Results
Succ.spa.4 <- spa.PD.step5(com=com, phy=phy, value=8, nullmod="1a", runs=199)
Succ.spa.4$Results


Succ.spa$Results

befdat$Pst.step.1s <- Succ.spa

###############################
## turnover between stages ####
###############################

#! use huge phylogeny instead
mat <- match.phylo.comm(phy=befdat$phy.143.ultra, comm=t(befdat$com.order))
com <- t(mat$comm)
phy <- mat$phy
dis <- cophenetic(phy)

nullmod <- "1s"
value <- 8

site <- befdat$site.order

timevec <- as.vector(dist(site$age_HB^3))
timevec[timevec==7] <- 1
timevec[timevec==26] <- 2
timevec[timevec==63] <- 3
timevec[timevec==124] <- 4
# timevec 

spacodi.temp.pair.PD <- function(com, phy, traits, value, nullmod, runs){
# mat <- matrix(1:220, nrow = 55, ncol = 4) # site vectors for the four different time steps
results <- matrix(NA, nrow = 4, ncol = 8)
pairwise <- list()[1:4]
names(pairwise) <- c("T1-T2", "T1-T3", "T1-T4", "T1-T5")
PI.tax.shuff <- function(com, runs){
  Res = NA
  for (r in 1:runs) {   
    Res <- c(Res, mean(as.dist(spacodi.calc(sp.plot = eval(parse(text=paste("resamp.", nullmod, sep = "")))(com), phy = phy, prune = TRUE, pairwise = TRUE)[[value]])[timevec==i-1]))
  }
  return(Res)
}
for (i in 2:5){ 
  # new:  
  timevec <- as.vector(dist(site$age_HB[site$age_HB==1 | site$age_HB==i]))
  ##  
obs <- spacodi.calc(sp.plot = com[,site$age_HB==1 | site$age_HB==i], phy = phy, prune = TRUE, pairwise = TRUE) # single obsversed PIst value  
obs.val <- mean(as.dist(obs[[value]])[timevec==i-1]) 
  resamp <- PI.tax.shuff(com = com[,site$age_HB==1 | site$age_HB==i], runs = runs)  
resamp[1] <- obs.val
obs.rank <- rank(resamp)[1]
results[i-1,1] <- obs.val
results[i-1,2] <- mean(resamp[2:(runs+1)], na.rm = TRUE)
results[i-1,3] <- sd(resamp[2:(runs+1)], na.rm = TRUE)
results[i-1,4] <- quantile(resamp[2:(runs+1)],  probs = c(2.5, 97.5)/100)[1]
results[i-1,5] <- quantile(resamp[2:(runs+1)],  probs = c(2.5, 97.5)/100)[2]
results[i-1,6] <- obs.rank/(runs+1) ## P(1-sided test, H1: obs<exp)
results[i-1,7] <- 1-(obs.rank/(runs+1)) ## P(1-sided test, H1: obs>exp)
results[i-1,8] <- (1-(obs.rank/(runs+1)))*2 ## P(2-sided test, H1: obs<>exp)
dimnames(results) <- list(c("T1-T2", "T1-T3", "T1-T4", "T1-T5"), c(names(obs)[value],"rand.mean","rand.sd","2.5%","97.5%","P.obs<exp","P.obs>exp","P.obs<>exp"))
pairwise[[i-1]] <- as.dist(obs[[value]])[timevec==i-1]
}
return(list(Results = results, Pairwise = pairwise))
}

# ex1
spa.phy.temp.pair.PIst <- spacodi.temp.pair.PD(com=com, phy=phy, traits = NULL, value=8, nullmod="1s", runs=499)
spa.phy.temp.pair.PIst$Results

################
# plot temporal turnover
################

cbind.fill <- function (alphalist) {
require(plyr) 
bind <- rbind.fill.matrix(t(as.matrix(as.vector(alphalist[[1]]))), t(as.matrix(as.vector(alphalist[[2]]))) ,t(as.matrix(as.vector(alphalist[[3]]))), t(as.matrix(as.vector(alphalist[[4]]))))
t(bind)
}

#postscript("Succ.beta.bef.temp.eps", width = 3, height = 3.1, paper = "special", onefile = FALSE, horizontal = FALSE, pointsize=12)
pdf("Succ.beta.bef.temp.pdf", width = 3, height = 3.1)
par(mar=c(0,3.8,0.5,.6),oma=c(5.2,0,1.6,0), tcl=.3, las=1, cex = .75)
#for (i in c(1,5,3)){
par(bty = "l")
error.bars(cbind.fill(spa.phy.temp.pair.PIst$Pairwise), bar=F, alpha = 0.05, sd = F, pch = 15, arrow.len = .00, lwd = 3, cex = 1.2, axes = FALSE, xlim = c(0.9,4.2), ylim = c(-0.004,0.007), main = "", xlab = "", ylab = expression(Pi[ST]), mgp=c(2.7,0,0))
polygon(y=c(spa.phy.temp.pair.PIst$Results[,4], rev(spa.phy.temp.pair.PIst$Results[,5])), x=c(1:4,4:1), col="grey76", border = NA)
error.bars(cbind.fill(spa.phy.temp.pair.PIst$Pairwise), bar=F, alpha = 0.05, sd = F, pch = 15, arrow.len = .00, lwd = 3, cex = 1.2, axes = FALSE, xlim = c(0.9,5.2), ylim = c(-0.004,0.007), main = "", xlab = "", ylab = expression(Pi[ST]), mgp=c(2.7,0,0), add = T)
lines(spa.phy.temp.pair.PIst$Results[,2], lty = 3)
#text(1,52, "a");text(2,52, "b");text(3,52, "c");text(4,52, "c")
axis(side = 2, hadj=.7)
axis(side = 1, 1:4, c("T1-T2","T1-T3","T1-T4","T1-T5"), las = 1)
#text(1.9,55, "Taxonomic", cex = 1.4)
box()
mtext("Successional stage (Years)", side=1, outer = T, line=4, at = .54, cex = .8)
#mtext("(a) Taxonomic", side=3, at = .152, outer = T, line=.4, cex = .9)
#mtext("(b) Phylogenetic", side=3, at = .494, outer = T, line=.4, cex = .9)
#mtext("(c) Functional", side=3, at = .815, outer = T, line=.4, cex = .9)
dev.off()

############################

####################
# testing difference between T2 and the rest 
########################

spacodi.temp.pair.PD.T2 <- function(com, phy, traits, value, nullmod, runs){
# mat <- matrix(1:220, nrow = 55, ncol = 4) # site vectors for the four different time steps
results <- matrix(NA, nrow = 3, ncol = 8)
pairwise <- list()[1:3]
names(pairwise) <- c("T2-T3", "T2-T4", "T2-T5")
PI.tax.shuff <- function(com, runs){
  Res = NA
  for (r in 1:runs) {   
    Res <- c(Res, mean(as.dist(spacodi.calc(sp.plot = eval(parse(text=paste("resamp.", nullmod, sep = "")))(com), phy = phy, prune = TRUE, pairwise = TRUE)[[value]])[timevec==i-1]))
  }
  return(Res)
}
for (i in 2:4){ 
  # new:  
  timevec <- as.vector(dist(site$age_HB[site$age_HB==2 | site$age_HB==i+1]))
  ##  
obs <- spacodi.calc(sp.plot = com[,site$age_HB==2 | site$age_HB==i+1], phy = phy, prune = TRUE, pairwise = TRUE) # single obsversed PIst value 
obs.val <- mean(as.dist(obs[[value]])[timevec==i-1]) 
resamp <- PI.tax.shuff(com = com[,site$age_HB==2 | site$age_HB==i+1], runs = runs)  
resamp[1] <- obs.val
obs.rank <- rank(resamp)[1]
results[i-1,1] <- obs.val
results[i-1,2] <- mean(resamp[2:(runs+1)], na.rm = TRUE)
results[i-1,3] <- sd(resamp[2:(runs+1)], na.rm = TRUE)
results[i-1,4] <- quantile(resamp[2:(runs+1)],  probs = c(2.5, 97.5)/100, na.rm = TRUE)[1]
results[i-1,5] <- quantile(resamp[2:(runs+1)],  probs = c(2.5, 97.5)/100, na.rm = TRUE)[2]
results[i-1,6] <- obs.rank/(runs+1) ## P(1-sided test, H1: obs<exp)
results[i-1,7] <- 1-(obs.rank/(runs+1)) ## P(1-sided test, H1: obs>exp)
results[i-1,8] <- (1-(obs.rank/(runs+1)))*2 ## P(2-sided test, H1: obs<>exp)
dimnames(results) <- list(c("T2-T3", "T2-T4", "T2-T5"), c(names(obs)[value],"rand.mean","rand.sd","2.5%","97.5%","P.obs<exp","P.obs>exp","P.obs<>exp"))
pairwise[[i-1]] <- as.dist(obs[[value]])[timevec==i-1]
}
return(list(Results = results, Pairwise = pairwise))
}

# ex1
spa.phy.temp.pair.PIst <- spacodi.temp.pair.PD.T2(com=com, phy=phy, traits = NULL, value=8, nullmod="1s", runs=299)


#################

## export .txt-file with spatial distance and age classes (age_HB)

spat <- read.table("/home/oliver/Dokumente/PhD/PostPhD/Halle/BEF-China/Data/Site/CSPs_UTM.txt", sep = ";", head = TRUE)
spat <- spat[,2:4]

spat[,1] <- paste("CSP", 1:27, sep = "")
rownames(spat) <- spat[,1]
spat <- spat[,-1]
rownames(spat) <- sort(colnames(befdat$com.order))

# 
befdat$site.order[,c(59,70,71)]

timedist <- (dist(befdat$site.order[,59]))

timedist[timedist != 0] <- NA

timedist <- as.matrix(timedist)

timedist[1:5, 1:5] <- 1
timedist[6:9, 6:9] <- 2
timedist[10:14, 10:14] <- 3
timedist[15:20, 15:20] <- 4
timedist[21:27, 21:27] <- 5

timedist <- as.vector(as.dist(timedist))

spatdist <- as.vector(dist(befdat$site.order[,70:71]))
elevdist <- as.vector(dist(befdat$site.order[,3]))
soildist <- as.vector(befdat$pca.soil.dist)

# create data for mantel tests:
# time.cont dist

time.dist.cont.all <- dist(befdat$site.order[,57])
spatdist.all <- (dist(befdat$site.order[,70:71]))
elevdist.all <- (dist(befdat$site.order[,3]))
soildist.all <- (befdat$pca.soil.dist)

write.table(as.matrix(soildist.all), "soildist.txt", sep = "\t", col.names = NA, quote = FALSE)

# converts into triplet format
soil.trip <- as.phylocom(as.data.frame(as.matrix(soildist.all)))

soil.trip <- soil.trip[, c(1,3,2)]

write.table(soil.trip, "soil.trip.txt", sep = "\t", col.names = FALSE,row.names = FALSE, quote = FALSE)

# partial mantel tests
library(ncf)

partial.mantel.test(M1=spa.pi, M2=as.matrix(time.dist.cont.all), M3=as.matrix(soildist.all), resamp=999, quiet=T)

######################################################
# try for PIst calculated within timesteps
# weird results if analysed within the five-stage AND three-stage classification
# 

# befdat$site.order[colnames(befdat$com.order.143),]

spatdist.all <- dist(befdat$site.order[colnames(befdat$com.order.143),70:71])
elevdist.all <- dist(befdat$site.order[colnames(befdat$com.order.143),3])

mat <- match.phylo.comm(phy=befdat$phy.143.ultra, comm=t(befdat$com.order.143))

spa.pi.1 <- spacodi.calc(sp.plot = t(mat$comm)[,c(1:9)], phy = mat$phy, prune = TRUE, pairwise = TRUE)[[7]]
mean(as.dist(spa.pi.1))
partial.mantel.test(M1=spa.pi.1, M2=as.matrix(spatdist.all)[1:9,1:9], M3=as.matrix(elevdist.all)[1:9,1:9], resamp=999, quiet=T)

plotlist <- befdat$site.order[colnames(befdat$com.order.143), c(8, 7)]
plotlist <- cbind(rownames(plotlist), plotlist)
colnames(plotlist) <- c("Name","Long","Lat")

write.table(plotlist[19:27,], "plotlist.33.txt", sep = "\t", col.names = TRUE, quote = FALSE, row.names = FALSE)


#############################################

befdat$PIst.step.1s$Pairwise$T1
as.matrix(spatdist.all)[1:5,1:5]

partial.mantel.test(M1=as.matrix(befdat$PIst.step.1s$Pairwise$T1), M2=as.matrix(spatdist.all)[1:5,1:5], M3=as.matrix(elevdist.all)[1:5,1:5], resamp=999, quiet=T)

partial.mantel.test(M1=as.matrix(befdat$PIst.step.1s$Pairwise$T4), M2=as.matrix(spatdist.all)[15:20,15:20], M3=as.matrix(elevdist.all)[15:20,15:20], resamp=999, quiet=T)


# add temporal distance (age continuous)
# create betamat including all plots (also between time steps)

betamat <- cbind(timedist[is.na(timedist)==F], scale(spatdist[is.na(timedist)==F]), scale(elevdist[is.na(timedist)==F]),scale(soildist[is.na(timedist)==F]), spa.pi.dis[is.na(timedist)==F], spa.ps.dis[is.na(timedist)==F], spa.i.dis[is.na(timedist)==F], spa.p.dis[is.na(timedist)==F])

colnames(betamat) <- c("Time", "Space", "Elevation", "Environment", "PsST", "PiST","IST","PST")

group <- as.data.frame(rbind(betamat[,c(1,2,5:8)], betamat[,c(1,3,5:8)], betamat[,c(1,4,5:8)]))

group$SpaEleEnv <- rep(c("Space","Elevation","Environment"), each = 62)
colnames(group) <- c("Time", "Distance", "PsST", "PiST", "IST", "PST", "SpaEleEnv")

group$TimeOrd <- ordered(as.factor(group$Time), levels = c("5","4","3","2","1"))

beta.plot <- xyplot(IST ~ Distance | SpaEleEnv + TimeOrd, data = group, cex = .2, type = c("p", "r"), panel = function (...) {panel.abline(-2,0, lty=2) 
#panel.abline(2,0, lty=2)
panel.xyplot(...)}, xlab = "Distance (scaled)", ylab = "IST", main = "IST")
beta.plot

pdf("Ist.SpaEleEnv.pdf")
beta.plot
dev.off()

# env.dist
  
pdf("env.pdf", width = 16, height = 16)
CorTestPlot(befdat$site.order[,c(3,5:10,19,45,57,59,60,62,63,65)])
dev.off()

# soil.dist (Soil_moisture)

befdat$site.order[,19] <- befdat$site.order[,19]+0.01
pca.soil.log.scale <- rda(scale(log(befdat$site.order[,c(19,45,60,62,63,65)])))
pca.soil.dist <- dist(pca.soil.log.scale$CA$u[,1:3])
befdat$pca.soil.dist <- pca.soil.dist

# reorder species names in community data according to phylogeny tip.labels
mat <- match.phylo.comm(phy=befdat$phy.143.ultra, comm=t(befdat$com.order))
write.table(t(mat$comm), file = "com.all.txt",sep = "\t", col.names = NA, quote = FALSE)

spa.p <- spacodi.calc(sp.plot = t(mat$comm), phy = mat$phy, prune = TRUE, pairwise = TRUE)[[6]]
spa.p.dis <- as.vector(as.dist(spa.p))


library(fossil)
spat.dist <- as.matrix(earth.dist(befdat$site.order[, c(8, 7)]))

dimnames(spat.dist) <- list(rownames(befdat$site.order), rownames(befdat$site.order))


plotlist <- befdat$site.order[, c(8, 7,58)]

plotlist[plotlist$age_HB==5, 3] <- "E"

plotlist <- plotlist[, c(2,1,3)]

write.table(plotlist, "plotlist.txt", sep = "\t", col.names = TRUE, quote = FALSE)

write.table(spat.dist, "spat.dist.txt", sep = "\t", col.names = NA, quote = FALSE)

1, 2, 6, 8.6
0.03897756 8.62814050
###########################################
##### cbind function that takes lists of unequal length

cbind.fill <- function (alphalist) {
require(plyr) 
bind <- rbind.fill.matrix(t(as.matrix(as.vector(alphalist[[1]]))), t(as.matrix(as.vector(alphalist[[2]]))) ,t(as.matrix(as.vector(alphalist[[3]]))), t(as.matrix(as.vector(alphalist[[4]]))), t(as.matrix(as.vector(alphalist[[5]]))))
t(bind)
}

# ex
cbind.fill(befdat$Alpha.step.1a.abu$Alpha)

#############################################
#### plot alpha #############################
#############################################

#postscript("Succ.alpha.bef.eps", width = 8.5, height = 2.8, paper = "special", onefile = FALSE, horizontal = FALSE, pointsize=12)
pdf("Succ.alpha.bef.pdf", width = 8.5, height = 2.8)
par(mfcol=c(1,4), mar=c(0,3.8,0.5,.6),oma=c(5.2,0,1.6,0), tcl=.3, las=1, cex = .75)
#for (i in c(1,5,3)){
par(bty = "l")
error.bars(befdat$SR, bar=F, alpha = 0.05, sd = F, pch = 15, arrow.len = .0, lwd = 3, cex = 1.2, axes = FALSE, xlim = c(0.9,5.2), ylim = c(18,61), main = "", xlab = "", ylab = "Species richness", mgp=c(2,0,0))
#text(1,45, "a");text(2,45, "b");text(3,45, "c");text(4,45, "c")
axis(side = 2, hadj=.5)
axis(side = 1, 1:5, c("T1","T2","T3","T4","T5"), las = 1)
#text(1.9,55, "Taxonomic", cex = 1.4)
box()
error.bars(cbind.fill(befdat$Alpha.step.Dpw.1a$Alpha), bar=F, alpha = 0.05, sd = F, pch = 15, arrow.len = .00, lwd = 3, cex = 1.2, axes = FALSE, xlim = c(0.9,5.2), ylim = c(78,108), main = "", xlab = "", ylab = expression(D[italic(W)]^{italic(P)}), mgp=c(2,0,0))
polygon(y=c(befdat$Alpha.step.Dpw.1a$Results[,4], rev(befdat$Alpha.step.Dpw.1a$Results[,5])), x=c(1:5,5:1), col="grey76", border = NA)
error.bars(cbind.fill(befdat$Alpha.step.Dpw.1a$Alpha), bar=F, alpha = 0.05, sd = F, pch = 15, arrow.len = .00, lwd = 3, cex = 1.2, axes = FALSE, xlim = c(0.9,5.2), ylim = c(78,108), main = "", xlab = "", ylab = expression(D[italic(W)]^{italic(P)}), mgp=c(2,0,0), add = T)
lines(befdat$Alpha.step.Dpw.1a$Results[,2], lty = 3)
#text(1,52, "a");text(2,52, "b");text(3,52, "c");text(4,52, "c")
axis(side = 2, hadj=.5)
axis(side = 1, 1:5, c("T1","T2","T3","T4","T5"), las = 1)
#text(1.9,55, "Taxonomic", cex = 1.4)
box()
error.bars(cbind.fill(befdat$Alpha.step.Dstar.w.1a$Alpha), bar=F, alpha = 0.05, sd = F, pch = 15, arrow.len = .00, lwd = 3, cex = 1.2, axes = FALSE, xlim = c(0.9,5.2), ylim = c(95,118), main = "", xlab = "", ylab = expression(Ds[italic(W)]^{italic(P)}), mgp=c(2,0,0))
polygon(y=c(befdat$Alpha.step.Dstar.w.1a$Results[,4], rev(befdat$Alpha.step.Dstar.w.1a$Results[,5])), x=c(1:5,5:1), col="grey76", border = NA)
error.bars(cbind.fill(befdat$Alpha.step.Dstar.w.1a$Alpha), bar=F, alpha = 0.05, sd = F, pch = 15, arrow.len = .00, lwd = 3, cex = 1.2, axes = FALSE, xlim = c(0.9,5.2), ylim = c(95,118), main = "", xlab = "", ylab = expression(Ds[italic(W)]^{italic(P)}), mgp=c(2,0,0), add = T)
lines(befdat$Alpha.step.Dstar.w.1a$Results[,2], lty = 3)
#text(1,52, "a");text(2,52, "b");text(3,52, "c");text(4,52, "c")
axis(side = 2, hadj=.5)
axis(side = 1, 1:5, c("T1","T2","T3","T4","T5"), las = 1)
#text(1.9,55, "Taxonomic", cex = 1.4)
box()
error.bars(cbind.fill(befdat$Alpha.step.Delta.pw.1a$Alpha), bar=F, alpha = 0.05, sd = F, pch = 15, arrow.len = .00, lwd = 3, cex = 1.2, axes = FALSE, xlim = c(0.9,5.2), ylim = c(106,114), main = "", xlab = "", ylab = expression(Delta[italic(W)]^{italic(T)}), mgp=c(2,0,0))
polygon(y=c(befdat$Alpha.step.Delta.pw.1a$Results[,4], rev(befdat$Alpha.step.Delta.pw.1a$Results[,5])), x=c(1:5,5:1), col="grey76", border = NA)
error.bars(cbind.fill(befdat$Alpha.step.Delta.pw.1a$Alpha), bar=F, alpha = 0.05, sd = F, pch = 15, arrow.len = .00, lwd = 3, cex = 1.2, axes = FALSE, xlim = c(0.9,5.2), ylim = c(106,114), main = "", xlab = "", ylab = expression(Delta[italic(W)]^{italic(T)}), mgp=c(2,0,0), add = T)
lines(befdat$Alpha.step.Delta.pw.1a$Results[,2], lty = 3)
#text(1,52, "a");text(2,52, "b");text(3,52, "c");text(4,52, "c")
axis(side = 2, hadj=.5)
axis(side = 1, 1:5, c("T1","T2","T3","T4","T5"), las = 1)
#text(1.9,55, "Taxonomic", cex = 1.4)
box()
mtext("Successional stage (Years)", side=1, outer = T, line=4, at = .54, cex = .8)
#mtext("(a) Taxonomic", side=3, at = .152, outer = T, line=.4, cex = .9)
#mtext("(b) Phylogenetic", side=3, at = .494, outer = T, line=.4, cex = .9)
#mtext("(c) Functional", side=3, at = .815, outer = T, line=.4, cex = .9)
dev.off()


#############################################
#### plot beta #############################
#############################################

#postscript("Succ.beta.bef.eps", width = 8.5, height = 2.8, paper = "special", onefile = FALSE, horizontal = FALSE, pointsize=12)
pdf("Succ.beta.bef.pdf", width = 8.5, height = 2.8)
par(mfcol=c(1,4), mar=c(0,3.8,0.5,.6),oma=c(5.2,0,1.6,0), tcl=.3, las=1, cex = .75)
#for (i in c(1,5,3)){
par(bty = "l")
error.bars(1-befdat$jacc, bar=F, alpha = 0.05, sd = F, pch = 15, arrow.len = .0, lwd = 3, cex = 1.2, axes = FALSE, xlim = c(0.9,5.2), ylim = c(0.5,0.75), main = "", xlab = "", ylab = "1-Jaccard", mgp=c(2,0,0), )
#text(1,45, "a");text(2,45, "b");text(3,45, "c");text(4,45, "c")
axis(side = 2, hadj=.5)
axis(side = 1, 1:5, c("T1","T2","T3","T4","T5"), las = 1)
#text(1.9,55, "Taxonomic", cex = 1.4)
box()
error.bars(cbind.fill(befdat$Pst.step.1a$Pairwise), bar=F, alpha = 0.05, sd = F, pch = 15, arrow.len = .00, lwd = 3, cex = 1.2, axes = FALSE, xlim = c(0.9,5.2), ylim = c(0.015, 0.12), main = "", xlab = "", ylab = expression(P[ST]), mgp=c(2.5,0,0))
polygon(y=c(befdat$Pst.step.1a$Results[,4], rev(befdat$Pst.step.1a$Results[,5])), x=c(1:5,5:1), col="grey76", border = NA)
error.bars(cbind.fill(befdat$Pst.step.1a$Pairwise), bar=F, alpha = 0.05, sd = F, pch = 15, arrow.len = .00, lwd = 3, cex = 1.2, axes = FALSE, xlim = c(0.9,5.2), ylim = c(0.015, 0.12), main = "", xlab = "", ylab = expression(P[ST]), mgp=c(2,0,0), add = T)
lines(befdat$Pst.step.1a$Results[,2], lty = 3)
#text(1,52, "a");text(2,52, "b");text(3,52, "c");text(4,52, "c")
axis(side = 2, hadj=.5)
axis(side = 1, 1:5, c("T1","T2","T3","T4","T5"), las = 1)
#text(1.9,55, "Taxonomic", cex = 1.4)
box()
error.bars(cbind.fill(befdat$Bst.step.1a$Pairwise), bar=F, alpha = 0.05, sd = F, pch = 15, arrow.len = .00, lwd = 3, cex = 1.2, axes = FALSE, xlim = c(0.9,5.2), ylim = c(-0.04, 0.026), main = "", xlab = "", ylab = expression(B[ST]), mgp=c(2.5,0,0))
polygon(y=c(befdat$Bst.step.1a$Results[,4], rev(befdat$Bst.step.1a$Results[,5])), x=c(1:5,5:1), col="grey76", border = NA)
error.bars(cbind.fill(befdat$Bst.step.1a$Pairwise), bar=F, alpha = 0.05, sd = F, pch = 15, arrow.len = .00, lwd = 3, cex = 1.2, axes = FALSE, xlim = c(0.9,5.2), ylim = c(-0.04, 0.026), main = "", xlab = "", ylab = expression(B[ST]), mgp=c(2.5,0,0), add = T)
lines(befdat$Bst.step.1a$Results[,2], lty = 3)
#text(1,52, "a");text(2,52, "b");text(3,52, "c");text(4,52, "c")
abline(h = 0, lty = 1, lwd = .5)
axis(side = 2, hadj=.7)
axis(side = 1, 1:5, c("T1","T2","T3","T4","T5"), las = 1)
#text(1.9,55, "Taxonomic", cex = 1.4)
box()
error.bars(cbind.fill(befdat$PIst.step.1a$Pairwise), bar=F, alpha = 0.05, sd = F, pch = 15, arrow.len = .00, lwd = 3, cex = 1.2, axes = FALSE, xlim = c(0.9,5.2), ylim = c(-0.007, 0.007), main = "", xlab = "", ylab = expression(Pi[ST]), mgp=c(2.5,0,0))
polygon(y=c(befdat$PIst.step.1a$Results[,4], rev(befdat$PIst.step.1a$Results[,5])), x=c(1:5,5:1), col="grey76", border = NA)
error.bars(cbind.fill(befdat$PIst.step.1a$Pairwise), bar=F, alpha = 0.05, sd = F, pch = 15, arrow.len = .00, lwd = 3, cex = 1.2, axes = FALSE, xlim = c(0.9,5.2), ylim = c(-0.007, 0.007), main = "", xlab = "", ylab = expression(Pi[ST]), mgp=c(2.5,0,0), add = T)
lines(befdat$PIst.step.1a$Results[,2], lty = 3)
#text(1,52, "a");text(2,52, "b");text(3,52, "c");text(4,52, "c")
abline(h = 0, lty = 1, lwd = .5)
axis(side = 2, hadj=0.7)
axis(side = 1, 1:5, c("T1","T2","T3","T4","T5"), las = 1)
#text(1.9,55, "Taxonomic", cex = 1.4)
box()
mtext("Successional stage (Years)", side=1, outer = T, line=4, at = .54, cex = .8)
#mtext("(a) Taxonomic", side=3, at = .152, outer = T, line=.4, cex = .9)
#mtext("(b) Phylogenetic", side=3, at = .494, outer = T, line=.4, cex = .9)
#mtext("(c) Functional", side=3, at = .815, outer = T, line=.4, cex = .9)
dev.off()

######################

#postscript("Succ.alpha.bef.pool.eps", width = 7.5, height = 3, paper = "special", onefile = FALSE, horizontal = FALSE, pointsize=12)
pdf("Succ.alpha.bef.pool.pdf", width = 7.5, height = 3)
par(mfcol=c(1,3), mar=c(0,3.8,0.5,.6),oma=c(5.2,0,1.6,0), tcl=.3, las=1, cex = .75)
#for (i in c(1,5,3)){
par(bty = "l")
error.bars(cbind.fill(befdat$Alpha.step.Dstar.w.1a$Alpha), bar=F, alpha = 0.05, sd = F, pch = 15, arrow.len = .00, lwd = 3, cex = 1.2, axes = FALSE, xlim = c(0.9,5.2), ylim = c(98,130), main = "", xlab = "", ylab = expression(Ds[italic(W)]^{italic(P)}), mgp=c(2,0,0))
polygon(y=c(befdat$Dstar.w.1s[,3], rev(befdat$Dstar.w.1s[,4])), x=c(1:5,5:1), col="grey76", border = NA)
error.bars(cbind.fill(befdat$Alpha.step.Dstar.w.1a$Alpha), bar=F, alpha = 0.05, sd = F, pch = 15, arrow.len = .00, lwd = 3, cex = 1.2, axes = FALSE, xlim = c(0.9,5.2), ylim = c(98,130), main = "", xlab = "", ylab = expression(Ds[italic(W)]^{italic(P)}), mgp=c(2,0,0), add = T)
lines(befdat$Dstar.w.1s[,2], lty = 3)
#text(1,52, "a");text(2,52, "b");text(3,52, "c");text(4,52, "c")
axis(side = 2, hadj=.5)
axis(side = 1, 1:5, c("T1","T2","T3","T4","T5"), las = 1)
#text(1.9,55, "Taxonomic", cex = 1.4)
box()
error.bars(cbind.fill(befdat$Alpha.step.Dstar.w.1a$Alpha), bar=F, alpha = 0.05, sd = F, pch = 15, arrow.len = .00, lwd = 3, cex = 1.2, axes = FALSE, xlim = c(0.9,5.2), ylim = c(98,130), main = "", xlab = "", ylab = expression(Ds[italic(W)]^{italic(P)}), mgp=c(2,0,0))
polygon(y=c(befdat$Dstar.w.1s[,6], rev(befdat$Dstar.w.1s[,7])), x=c(1:5,5:1), col="grey76", border = NA)
error.bars(cbind.fill(befdat$Alpha.step.Dstar.w.1a$Alpha), bar=F, alpha = 0.05, sd = F, pch = 15, arrow.len = .00, lwd = 3, cex = 1.2, axes = FALSE, xlim = c(0.9,5.2), ylim = c(98,130), main = "", xlab = "", ylab = expression(Ds[italic(W)]^{italic(P)}), mgp=c(2,0,0), add = T)
lines(befdat$Dstar.w.1s[,5], lty = 3)
#text(1,52, "a");text(2,52, "b");text(3,52, "c");text(4,52, "c")
axis(side = 2, hadj=.5)
axis(side = 1, 1:5, c("T1","T2","T3","T4","T5"), las = 1)
#text(1.9,55, "Taxonomic", cex = 1.4)
box()
error.bars(cbind.fill(befdat$Alpha.step.Dstar.w.1a$Alpha), bar=F, alpha = 0.05, sd = F, pch = 15, arrow.len = .00, lwd = 3, cex = 1.2, axes = FALSE, xlim = c(0.9,5.2), ylim = c(98,130), main = "", xlab = "", ylab = expression(Ds[italic(W)]^{italic(P)}), mgp=c(2,0,0))
polygon(y=c(befdat$Dstar.w.1s[,9], rev(befdat$Dstar.w.1s[,10])), x=c(1:5,5:1), col="grey76", border = NA)
error.bars(cbind.fill(befdat$Alpha.step.Dstar.w.1a$Alpha), bar=F, alpha = 0.05, sd = F, pch = 15, arrow.len = .00, lwd = 3, cex = 1.2, axes = FALSE, xlim = c(0.9,5.2), ylim = c(98,130), main = "", xlab = "", ylab = expression(Ds[italic(W)]^{italic(P)}), mgp=c(2,0,0), add = T)
lines(befdat$Dstar.w.1s[,8], lty = 3)
#text(1,52, "a");text(2,52, "b");text(3,52, "c");text(4,52, "c")
axis(side = 2, hadj=.5)
axis(side = 1, 1:5, c("T1","T2","T3","T4","T5"), las = 1)
#text(1.9,55, "Taxonomic", cex = 1.4)
box()
mtext("Successional stage (Years)", side=1, outer = T, line=4, at = .54, cex = .8)
mtext("(a) Age pool", side=3, at = .152, outer = T, line=.4, cex = .9)
mtext("(b) Landscape pool", side=3, at = .494, outer = T, line=.4, cex = .9)
mtext("(c) Regional pool", side=3, at = .815, outer = T, line=.4, cex = .9)
dev.off()

#######################################

#postscript("Succ.beta.bef.pool.eps", width = 7.5, height = 3, paper = "special", onefile = FALSE, horizontal = FALSE, pointsize=12)
pdf("Succ.beta.bef.pool.pdf", width = 7.5, height = 3)
par(mfcol=c(1,3), mar=c(0,3.8,0.5,.6),oma=c(5.2,0,1.6,0), tcl=.3, las=1, cex = .75)
#for (i in c(1,5,3)){
par(bty = "l")
error.bars(cbind.fill(befdat$Bst.step.1a$Pairwise), bar=F, alpha = 0.05, sd = F, pch = 15, arrow.len = .00, lwd = 3, cex = 1.2, axes = FALSE, xlim = c(0.9,5.2), ylim = c(-0.04, 0.026), main = "", xlab = "", ylab = expression(B[ST]), mgp=c(2.5,0,0))
polygon(y=c(befdat$Bst.1s[,3], rev(befdat$Bst.1s[,4])), x=c(1:5,5:1), col="grey76", border = NA)
error.bars(cbind.fill(befdat$Bst.step.1a$Pairwise), bar=F, alpha = 0.05, sd = F, pch = 15, arrow.len = .00, lwd = 3, cex = 1.2, axes = FALSE, xlim = c(0.9,5.2), ylim = c(-0.04, 0.026), main = "", xlab = "", ylab = expression(B[ST]), mgp=c(2.5,0,0), add = T)
lines(befdat$Bst.1s[,2], lty = 3)
#text(1,52, "a");text(2,52, "b");text(3,52, "c");text(4,52, "c")
axis(side = 2, hadj=.7)
axis(side = 1, 1:5, c("T1","T2","T3","T4","T5"), las = 1)
#text(1.9,55, "Taxonomic", cex = 1.4)
box()
error.bars(cbind.fill(befdat$Bst.step.1a$Pairwise), bar=F, alpha = 0.05, sd = F, pch = 15, arrow.len = .00, lwd = 3, cex = 1.2, axes = FALSE, xlim = c(0.9,5.2), ylim = c(-0.04, 0.026), main = "", xlab = "", ylab = expression(B[ST]), mgp=c(2.5,0,0))
polygon(y=c(befdat$Bst.1s[,6], rev(befdat$Bst.1s[,7])), x=c(1:5,5:1), col="grey76", border = NA)
error.bars(cbind.fill(befdat$Bst.step.1a$Pairwise), bar=F, alpha = 0.05, sd = F, pch = 15, arrow.len = .00, lwd = 3, cex = 1.2, axes = FALSE, xlim = c(0.9,5.2), ylim = c(-0.04, 0.026), main = "", xlab = "", ylab = expression(B[ST]), mgp=c(2.5,0,0), add = T)
lines(befdat$Bst.1s[,5], lty = 3)
#text(1,52, "a");text(2,52, "b");text(3,52, "c");text(4,52, "c")
axis(side = 2, hadj=.7)
axis(side = 1, 1:5, c("T1","T2","T3","T4","T5"), las = 1)
#text(1.9,55, "Taxonomic", cex = 1.4)
box()
error.bars(cbind.fill(befdat$Bst.step.1a$Pairwise), bar=F, alpha = 0.05, sd = F, pch = 15, arrow.len = .00, lwd = 3, cex = 1.2, axes = FALSE, xlim = c(0.9,5.2), ylim = c(-0.04, 0.026), main = "", xlab = "", ylab = expression(B[ST]), mgp=c(2.5,0,0))
polygon(y=c(befdat$Bst.1s[,9], rev(befdat$Bst.1s[,10])), x=c(1:5,5:1), col="grey76", border = NA)
error.bars(cbind.fill(befdat$Bst.step.1a$Pairwise), bar=F, alpha = 0.05, sd = F, pch = 15, arrow.len = .00, lwd = 3, cex = 1.2, axes = FALSE, xlim = c(0.9,5.2), ylim = c(-0.04, 0.026), main = "", xlab = "", ylab = expression(B[ST]), mgp=c(2.5,0,0), add = T)
lines(befdat$Bst.1s[,8], lty = 3)
#text(1,52, "a");text(2,52, "b");text(3,52, "c");text(4,52, "c")
axis(side = 2, hadj=.7)
axis(side = 1, 1:5, c("T1","T2","T3","T4","T5"), las = 1)
#text(1.9,55, "Taxonomic", cex = 1.4)
box()
mtext("Successional stage (Years)", side=1, outer = T, line=4, at = .54, cex = .8)
mtext("(a) Age pool", side=3, at = .152, outer = T, line=.4, cex = .9)
mtext("(b) Landscape pool", side=3, at = .494, outer = T, line=.4, cex = .9)
mtext("(c) Regional pool", side=3, at = .815, outer = T, line=.4, cex = .9)
dev.off()

##################################################
# test for phylogenetic signal in abundances
##################################################

apd.all <- function(com, dis, runs) { 
results <- matrix(NA, nrow = 1, ncol = 8)
colnames(results) <- c("APD","rand.mean","rand.sd","2.5%","97.5%","P.obs<exp","P.obs>exp","P.obs<>exp")
APD.tax.shuff <- function(com, runs){
  Res = NA
  for (r in 1:runs) {   
    Res <- c(Res, apd(sp.plot = resamp.1s(com), cophen = dis, abundance=TRUE))
  }
  return(Res)
}
obs <- apd(com, dis, abundance=TRUE)
resamp <- APD.tax.shuff(com=com, runs=runs)
resamp[1] <- obs
obs.rank <- rank(resamp)[1]
results[,1] <- obs
results[,2] <- mean(resamp[2:(runs+1)], na.rm = TRUE)
results[,3] <- sd(resamp[2:(runs+1)], na.rm = TRUE)
results[,4] <- quantile(resamp[2:(runs+1)],  probs = c(2.5, 97.5)/100)[1]
results[,5] <- quantile(resamp[2:(runs+1)],  probs = c(2.5, 97.5)/100)[2]
results[,6] <- obs.rank/(runs+1) ## P(1-sided test, H1: obs<exp)
results[,7] <- 1-(obs.rank/(runs+1)) ## P(1-sided test, H1: obs>exp)
results[,8] <- (1-(obs.rank/(runs+1)))*2 ## P(2-sided test, H1: obs<>exp)
colnames(results) <- c("APD","rand.mean","rand.sd","2.5%","97.5%","P.obs<exp","P.obs>exp","P.obs<>exp")
return(list(Results = results, Randvec = resamp))
}

mat <- match.phylo.comm(befdat$phy.147.ultra, t(befdat$com.order))
apd.all.147 <- apd.all(t(mat$comm), cophenetic(mat$phy), runs = 999)

mat <- match.phylo.comm(befdat$phy.143.ultra, t(befdat$com.order))



apd.all.143 <- apd.all(t(mat$comm), cophenetic(mat$phy), runs = 249)
apd.all.143$Results
## phylogenetic structure in species occurrences
apd.143.pa <- apd.all(t(decostand(mat$comm, method = "pa")), cophenetic(mat$phy), runs = 249)
apd.143.pa$Results
apd.all.143 <- apd.all(t(mat$comm), cophenetic(mat$phy), runs = 249)
apd.all.143$Results
## phylogenetic structure in species occurrences
apd.143.pa <- apd.all(t(decostand(mat$comm, method = "pa")), cophenetic(mat$phy), runs = 249)
apd.143.pa$Results


#> apd.all.143$Results
#            APD  rand.mean    rand.sd        2.5%      97.5% P.obs<exp
#[1,] 0.05264448 0.00038038 0.01863379 -0.03571692 0.03750156     0.993
#     P.obs>exp P.obs<>exp
#[1,]     0.007      0.014
#> apd.all.147$Results
#             APD   rand.mean   rand.sd       2.5%     97.5% P.obs<exp P.obs>exp
#[1,] 0.001234291 0.006243243 0.1235585 -0.3432292 0.1253932      0.31      0.69
#     P.obs<>exp
#[1,]       1.38

pdf("APD.pdf", width = 12, height = 6)
par(mfrow = c(1,2))
plot(density(apd.all.147$Randvec[2:1000]), main = "Abundance phylogenetic deviation (obs. vs. null), All", xlab = "APD", lwd = 2, ylim = c(0.2,7.5), xlim = c(-0.7,0.2))
abline(v=apd.all.147$Results[1], col = "red", lwd = 2)
abline(v=apd.all.147$Results[4], lty = 2)
abline(v=apd.all.147$Results[5], lty = 2)
plot(density(apd.all.143$Randvec[2:1000]), main = "Abundance phylogenetic deviation (obs. vs. null), non-Gymno", xlab = "APD", lwd = 2, ylim = c(0.2, 22), xlim = c(-0.07,0.07))
abline(v=apd.all.143$Results[1], col = "red", lwd = 2)
abline(v=apd.all.143$Results[4], lty = 2)
abline(v=apd.all.143$Results[5], lty = 2)
dev.off()

## phylogenetic structure in species occurrences
apd.143.pa <- apd.all(t(decostand(mat$comm, method = "pa")), cophenetic(mat$phy), runs = 999)
apd.143.pa$Results
################

pdf("APD.143.occ.pdf", width = 5, height = 5)
#postscript("APD.143.occ.eps", width = 5, height = 5, paper = "special", onefile = FALSE, horizontal = FALSE, pointsize=12)
plot(density(apd.143.pa$Randvec[2:100]), main = "", xlab = "APD", lwd = 2, ylim = c(0.2, 52), xlim = c(-0.021,0.028))
abline(v=apd.143.pa$Results[1], col = "red", lwd = 2)
abline(v=apd.143.pa$Results[4], lty = 2)
abline(v=apd.143.pa$Results[5], lty = 2)
dev.off()

#####################


#################################

# null models
rao.tax.shuff <- function(samp, phy, runs){
  Res = list()
  for (r in 1:runs) {
    phy.shuff=taxaShuffle(phy)
    samp.order=samp[ ,match(colnames(phy.shuff), colnames(samp))]    
    Res <- c(Res, list(Rao(sample=t(samp.order), dfunc=NULL, dphyl=phy.shuff, weight=F, Jost=T, structure=NULL)$PD$Alpha))
  }
  return(Res)
}

RaoPD.taxshuff.alpha <- rao.tax.shuff(mat$comm, cophenetic(mat$phy), 999)

# SES

ses.alpha <- function(obs, rand){
  rand <- t(as.data.frame(lapply(rand, as.vector)))
  physo.obs <- as.numeric(obs)
  physo.mean <- apply(rand, MARGIN = 2, FUN = mean, na.rm = TRUE)
  physo.sd <- apply(rand, MARGIN = 2, FUN = sd, na.rm = TRUE)
  physo.ses <- (physo.obs - physo.mean)/physo.sd
  physo.obs.rank <- apply(X = rbind(physo.obs, rand), MARGIN = 2, FUN = rank)[1, ]
  physo.obs.rank <- ifelse(is.na(physo.mean), NA, physo.obs.rank)
  data.frame(physo.obs, physo.mean, physo.sd, physo.obs.rank, physo.ses, physo.obs.p = physo.obs.rank/(dim(rand)[1] + 1))
}

PD.ses <- ses.alpha(Rao.PD$PD$Alpha, RaoPD.taxshuff.alpha)

mean(PD.ses$physo.ses[19:27])

##########################



save(SapesData, file = paste(path.data,"SapesData.Rdata", sep = ""))
load(paste(path.data,"SapesData.Rdata", sep = ""))

load(paste(path.data,"traits.t.imp.Rdata", sep = ""))

# convert factorial traits to numeric
traits.t.imp.num <- traits.t.imp
traits.t.imp.num$life_form <- as.numeric(traits.t.imp$life_form)
traits.t.imp.num$leaf_longevity <- as.numeric(traits.t.imp$leaf_longevity)

# correlation between traits
pdf("traits.t.imp.pdf", width = 16, height = 16)
CorTestPlot(traits.t.imp)
dev.off()

# CWM trait values
com <- SapesData$comtrans
phyl <- SapesData$tree.non.gym.wood
com.order <- com[, match(phyl$tip.label, colnames(com))]

traits.order <- traits.imp[match(phyl$tip.label, rownames(traits.imp)),]

match(rownames(traits.order), colnames(com.order))

cwm <- functcomp(traits.order[,-6], as.matrix(com.order), bin.num = c("perennial","insect_pollen_exclusive","specialist"))

round(apply(cwm[1:54,], 2, mean), 3)
round(apply(cwm[55:108,], 2, mean), 3)

SapesData$cwm <- cwm

# calculate functional diversity
# single traits

# order the trait data
traits.order <- traits.t.imp[match(phyl$tip.label, rownames(traits.t.imp)),]

# gow <- gowdis(as.data.frame(traits.t.imp$seed_mass_leda))

sbank <- as.data.frame(phycom09$traits.all.t.imp.herb$sbank)
rownames(sbank) <- rownames(phycom09$traits.all.t.imp.herb)
colnames(sbank) <- "sbank"
# euclidean dist for continuous traits
sbank.dist <- dist(scale(sbank))

# gower distance for binary single traits (? also for continous, see mokany, 2008?, YES!!!) and mixed trait sets

## TEST
Rao.PD <- Rao(sample=t(com.order), dfunc=NULL, dphyl=cophenetic(phyl), weight=F, Jost=T, structure=NULL)$PD$Pairwise_samples$Beta_prop

############################################
## Null models for phylogenetic diversity ##
############################################

# 1)  Rao-partitioning for PD
Rao.PD <- Rao(sample=t(com.order), dfunc=NULL, dphyl=cophenetic(phycom09$phyl.herb), weight=F, Jost=T, structure=NULL)

# 2) Null models ? how for FD?
rao.tax.shuff <- function(samp, phy, runs){
  Res = list()
  for (r in 1:runs) {
    phy.shuff=taxaShuffle(phy)
    samp.order=samp[ ,match(colnames(phy.shuff), colnames(samp))]    
    Res <- c(Res, list(Rao(sample=t(samp.order), dfunc=NULL, dphyl=phy.shuff, weight=F, Jost=T, structure=NULL)$PD$Alpha))
  }
  return(Res)
}

system.time(
RaoPD.taxshuff.alpha <- rao.tax.shuff(com.order, cophenetic(phycom09$phyl.herb), 999)
)

# 3) SES
ses.alpha <- function(obs, rand){
  rand <- t(as.data.frame(lapply(rand, as.vector)))
  physo.obs <- as.numeric(obs)
  physo.mean <- apply(rand, MARGIN = 2, FUN = mean, na.rm = TRUE)
  physo.sd <- apply(rand, MARGIN = 2, FUN = sd, na.rm = TRUE)
  physo.ses <- (physo.obs - physo.mean)/physo.sd
  physo.obs.rank <- apply(X = rbind(physo.obs, rand), MARGIN = 2, FUN = rank)[1, ]
  physo.obs.rank <- ifelse(is.na(physo.mean), NA, physo.obs.rank)
  data.frame(physo.obs, physo.mean, physo.sd, physo.obs.rank, physo.ses, physo.obs.p = physo.obs.rank/(dim(rand)[1] + 1))
}

# program function that a) calculates Rao, b) does the Null models and c) calculates the SES

# PhylAlpha
# include com.order
com <- SapesData$comtrans
phyl <- SapesData$tree.non.gym.wood
com.order <- com[, match(phyl$tip.label, colnames(com))]
rao.tax.shuff <- function(samp, phy, runs){
  Res = list()
  for (r in 1:runs) {
    phy.shuff=taxaShuffle(phy)
    samp.order=samp[ ,match(colnames(phy.shuff), colnames(samp))]    
    Res <- c(Res, list(Rao(sample=t(samp.order), dfunc=NULL, dphyl=phy.shuff, weight=F, Jost=T, structure=NULL)$PD$Alpha))
  }
  return(Res)
}
DivPartGrandPDalpha <- function(com, dfunc, dphyl, runs){
  Rao.PD <- Rao(sample = t(com), dfunc = dfunc, dphyl = dphyl, weight = F, Jost = T, structure = NULL)
  shuff <- rao.tax.shuff(samp = com, phy=dphyl, runs=runs)
  ses.PD <- ses.alpha(Rao.PD$PD$Alpha, shuff)
  return(ses.PD)
}

PDalpha <- DivPartGrandPDalpha(com=com.order, dfunc=NULL, dphyl=cophenetic(phyl), runs = 999)
write.csv(PDalpha, "PDalpha.csv")

##########
# PhylBeta
rao.tax.shuff <- function(samp, phy, runs){
  Res = list()
  for (r in 1:runs) {
    phy.shuff=taxaShuffle(phy)
    samp.order=samp[ ,match(colnames(phy.shuff), colnames(samp))]    
    Res <- c(Res, list(Rao(sample=t(samp.order), dfunc=NULL, dphyl=phy.shuff, weight=F, Jost=T, structure=NULL)$PD$Pairwise_samples$Beta_prop))
  }
  return(Res)
}
DivPartGrandPDbeta <- function(com, dfunc, dphyl, runs){
  Rao.PD <- Rao(sample = t(com), dfunc = dfunc, dphyl = dphyl, weight = F, Jost = T, structure = NULL)
  shuff <- rao.tax.shuff(samp = com, phy=dphyl, runs=runs)
  ses.PD <- ses.alpha(Rao.PD$PD$Pairwise_samples$Beta_prop, shuff)
  return(ses.PD)
}
PDbeta <- DivPartGrandPDbeta(com=com.order, dfunc=NULL, dphyl=cophenetic(phyl), runs = 999)
write.csv(PDbeta, "PDbeta.csv")

SapesData$PDalpha <- PDalpha 
SapesData$PDbeta <- PDbeta

###

# FunctAlpha
# include com.order

traits.order <- traits.t.imp[match(phyl$tip.label, rownames(traits.t.imp)),]
traits.order.num <- traits.t.imp.num[match(phyl$tip.label, rownames(traits.t.imp.num)),]
# !!!# Saturday evening ## continue here
# gow <- gowdis(as.data.frame(traits.t.imp$seed_mass_leda))

sbank <- as.data.frame(phycom09$traits.all.t.imp.herb$sbank)
rownames(sbank) <- rownames(phycom09$traits.all.t.imp.herb)
colnames(sbank) <- "sbank"
# euclidean dist for continuous traits

rda.lhs <- rda(scale(traits.order[, c(1,2,4)]))
# trait distance matrices
# lhs
pca.lhs.dist <- dist(rda.lhs$CA$u)
lhs.dist <- dist(scale(traits.order[, c(1,2,4)]))
lhs.gow <- gowdis(scale(traits.order[, c(1,2,4)]))

com <- SapesData$comtrans
com.order <- com[, match(phyl$tip.label, colnames(com))]
traitdist <- as.matrix(pca.lhs.dist)
match(colnames(traitdist), colnames(com.order))

#########################################
########### start here ############
# lhs.dist
traitdist <- lhs.dist
rao.tax.shuff <- function(samp, phy, runs){  
  Res = list()
  for (r in 1:runs) {
    phy.shuff=taxaShuffle(phy)
    samp.order=samp[ ,match(colnames(phy.shuff), colnames(samp))]    
    Res <- c(Res, list(Rao(sample=t(samp.order), dfunc=phy.shuff, dphyl=NULL, weight=F, Jost=T, structure=NULL)$FD$Alpha))
  }
  return(Res)
}
DivPartGrandFDalpha <- function(com, dfunc, dphyl, runs){
  Rao.PD <- Rao(sample = t(com), dfunc = dfunc, dphyl = dphyl, weight = F, Jost = T, structure = NULL)  
  shuff <- rao.tax.shuff(samp = com, phy=dfunc, runs=runs)
  ses.PD <- ses.alpha(Rao.PD$FD$Alpha, shuff)
  return(ses.PD)
}
FDalpha.lhs.dist <- DivPartGrandFDalpha(com=com.order, dfunc=traitdist, dphyl=NULL, runs = 999)
write.csv(FDalpha.lhs.dist, "FDalpha.lhs.dist.csv")

##########
# FunctBeta
rao.tax.shuff <- function(samp, phy, runs){
  Res = list()
  for (r in 1:runs) {
    phy.shuff=taxaShuffle(phy)
    samp.order=samp[ ,match(colnames(phy.shuff), colnames(samp))]    
    Res <- c(Res, list(Rao(sample=t(samp.order), dfunc=phy.shuff, dphyl=NULL, weight=F, Jost=T, structure=NULL)$FD$Pairwise_samples$Beta_prop))
  }
  return(Res)
}
DivPartGrandFDbeta <- function(com, dfunc, dphyl, runs){
  Rao.PD <- Rao(sample = t(com), dfunc = dfunc, dphyl = dphyl, weight = F, Jost = T, structure = NULL)
  shuff <- rao.tax.shuff(samp = com, phy=dfunc, runs=runs)
  ses.PD <- ses.alpha(Rao.PD$FD$Pairwise_samples$Beta_prop, shuff)
  return(ses.PD)
}
FDbeta.lhs.dist <- DivPartGrandFDbeta(com=com.order, dfunc=traitdist, dphyl=NULL, runs = 999)
write.csv(FDbeta.lhs.dist, "FDbeta.lhs.dist.csv")

SapesData$FDalpha.lhs.dist <- FDalpha.lhs.dist
SapesData$FDbeta.lhs.dist <- FDbeta.lhs.dist
save(SapesData, file = paste(path.data,"SapesData.Rdata", sep = ""))



## # lhs.gow
## traitdist <- lhs.gow
## rao.tax.shuff <- function(samp, phy, runs){  
##   Res = list()
##   for (r in 1:runs) {
##     phy.shuff=taxaShuffle(phy)
##     samp.order=samp[ ,match(colnames(phy.shuff), colnames(samp))]    
##     Res <- c(Res, list(Rao(sample=t(samp.order), dfunc=phy.shuff, dphyl=NULL, weight=F, Jost=T, structure=NULL)$FD$Alpha))
##   }
##   return(Res)
## }
## DivPartGrandFDalpha <- function(com, dfunc, dphyl, runs){
##   Rao.PD <- Rao(sample = t(com), dfunc = dfunc, dphyl = dphyl, weight = F, Jost = T, structure = NULL)  
##   shuff <- rao.tax.shuff(samp = com, phy=dfunc, runs=runs)
##   ses.PD <- ses.alpha(Rao.PD$FD$Alpha, shuff)
##   return(ses.PD)
## }
## FDalpha.lhs.gow <- DivPartGrandFDalpha(com=com.order, dfunc=traitdist, dphyl=NULL, runs = 999)
## write.csv(FDalpha.lhs.gow, "FDalpha.lhs.gow.csv")

##########
# FunctBeta
rao.tax.shuff <- function(samp, phy, runs){
  Res = list()
  for (r in 1:runs) {
    phy.shuff=taxaShuffle(phy)
    samp.order=samp[ ,match(colnames(phy.shuff), colnames(samp))]    
    Res <- c(Res, list(Rao(sample=t(samp.order), dfunc=phy.shuff, dphyl=NULL, weight=F, Jost=T, structure=NULL)$FD$Pairwise_samples$Beta_prop))
  }
  return(Res)
}
DivPartGrandFDbeta <- function(com, dfunc, dphyl, runs){
  Rao.PD <- Rao(sample = t(com), dfunc = dfunc, dphyl = dphyl, weight = F, Jost = T, structure = NULL)
  shuff <- rao.tax.shuff(samp = com, phy=dfunc, runs=runs)
  ses.PD <- ses.alpha(Rao.PD$FD$Pairwise_samples$Beta_prop, shuff)
  return(ses.PD)
}
FDbeta.lhs.gow <- DivPartGrandFDbeta(com=com.order, dfunc=traitdist, dphyl=NULL, runs = 999)
write.csv(FDbeta.lhs.gow, "FDbeta.lhs.gow.csv")

SapesData$FDalpha.lhs.gow <- FDalpha.lhs.gow
SapesData$FDbeta.lhs.gow <- FDbeta.lhs.gow
save(SapesData, file = paste(path.data,"SapesData.Rdata", sep = ""))


#######
# FD: all 12 traits (PCA dist, dist, gow)

rda.all.pca <- rda(scale(traits.order.num[, -6]))
# trait distance matrices
# all
all.pca <- dist(rda.all.pca$CA$u)
all.dist <- dist(scale(traits.order.num[, -6]))
all.gow <- gowdis(traits.order[, -6])



# all.pca
traitdist <- all.pca
rao.tax.shuff <- function(samp, phy, runs){  
  Res = list()
  for (r in 1:runs) {
    phy.shuff=taxaShuffle(phy)
    samp.order=samp[ ,match(colnames(phy.shuff), colnames(samp))]    
    Res <- c(Res, list(Rao(sample=t(samp.order), dfunc=phy.shuff, dphyl=NULL, weight=F, Jost=T, structure=NULL)$FD$Alpha))
  }
  return(Res)
}
DivPartGrandFDalpha <- function(com, dfunc, dphyl, runs){
  Rao.PD <- Rao(sample = t(com), dfunc = dfunc, dphyl = dphyl, weight = F, Jost = T, structure = NULL)  
  shuff <- rao.tax.shuff(samp = com, phy=dfunc, runs=runs)
  ses.PD <- ses.alpha(Rao.PD$FD$Alpha, shuff)
  return(ses.PD)
}
FDalpha.all.pca <- DivPartGrandFDalpha(com=com.order, dfunc=traitdist, dphyl=NULL, runs = 999)
write.csv(FDalpha.all.pca, "FDalpha.all.pca.csv")

##########
# FunctBeta
rao.tax.shuff <- function(samp, phy, runs){
  Res = list()
  for (r in 1:runs) {
    phy.shuff=taxaShuffle(phy)
    samp.order=samp[ ,match(colnames(phy.shuff), colnames(samp))]    
    Res <- c(Res, list(Rao(sample=t(samp.order), dfunc=phy.shuff, dphyl=NULL, weight=F, Jost=T, structure=NULL)$FD$Pairwise_samples$Beta_prop))
  }
  return(Res)
}
DivPartGrandFDbeta <- function(com, dfunc, dphyl, runs){
  Rao.PD <- Rao(sample = t(com), dfunc = dfunc, dphyl = dphyl, weight = F, Jost = T, structure = NULL)
  shuff <- rao.tax.shuff(samp = com, phy=dfunc, runs=runs)
  ses.PD <- ses.alpha(Rao.PD$FD$Pairwise_samples$Beta_prop, shuff)
  return(ses.PD)
}
FDbeta.all.pca <- DivPartGrandFDbeta(com=com.order, dfunc=traitdist, dphyl=NULL, runs = 999)
write.csv(FDbeta.all.pca, "FDbeta.all.pca.csv")

SapesData$FDalpha.all.pca <- FDalpha.all.pca
SapesData$FDbeta.all.pca <- FDbeta.all.pca
save(SapesData, file = paste(path.data,"SapesData.Rdata", sep = ""))





# all.dist
traitdist <- all.dist
rao.tax.shuff <- function(samp, phy, runs){  
  Res = list()
  for (r in 1:runs) {
    phy.shuff=taxaShuffle(phy)
    samp.order=samp[ ,match(colnames(phy.shuff), colnames(samp))]    
    Res <- c(Res, list(Rao(sample=t(samp.order), dfunc=phy.shuff, dphyl=NULL, weight=F, Jost=T, structure=NULL)$FD$Alpha))
  }
  return(Res)
}
DivPartGrandFDalpha <- function(com, dfunc, dphyl, runs){
  Rao.PD <- Rao(sample = t(com), dfunc = dfunc, dphyl = dphyl, weight = F, Jost = T, structure = NULL)  
  shuff <- rao.tax.shuff(samp = com, phy=dfunc, runs=runs)
  ses.PD <- ses.alpha(Rao.PD$FD$Alpha, shuff)
  return(ses.PD)
}
FDalpha.all.dist <- DivPartGrandFDalpha(com=com.order, dfunc=traitdist, dphyl=NULL, runs = 999)
write.csv(FDalpha.all.dist, "FDalpha.all.dist.csv")

##########
# FunctBeta
rao.tax.shuff <- function(samp, phy, runs){
  Res = list()
  for (r in 1:runs) {
    phy.shuff=taxaShuffle(phy)
    samp.order=samp[ ,match(colnames(phy.shuff), colnames(samp))]    
    Res <- c(Res, list(Rao(sample=t(samp.order), dfunc=phy.shuff, dphyl=NULL, weight=F, Jost=T, structure=NULL)$FD$Pairwise_samples$Beta_prop))
  }
  return(Res)
}
DivPartGrandFDbeta <- function(com, dfunc, dphyl, runs){
  Rao.PD <- Rao(sample = t(com), dfunc = dfunc, dphyl = dphyl, weight = F, Jost = T, structure = NULL)
  shuff <- rao.tax.shuff(samp = com, phy=dfunc, runs=runs)
  ses.PD <- ses.alpha(Rao.PD$FD$Pairwise_samples$Beta_prop, shuff)
  return(ses.PD)
}
FDbeta.all.dist <- DivPartGrandFDbeta(com=com.order, dfunc=traitdist, dphyl=NULL, runs = 999)
write.csv(FDbeta.all.dist, "FDbeta.all.dist.csv")

SapesData$FDalpha.all.dist <- FDalpha.all.dist
SapesData$FDbeta.all.dist <- FDbeta.all.dist
save(SapesData, file = paste(path.data,"SapesData.Rdata", sep = ""))



# all.gow
traitdist <- all.gow
rao.tax.shuff <- function(samp, phy, runs){  
  Res = list()
  for (r in 1:runs) {
    phy.shuff=taxaShuffle(phy)
    samp.order=samp[ ,match(colnames(phy.shuff), colnames(samp))]    
    Res <- c(Res, list(Rao(sample=t(samp.order), dfunc=phy.shuff, dphyl=NULL, weight=F, Jost=T, structure=NULL)$FD$Alpha))
  }
  return(Res)
}
DivPartGrandFDalpha <- function(com, dfunc, dphyl, runs){
  Rao.PD <- Rao(sample = t(com), dfunc = dfunc, dphyl = dphyl, weight = F, Jost = T, structure = NULL)  
  shuff <- rao.tax.shuff(samp = com, phy=dfunc, runs=runs)
  ses.PD <- ses.alpha(Rao.PD$FD$Alpha, shuff)
  return(ses.PD)
}
FDalpha.all.gow <- DivPartGrandFDalpha(com=com.order, dfunc=traitdist, dphyl=NULL, runs = 999)
write.csv(FDalpha.all.gow, "FDalpha.all.gow.csv")

##########
# FunctBeta
rao.tax.shuff <- function(samp, phy, runs){
  Res = list()
  for (r in 1:runs) {
    phy.shuff=taxaShuffle(phy)
    samp.order=samp[ ,match(colnames(phy.shuff), colnames(samp))]    
    Res <- c(Res, list(Rao(sample=t(samp.order), dfunc=phy.shuff, dphyl=NULL, weight=F, Jost=T, structure=NULL)$FD$Pairwise_samples$Beta_prop))
  }
  return(Res)
}
DivPartGrandFDbeta <- function(com, dfunc, dphyl, runs){
  Rao.PD <- Rao(sample = t(com), dfunc = dfunc, dphyl = dphyl, weight = F, Jost = T, structure = NULL)
  shuff <- rao.tax.shuff(samp = com, phy=dfunc, runs=runs)
  ses.PD <- ses.alpha(Rao.PD$FD$Pairwise_samples$Beta_prop, shuff)
  return(ses.PD)
}
FDbeta.all.gow <- DivPartGrandFDbeta(com=com.order, dfunc=traitdist, dphyl=NULL, runs = 999)
write.csv(FDbeta.all.gow, "FDbeta.all.gow.csv")

SapesData$FDalpha.all.gow <- FDalpha.all.gow
SapesData$FDbeta.all.gow <- FDbeta.all.gow
save(SapesData, file = paste(path.data,"SapesData.Rdata", sep = ""))


####### stop here monday #######






## 
## ! to do: a) LHS euclidean but without PCA, b) LHS, gower (using factor levels), c) FD for all traits

## functional diversity for single traits (euclidean distances of untransformed, imputed trait values)
# alpha diversity

rao.tax.shuff <- function(samp, phy, runs){  
  Res = list()
  for (r in 1:runs) {
    phy.shuff=taxaShuffle(phy)
    samp.order=samp[ ,match(colnames(phy.shuff), colnames(samp))]    
    Res <- c(Res, list(Rao(sample=t(samp.order), dfunc=phy.shuff, dphyl=NULL, weight=F, Jost=T, structure=NULL)$FD$Alpha))
  }
  return(Res)
}
DivPartGrandFDalpha <- function(com, dfunc, dphyl, runs){
  Rao.PD <- Rao(sample = t(com), dfunc = dfunc, dphyl = dphyl, weight = F, Jost = T, structure = NULL)  
  shuff <- rao.tax.shuff(samp = com, phy=dfunc, runs=runs)
  ses.PD <- ses.alpha(Rao.PD$FD$Alpha, shuff)
  return(ses.PD)
}
# needs: com.order
for (i in c(1:5, 7:13)){  
  singledis <- as.data.frame(traits.order.num[,i])
  rownames(singledis) <- rownames(traits.order.num)
  colnames(singledis) <- colnames(traits.order.num)[i]
  singledis <- as.matrix(dist(singledis))  
  FDalpha.single.dist <- DivPartGrandFDalpha(com=com.order, dfunc=singledis, dphyl=NULL, runs = 999)
  write.csv(FDalpha.single.dist, file = paste(colnames(traits.order.num)[i], "FDalpha.single.dist.csv", sep = "_"))
}

##################
# single beta
rao.tax.shuff <- function(samp, phy, runs){  
  Res = list()
  for (r in 1:runs) {
    phy.shuff=taxaShuffle(phy)
    samp.order=samp[ ,match(colnames(phy.shuff), colnames(samp))]    
    Res <- c(Res, list(Rao(sample=t(samp.order), dfunc=phy.shuff, dphyl=NULL, weight=F, Jost=T, structure=NULL)$FD$Pairwise_samples$Beta_prop))
  }
  return(Res)
}
DivPartGrandFDbeta <- function(com, dfunc, dphyl, runs){
  Rao.PD <- Rao(sample = t(com), dfunc = dfunc, dphyl = dphyl, weight = F, Jost = T, structure = NULL)  
  shuff <- rao.tax.shuff(samp = com, phy=dfunc, runs=runs)
  ses.PD <- ses.alpha(Rao.PD$FD$Pairwise_samples$Beta_prop, shuff)
  return(ses.PD)
}
for (i in c(1:5, 7:13)){  
  singledis <- as.data.frame(traits.order.num[,i])
  rownames(singledis) <- rownames(traits.order.num)
  colnames(singledis) <- colnames(traits.order.num)[i]
  singledis <- as.matrix(dist(singledis))  
FDbeta.single.dist <- DivPartGrandFDbeta(com=com.order, dfunc=singledis, dphyl=NULL, runs = 999)
  write.csv(FDbeta.single.dist, file = paste(colnames(traits.order.num)[i], "FDbeta.single.dist.csv", sep = "_"))
}

################### run until here ########################

                                        
# utility functions

# vec2dist: converts vector of betadiversity values into a distance matrix
# arguments:
# betavec - vector of beta diversity values
# com - community data frame (sites x species)

vec2dist <- function(betavec, com){
  mat <- matrix(NA, nrow = dim(com)[1], ncol = dim(com)[1])
  rownames(mat) <- rownames(com) 
  colnames(mat) <- rownames(com) 
  d <- as.dist(mat)
  for (i in 1:length(betavec)){
      d[i] <- betavec[i]
    }
  d
}

# example
ex1 <- vec2dist(betavec = PDbeta$physo.obs, com = comtrans)

# groupbeta: groups beta diversity values into three groups (within treatment: con, org, between treatmeants: conorg)
groupbeta <- function(betavec, com){
  mat <- matrix(NA, nrow = dim(com)[1], ncol = dim(com)[1])
  rownames(mat) <- rownames(com) 
  colnames(mat) <- rownames(com) 
  d <- as.dist(mat)
  for (i in 1:length(betavec)){
      d[i] <- betavec[i]
    }
  betadiv.mat <- as.matrix(d)
  betadiv.mat.con <- betadiv.mat[1:54,1:54] 
  betadiv.dist.con <- as.dist(betadiv.mat.con)
  betadiv.num.con <- as.numeric(betadiv.dist.con)  
  betadiv.mat.org <- betadiv.mat[55:108,55:108] 
  betadiv.dist.org <- as.dist(betadiv.mat.org)
  betadiv.num.org <- as.numeric(betadiv.dist.org)
  betadiv.mat.conorg <- betadiv.mat[55:108,1:54] 
  betadiv.num.conorg <- as.numeric(betadiv.mat.conorg)
  beta.num <- c(betadiv.num.con,betadiv.num.org,betadiv.num.conorg)
  namvec <- ordered(as.factor(c(rep("con", 1431),rep("org", 1431),rep("conorg", 2916))), c("con","org","conorg"))
  beta.vec <- as.data.frame(cbind(beta.num, ordered(namvec)))
  colnames(beta.vec) <- c("beta", "treat") 
  beta.vec$treat <- namvec
  #boxplot(beta ~ treat, data = beta.vec)
  beta.vec
}

# example
ex2 <- groupbeta(betavec = beta[,1], com = SapesData$comtrans)

res <- ordered(as.factor(c(rep("con", 1431),rep("org", 1431),rep("conorg", 2916))), c("con","org","conorg"))


ex2 <- groupbeta(betavec = beta[,1], com = SapesData$comtrans)[,1]


res <- ordered(as.factor(c(rep("con", 1431),rep("org", 1431),rep("conorg", 2916))), c("con","org","conorg"))
for (i in 1:39){
  tab <- groupbeta(betavec = beta[,i], com = SapesData$comtrans)[,1]
  res <- cbind(res, tab)
  res
}

res <- as.data.frame(res)
res[,1] <- namvec
names(res)[2:40] <- names(beta) 
names(res)[1] <- "treat" 

beta.treat <- res

######################
# plot beta diversity
######################

pdf("beta.pdf", width = 10, height = 9)
par(mfrow=c(3,4))
for (i in 2:40){
  boxplot(beta.treat[,i] ~ treat, main = names(beta.treat[i]), data = beta.treat)
}
dev.off()

#######################
# plot alpha diversity
#######################

alpha$treat <- as.factor(rep(c("con", "org"), each = 54))

pdf("alpha.pdf")
par(mfrow=c(3,4))
for (i in 1:40){
  boxplot(alpha[,i] ~ treat, main = names(alpha[i]), data = alpha)
}
dev.off()

#######################
###### plot CWM #######
#######################

SapesData$cwm$treat <- as.factor(rep(c("con", "org"), each = 54))

pdf("cwm.pdf")
par(mfrow=c(3,4))
for (i in 1:12){
  boxplot(SapesData$cwm[,i] ~ treat, main = names(SapesData$cwm[i]), data = SapesData$cwm)
}
dev.off()

##########################################################################
# read in files from a specific folder, and bind column "obs" and "ses"
##########################################################################

dat <- data.frame(NA)
for (i in 1:12){
  tab <- read.csv(paste("/home/oliver/Dokumente/Dropbox/Oliver_Romina_Johan/Results/Diversity/All/Beta/FD/Single/", dir("/home/oliver/Dokumente/Dropbox/Oliver_Romina_Johan/Results/Diversity/All/Beta/FD/Single")[i], sep = ""))[,c(2,6)]
  dat <- cbind(dat, tab)
  dat
}

# generate vector of column names
vec <- as.vector(1:12)
for (i in 1:12){
  vec[i] <- strsplit(dir("/home/oliver/Dokumente/Dropbox/Oliver_Romina_Johan/Results/Diversity/All/Beta/FD/Single"), split = "_")[[i]][1]
}
# for alpha div
namvec <- paste(paste("FDbeta", rep(vec, each = 2), sep = "."), rep(c("obs", "ses"), 12), sep = ".")
# for beta div
#namvec <- paste(rep(vec, each = 2), rep(c("obs", "ses"), 6), sep = ".")

colnames(dat)[-1] <- namvec
dat <- dat[,-1]

write.csv(dat, file = "FD.single.beta.csv")

########################################################################

# !!! check data for beta multi and single

# load alpha and beta- diversity files
beta <- read.csv("/home/oliver/Dokumente/Dropbox/Oliver_Romina_Johan/Results/Diversity/All/Beta/TD_PD_FDbeta.csv", row.names = 1)

alpha <- read.csv("/home/oliver/Dokumente/Dropbox/Oliver_Romina_Johan/Results/Diversity/All/Alpha/TD_PD_FDalpha.csv", sep = "\t", row.names = 1)

TDvec <- as.vector(as.dist(TDbeta))

write.csv(TDvec, file = "TDvec.csv")

/home/oliver/Dokumente/Dropbox/Oliver_Romina_Johan/Results/Diversity/All/Beta/FD/Multi

SapesData$Beta.treat <- beta.treat

SapesData$Beta.treat[1:5,1:5]

write.csv(SapesData$Beta.treat, file = "Beta.treat.csv")

# homogenize species names in com, traits, phylo

tree.full <- prune.sample(SapesData$comtrans, phyl)
write.tree(tree.full, file = "tree.full.txt")

# exclude gymnosperms
tree.non.gym <- drop.tip(tree.full, tip=c("Equisetum_pratense", "Equisetum_palustre", "Equisetum_arvense", "Pteridium_aquilinum", "Athyrium_filix-femina" ))
write.tree(tree.non.gym, file = "tree.non.gym.txt")

# exclude gymnosperms and non-woody species
tree.non.gym.wood <- drop.tip(tree.non.gym, tip=c("Acer_platanoides","Acer_pseudoplatanus", "Crataegus_laevigata","Euonymus_europaea","Fagus_sylvatica","Fraxinus_excelsior","Populus_tremula","Prunus_avium","Prunus_domestica","Prunus_spinosa","Quercus_robur","Ribes_uva-crispa","Rosa_canina","Rubus_caesius","Rubus_idaeus","Salix_repens","Sambucus_nigra","Sorbus_aucuparia","Tilia_cordata","Ulmus_glabra"))
write.tree(tree.non.gym.wood, file = "tree.non.gym.wood.txt")

pdf("tree.non.gym.wood.pdf", width = 8, height = 8.5)
plot(SapesData$tree.non.gym.wood, type = "f", cex = .5)
dev.off()

# saving the three different trees
SapesData$tree.full <- tree.full
SapesData$tree.non.gym <- tree.non.gym
SapesData$tree.non.gym.wood <- tree.non.gym.wood

############
#### calculate Rao for PD (try with and without abundance weighting)

# a) Full phylogeny including all 235 species 
# match species names in community data and phylogenetic tree
com <- SapesData$comtrans
phyl <- SapesData$tree.non.gym.wood
com.order <- t(com[, match(phyl$tip.label, colnames(com))])
# Rao-partitioning for PD
Rao.PD <- Rao(sample=com.order, dfunc=NULL, dphyl=cophenetic(phyl), weight=F, Jost=T, structure=NULL)

Rao_TD_Alpha <- cbind(Rao.PD$TD$Richness_per_plot, Rao.PD$TD$Alpha)
colnames(Rao_TD_Alpha) <- c("SR", "TDalpha")
write.csv(Rao_TD_Alpha, file = "TDalpha.csv")

Rao_TD_Beta <- as.matrix(Rao.PD$TD$Pairwise_samples$Beta_prop)
write.csv(Rao_TD_Beta, file = "Rao_TD_Beta.csv")

Rao_PD_Beta <- as.matrix(Rao.PD$PD$Pairwise_samples$Beta_prop)
write.csv(Rao_PD_Beta, file = "Rao_PD_Beta.csv")




mean(Rao.PD$TD$Richness_per_plot[1:54])
mean(Rao.PD$TD$Richness_per_plot[55:108])
mean(Rao.PD$TD$Alpha[1:54])
mean(Rao.PD$TD$Alpha[55:108])
mean(Rao.PD$PD$Alpha[1:54])
mean(Rao.PD$PD$Alpha[55:108])




env <- read.csv(paste(path.data,"landscapeidinfopc1.csv", sep = ""))
phyl <- read.tree(paste(path.data,"daphne_romina.tre", sep = ""))
load(paste(path.data,"datlist.Rdata", sep = ""))

# homogenize dimnames
identical(traits$species_phylo, traits$species_romina)
# .... 

# create new variable "ekofarm" coding for farming practice (con=convential, org=organic)
env[,1] <- c(rep("Con", 9), rep("Org", 9))

# export data sets
save(traits, file = paste(path.data, "traits.Rdata", sep = ""))
# ...

# create data.list
com <- t(com)
datlist <- data.list(com, env, traits)
save(datlist, file = paste(path.data, "datlist.Rdata", sep = ""))

# inspect trait data
#pdf("hist.traits.pdf")
par(mfrow=c(4,4))
for (i in 1:13){
  hist(traits[,i], main = names(traits[i]))
}
#dev.off()

# log-transform continuous, non-normally distributed traits
# "seed_mass_leda" "height_leda"    "leaf_size_leda" "sla_leda"      
# "nbr_seed_ramet"

for (i in c(1:4,12)){
  traits[,i] <- log(traits[,i])
}

par(mfrow=c(2,3))
for (i in c(1:4,12)){
  hist(log(traits[,i]), main = names(traits[i]))
}

traits.t <- traits
save(traits.t, file = paste(path.data, "traits.t.Rdata", sep = ""))

# impute missing data (Multivariate Imputations by Chained Equations (MICE))

## percentage of missing data
sum(is.na(traits.t==T))/(dim(traits.t)[1]*(dim(traits.t)[2]))*100
# only 4.418985 % of the data are missing

## transform "life form" and "leaf longevity" into factors (required for the "proportional odds model"-imputation method)
traits.t[,8] <- as.factor(traits.t[,8])
traits.t[,10] <- as.factor(traits.t[,10])

imp <- mice(as.data.frame(traits.t[,c(1:13)]), meth=c("pmm","pmm","pmm","pmm","logreg","logreg","logreg","polr","logreg","polr","pmm","pmm","pmm"), maxit = 100)

# Different imputation methods as we deal with mixed data:
#‘pmm’ Predictive mean matching (any)
#‘logreg’ Logistic regression (factor, 2 levels)
#‘polr’ Proportional odds model (ordered, >=2 levels)

# check for the robustness of the imputation procedure:
bwplot(imp)
traits.t.imp <- complete(imp)
save(traits.t.imp, file = paste(path.data, "traits.t.imp.Rdata", sep = ""))
write.csv(traits.t.imp, file = "traits.t.imp.csv")

# backtransform imputed data (for plotting raw trait data later on)
traits.imp <- traits.t.imp
for (i in c(1:4,12)){
  traits.imp[,i] <- exp(traits.imp[,i])
}

save(traits.imp, file = paste(path.data, "traits.imp.Rdata", sep = ""))
write.csv(traits.imp, file = "traits.imp.csv")

# create data.list, including the transformed and imputed trait data
datlist <- data.list(com, env, traits.t.imp)
save(datlist, file = paste(path.data, "datlist.Rdata", sep = ""))


############
#### calculate Rao for PD

# a) Full phylogeny including all 235 species 
# match species names in community data and phylogenetic tree
com.order <- datlist$com[match(phyl$tip.label, rownames(datlist$com)), ]
# Rao-partitioning for PD
Rao.PD <- Rao(sample=com.order, dfunc=NULL, dphyl=cophenetic(phyl), weight=F, Jost=T, structure=NULL)
mean(Rao.PD$TD$Richness_per_plot[1:9])
mean(Rao.PD$TD$Richness_per_plot[10:18])
mean(Rao.PD$TD$Alpha[1:9])
mean(Rao.PD$TD$Alpha[10:18])
mean(Rao.PD$PD$Alpha[1:9])
mean(Rao.PD$PD$Alpha[10:18])

summary(lm(Rao.PD$TD$Richness_per_plot~datlist$pc1*datlist$ekofarm))
summary(aov(Rao.PD$TD$Richness_per_plot~datlist$pc1*datlist$ekofarm))

summary(lm(Rao.PD$TD$Alpha~datlist$pc1*datlist$ekofarm))
summary(aov(Rao.PD$TD$Alpha~datlist$pc1*datlist$ekofarm))

summary(lm(Rao.PD$PD$Alpha~datlist$pc1*datlist$ekofarm))
summary(aov(Rao.PD$PD$Alpha~datlist$pc1*datlist$ekofarm))

# b) exclude gymnosperms

tree230 <- drop.tip(phyl, tip=c("Equisetum_pratense", "Equisetum_palustre", "Equisetum_arvense", "Pteridium_aquilinum", "Athyrium_filix-femina" ))
com.order <- datlist$com[match(tree230$tip.label, rownames(datlist$com)), ]
Rao.PD <- Rao(sample=com.order, dfunc=NULL, dphyl=cophenetic(tree230), weight=F, Jost=T, structure=NULL)
mean(Rao.PD$TD$Richness_per_plot[1:9])
mean(Rao.PD$TD$Richness_per_plot[10:18])
mean(Rao.PD$TD$Alpha[1:9])
mean(Rao.PD$TD$Alpha[10:18])
mean(Rao.PD$PD$Alpha[1:9])
mean(Rao.PD$PD$Alpha[10:18])

summary(lm(Rao.PD$TD$Richness_per_plot~datlist$pc1*datlist$ekofarm))
summary(aov(Rao.PD$TD$Richness_per_plot~datlist$pc1*datlist$ekofarm))
summary(lm(Rao.PD$TD$Alpha~datlist$pc1*datlist$ekofarm))
summary(aov(Rao.PD$TD$Alpha~datlist$pc1*datlist$ekofarm))
summary(lm(Rao.PD$PD$Alpha~datlist$pc1*datlist$ekofarm))
summary(aov(Rao.PD$PD$Alpha~datlist$pc1*datlist$ekofarm))

                                        
# c) exclude gymnosperms and non-woody species

tree210 <- drop.tip(tree230, tip=c("Acer_platanoides","Acer_pseudoplatanus", "Crataegus_laevigata","Euonymus_europaea","Fagus_sylvatica","Fraxinus_excelsior","Populus_tremula","Prunus_avium","Prunus_domestica","Prunus_spinosa","Quercus_robur","Ribes_uva-crispa","Rosa_canina","Rubus_caesius","Rubus_idaeus","Salix_repens","Sambucus_nigra","Sorbus_aucuparia","Tilia_cordata","Ulmus_glabra"))
com.order <- datlist$com[match(tree210$tip.label, rownames(datlist$com)), ]
Rao.PD <- Rao(sample=com.order, dfunc=NULL, dphyl=cophenetic(tree210), weight=F, Jost=T, structure=NULL)
mean(Rao.PD$TD$Richness_per_plot[1:9])
mean(Rao.PD$TD$Richness_per_plot[10:18])
mean(Rao.PD$TD$Alpha[1:9])
mean(Rao.PD$TD$Alpha[10:18])
mean(Rao.PD$PD$Alpha[1:9])
mean(Rao.PD$PD$Alpha[10:18])



############
#### calculate Rao for FD

trait.order <- datlist[match(tree210$tip.label, rownames(datlist$com)), ]
gow <- gowdis(trait.order[c(4:8,10:16)])

com.order <- datlist$com[match(tree210$tip.label, rownames(datlist$com)), ]

Rao.PD <- Rao(sample=com.order, dfunc=NULL, dphyl=gow, weight=F, Jost=T, structure=NULL)

mean(Rao.PD$TD$Richness_per_plot[1:9])
mean(Rao.PD$TD$Richness_per_plot[10:18])
mean(Rao.PD$TD$Alpha[1:9])
mean(Rao.PD$TD$Alpha[10:18])
mean(Rao.PD$PD$Alpha[1:9])
mean(Rao.PD$PD$Alpha[10:18])


# excluding stuff from data list
datlist2 <- datlist[-c(10:100),]

dat.dat <- as.data.frame(datlist)

# phylogenetic distances

phylodist <- cophenetic(phyl)
phylodist <- as.data.frame(phylodist)
colnames(phylodist) <- paste(colnames(phylodist), 'phylo.dist', sep = '.') 
dl <- datlist + variableGroup(as.data.frame(phylodist), dimids = 'D1')



dis <- (dl[17:251])

dis <- as.dist(dis)

#########
# ph

TreeSiteB <- read.csv("/home/oliver/Dokumente/PhD/PostPhD/Halle/BEF-China/AndreasSchuldt/tree_species_site_b.csv", head = FALSE)

##########################################

TreeSiteB
                          V1
1        Ailanthus altissima
2       Alniphyllum fortunei
3          Betula luminifera
4          Castanopsis eyrei
5       Castanopsis fargesii
6   Castanopsis sclerophylla
7              Celtis biondi
8        Cinnamomum camphora
9     Cyclobalanopsis glauca
10    Daphniphyllum oldhamii
11     Diospyros glaucifolia
12     Elaeocarpus chinensis
13 Elaeocarpus glabripetalus  Elaeocarpus_decipiens
14     Elaeocarpus japonicus
15          Idesia polycarpa
16        Lithocarpus glaber
17          Machilus grijsii
18      Machilus leptophylla
19       Machilus thunbergii
20    Manglietia yuyuanensis  Manglietia_fordiana
21         Meliosma flexuosa
22            Phoebe bournei
23    Quercus phillyraeoides
24            Schima superba

######################
TreeSiteB[,1] <- as.character(TreeSiteB[,1])
TreeSiteB[,1] <- gsub(" ", "_", TreeSiteB[,1])

rownames(TreeSiteB) <- TreeSiteB[,1]

###########################################

phy.andreas <- befdat$phy.gut.ultra.nongymnocult
# write.tree(phy.andreas, file = "phy.gutian.ultra.nongymno.tre")
  
phy.andreas$tip.label[phy.andreas$tip.label=="Elaeocarpus_decipiens"] <- "Elaeocarpus_glabripetalus"

phy.andreas$tip.label[phy.andreas$tip.label=="Manglietia_fordiana"] <- "Manglietia_yuyuanensis"

phy.andreas$tip.label[phy.andreas$tip.label=="Celtis_biondii"] <- "Celtis_biondi"

phy.site.B <- prune.sample(t(TreeSiteB), phy.andreas)

write.tree(phy.site.B, "PhySiteB.txt")

pdf("PhySiteB.pdf")
plot(phy.site.B, cex = .7)
dev.off()


#########################################



require(mail)
data(phylocom)
mpd(phylocom$sample, cophenetic(phylocom$phylo), abundance.weighted=TRUE)
sendmail("oliver.purschke@nateko.lu.se", "R notice", "Calculation finished.\nFetch your data!")


# error.bar function to draw plot without axis
library(psych)
error.bars <- function (x, stats = NULL, ylab = "Dependent Variable", xlab = "Independent Variable", 
    main = NULL, ylim = NULL, alpha = 0.05, sd = FALSE, labels = NULL, 
    pos = NULL, arrow.len = 0.05, arrow.col = "black", add = FALSE, 
    bars = FALSE, within = FALSE, ...) 
{
    if (is.null(stats)) {
        x.stats <- describe(x)
        if (within) {
            x.smc <- smc(x, covar = TRUE)
            x.stats$se <- sqrt((x.stats$sd^2 - x.smc)/x.stats$n)
        }
        if (is.null(dim(x))) {
            z <- 1
        }
        else {
            z <- dim(x)[2]
        }
        names <- colnames(x)
    }
    else {
        x.stats <- stats
        z <- dim(x.stats)[1]
        names <- rownames(stats)
    }
    min.x <- min(x.stats$mean, na.rm = TRUE)
    max.x <- max(x.stats$mean, na.rm = TRUE)
    max.se <- max(x.stats$se, na.rm = TRUE)
    {
        if (!sd) {
            if (is.null(stats)) {
                ci <- qt(1 - alpha/2, x.stats$n)
            }
            else {
                ci <- rep(1, z)
            }
        }
        else {
            ci <- sqrt(x.stats$n)
            max.se <- max(ci * x.stats$se, na.rm = TRUE)
        }
    }
    if (is.null(main)) {
        if (!sd) {
            main = paste((1 - alpha) * 100, "% confidence limits", 
                sep = "")
        }
        else {
            main = paste("Means and standard deviations")
        }
    }
    if (is.null(ylim)) {
        if (is.na(max.x) | is.na(max.se) | is.na(min.x) | is.infinite(max.x) | 
            is.infinite(min.x) | is.infinite(max.se)) {
            ylim = c(0, 1)
        }
        else {
            if (bars) {
                ylim = c(min(0, min.x - 2 * max.se), max.x + 
                  2 * max.se)
            }
            else {
                ylim = c(min.x - 2 * max.se, max.x + 2 * max.se)
            }
        }
    }
    if (bars) {
        mp = barplot(x.stats$mean, ylim = ylim, xlab = xlab, 
            ylab = ylab, main = main, ...)
        axis(1, mp[1:z], names)
        axis(2)
        box()
      }
    else {
        if (!add) {
            if (is.null(x.stats$values)) {
                plot(x.stats$mean, ylim = ylim, xlab = xlab, 
                  ylab = ylab, main = main, ...)
            }
            else {
                plot(x.stats$values, x.stats$mean, ylim = ylim, 
                  xlab = xlab, ylab = ylab, main = main, ...)
            }
          }
        else {
            points(x.stats$mean, ...)
        }
      }
    if (!is.null(labels)) {
        lab <- labels
    }
    else {
        lab <- paste("V", 1:z, sep = "")
      }
    if (length(pos) == 0) {
        locate <- rep(1, z)
    }
    else {
        locate <- pos
    }
    if (length(labels) == 0) 
        lab <- rep("", z)
    else lab <- labels
    s <- c(1:z)
    if (bars) {
        arrows(mp[s], x.stats$mean[s] - ci[s] * x.stats$se[s], 
            mp[s], x.stats$mean[s] + ci[s] * x.stats$se[s], length = arrow.len, 
            angle = 90, code = 3, col = par("fg"), lty = NULL, 
            lwd = par("lwd"), xpd = NULL)
    }
    else {
        if (is.null(x.stats$values)) {
            arrows(s[s], x.stats$mean[s] - ci[s] * x.stats$se[s], 
                s[s], x.stats$mean[s] + ci[s] * x.stats$se[s], 
                length = arrow.len, angle = 90, code = 3, col = arrow.col)
        }
        else {
            arrows(x.stats$values, x.stats$mean[s] - ci[s] * 
                x.stats$se[s], x.stats$values, x.stats$mean[s] + 
                ci[s] * x.stats$se[s], length = arrow.len, angle = 90, 
                code = 3, col = arrow.col)
        }
    }
}


# fuer marten: hardy delta st:

resamp.1a <- function (obj, abund.class.ratio = 4) 
{
    if (abund.class.ratio <= 1) 
        stop("Supplied abundance-class ratio did not appear sensible: choose a value greater than 1.")
    orig = obj
    abund <- rowSums(obj)
    n.spp <- length(abund)
    aa <- abund.class.ratio
    while (1) {
        classes <- aa^(0:ifelse(aa < 2, n.spp * (1/(aa - 1)), 
            n.spp))
        if (length(classes) >= n.spp) {
            classes <- unique(round(runif(1) * classes))
            break()
        }
    }
    class <- rep(NA, n.spp)  
    for (i in 1:length(classes)) {
        class[abund > classes[i]] <- i
    }   
    if (any(is.na(class))) 
        class[which(is.na(class))] = 1    
    if (min(table(class)) == 1) # OP
      class[which(class == max(unique(class)))] <- length(sort(unique(class)))-1 # OP
    new_name <- rep(NA, n.spp) 
    for (i in unique(class)) {
      new_name[class == i] <- sample(rownames(obj[class == 
            i, ]))
    }
    row.names(obj) <- new_name
    return(obj[order(match(row.names(obj), row.names(orig))), ])
  }


################################

library(spacodiR)

czech.tree <- read.tree("/home/oliver/Dokumente/PhD/PostPhD/IDiv/Lososova_Phylo/DaPhnE_01_czech_1.8.tre")

pdf("czech.tree.pdf", width = 42, height = 42)
plot(czech.tree, "f", cex = .2)
dev.off()


# generate data subset (100 species in 10 sites)

czech.hab <- read.csv("/home/oliver/Dokumente/PhD/PostPhD/IDiv/Lososova_Phylo/DAPHNE_Czech2_frequencies.csv", sep = "\t", head = T, row.names = 1)

czech.hab.cat <- read.csv("/home/oliver/Dokumente/PhD/PostPhD/IDiv/Lososova_Phylo/czech_hab_cat.csv", sep = "\t")

czech.angio <- czech.hab[czech.hab$angio=="angiosperm",]
czech.angio <- czech.angio[,4:91]

czech.herb <- czech.hab[czech.hab$herb=="herb",]
czech.herb <- czech.herb[,4:91]

czech.hab <- czech.hab[,4:91]
samp <- angio.hab[sample(rownames(angio.hab), 100), sample(colnames(angio.hab), 10)]
samp <- samp[rowSums(samp)!=0,] # exclude exclude species which are not represented
dim(samp)

# prune czech tree to angiosperms


mat <- match.phylo.comm(czech.tree, t(czech.hab))

pdf("czech.phy.angio.node.pdf", width = 15, height = 15)
plot(mat$phy, "f", cex = .2, show.node.label = T)
dev.off()

# arguments for the "Grand.distinct.null.fun" - function below:
nullmod <- "1a" # 1a - shuffles species with similar abundances (within distinct abundance classes) or "1s" for ordinary taxa.shuffle model
com <- t(mat$comm)
dis <- cophenetic(mat$phy)
value <- 5 # 5 - corresponds to Delta+ (distinctiveness based on presence absence data, Warwick Clarke-stuff), 2 - corresponds to Rao's Q

###########################################################################

# correct p-vals (from picante ses.mpd output)

all <- read.csv("Grand.mpd.1a.czech.abu.true.csv", sep = " ", dec = ",")
angio <- read.csv("Grand.mpd.1a.czech.abu.true.angio.csv", dec = ",")

x <- 0.623

all$physo.obs.p

pcor <- function(x){
    n <- 1:length(all$physo.obs.p)
    for (i in 1:length(all$physo.obs.p)){
        n[i] <- if (x[i] > .5) (1-x[i])*2 else (x[i]*2)
    }
    n
}


all$physo.obs.p <- pcor(all$physo.obs.p)

angio$physo.obs.p <- pcor(angio$physo.obs.p)

write.csv(all, file = "Grand.mpd.1a.czech.abu.true.correct.csv")
write.csv(angio, file = "Grand.mpd.1a.czech.abu.true.angio.correct.csv")



######


Grand.distinct.null.fun <- function(com, dis, runs, value, nullmod){
  
  resamp.1a <- function (obj = com, abund.class.ratio = 4) # corrected function from the "spacodiR"-package (original function had some bugs)
{
    if (abund.class.ratio <= 1) 
        stop("Supplied abundance-class ratio did not appear sensible: choose a value greater than 1.")
    orig = obj
    abund <- rowSums(obj)
    n.spp <- length(abund)
    aa <- abund.class.ratio
    while (1) {
        classes <- aa^(0:ifelse(aa < 2, n.spp * (1/(aa - 1)), 
            n.spp))
        if (length(classes) >= n.spp) {
            classes <- unique(round(runif(1) * classes))
            break()
        }
    }
    class <- rep(NA, n.spp)  
    for (i in 1:length(classes)) {
        class[abund > classes[i]] <- i
    }   
    if (any(is.na(class))) 
        class[which(is.na(class))] = 1    
    if (min(table(class)) == 1) # OP
      class[which(class == max(unique(class)))] <- length(sort(unique(class)))-1 # OP
    new_name <- rep(NA, n.spp) 
    for (i in unique(class)) {
      new_name[class == i] <- sample(rownames(obj[class == 
            i, ]))
    }
    row.names(obj) <- new_name
    return(obj[order(match(row.names(obj), row.names(orig))), ])
}

alpha.shuff <- function(com, dis, runs, value){ # !!! if null.model "1s" is used, delete ", abund.class.ratio = 4" - argument
  Res = list()
  for (r in 1:runs) {     
    Res <- c(Res, list(taxondive(t(eval(parse(text=paste("resamp.", nullmod, sep = "")))(com, abund.class.ratio = 4)), dis, match.force = TRUE)[[value]]))
  }
  return(Res)
}

PD.obs <- taxondive(t(com), dis, match.force = TRUE)[[value]]

ses.alpha <- function(obs, rand){
  rand <- t(as.data.frame(lapply(rand, as.vector)))
  physo.obs <- as.numeric(obs)
  physo.mean <- apply(rand, MARGIN = 2, FUN = mean, na.rm = TRUE)
  physo.sd <- apply(rand, MARGIN = 2, FUN = sd, na.rm = TRUE)
  physo.ses <- (physo.obs - physo.mean)/physo.sd
  physo.obs.rank <- apply(X = rbind(physo.obs, rand), MARGIN = 2, FUN = rank)[1, ]
  physo.obs.rank <- ifelse(is.na(physo.mean), NA, physo.obs.rank)
  data.frame(physo.obs, physo.mean, physo.sd, physo.obs.rank, physo.ses, physo.obs.p = physo.obs.rank/(dim(rand)[1] + 1))
}

shuff <- alpha.shuff(com, dis, runs, value)
PD.obs <- taxondive(t(com), dis, match.force = TRUE)[[value]]
ses.PD.alpha <- ses.alpha(PD.obs, shuff)
return(ses.PD.alpha)
}

### for MPD #############

Grand.mpd.null.fun.pa <- function(com, dis, runs, nullmod){
  resamp.1a <- function (obj = com, abund.class.ratio = 4) # corrected function from the "spacodiR"-package (original function had some bugs)
{
    if (abund.class.ratio <= 1) 
        stop("Supplied abundance-class ratio did not appear sensible: choose a value greater than 1.")
    orig = obj
    abund <- rowSums(obj)
    n.spp <- length(abund)
    aa <- abund.class.ratio
    while (1) {
        classes <- aa^(0:ifelse(aa < 2, n.spp * (1/(aa - 1)), 
            n.spp))
        if (length(classes) >= n.spp) {
            classes <- unique(round(runif(1) * classes))
            break()
        }
    }
    class <- rep(NA, n.spp)  
    for (i in 1:length(classes)) {
        class[abund > classes[i]] <- i
    }   
    if (any(is.na(class))) 
        class[which(is.na(class))] = 1    
    if (min(table(class)) == 1) # OP
      class[which(class == max(unique(class)))] <- length(sort(unique(class)))-1 # OP
    new_name <- rep(NA, n.spp) 
    for (i in unique(class)) {
      new_name[class == i] <- sample(rownames(obj[class == 
            i, ]))
    }
    row.names(obj) <- new_name
    return(obj[order(match(row.names(obj), row.names(orig))), ])
  }

alpha.shuff <- function(com, dis, runs, value){ # !!! if null.model "1s" is used, delete ", abund.class.ratio = 4" - argument
  Res = list()
  for (r in 1:runs) {     
    Res <- c(Res, list(mpd(t(eval(parse(text=paste("resamp.", nullmod, sep = "")))(com, abund.class.ratio = 4)), dis, abundance.weighted = FALSE)))
  }
  return(Res)
}

ses.alpha <- function(obs, rand){
  rand <- t(as.data.frame(lapply(rand, as.vector)))
  physo.obs <- as.numeric(obs)
  physo.mean <- apply(rand, MARGIN = 2, FUN = mean, na.rm = TRUE)
  physo.sd <- apply(rand, MARGIN = 2, FUN = sd, na.rm = TRUE)
  physo.ses <- (physo.obs - physo.mean)/physo.sd
  physo.obs.rank <- apply(X = rbind(physo.obs, rand), MARGIN = 2, FUN = rank)[1, ]
  physo.obs.rank <- ifelse(is.na(physo.mean), NA, physo.obs.rank)
  data.frame(physo.obs, physo.mean, physo.sd, physo.obs.rank, physo.ses, physo.obs.p = physo.obs.rank/(dim(rand)[1] + 1))
}

shuff <- alpha.shuff(com, dis, runs)
PD.obs <- mpd(t(com), dis, abundance.weighted = FALSE)
ses.PD.alpha <- ses.alpha(PD.obs, shuff)
return(ses.PD.alpha)
}

###################################

Grand.mpd.null.fun.1s <- function(com, dis, runs, nullmod){
  
  resamp.1a <- function (obj = com, abund.class.ratio = 4) # corrected function from the "spacodiR"-package (original function had some bugs)
{
    if (abund.class.ratio <= 1) 
        stop("Supplied abundance-class ratio did not appear sensible: choose a value greater than 1.")
    orig = obj
    abund <- rowSums(obj)
    n.spp <- length(abund)
    aa <- abund.class.ratio
    while (1) {
        classes <- aa^(0:ifelse(aa < 2, n.spp * (1/(aa - 1)), 
            n.spp))
        if (length(classes) >= n.spp) {
            classes <- unique(round(runif(1) * classes))
            break()
        }
    }
    class <- rep(NA, n.spp)  
    for (i in 1:length(classes)) {
        class[abund > classes[i]] <- i
    }   
    if (any(is.na(class))) 
        class[which(is.na(class))] = 1    
    if (min(table(class)) == 1) # OP
      class[which(class == max(unique(class)))] <- length(sort(unique(class)))-1 # OP
    new_name <- rep(NA, n.spp) 
    for (i in unique(class)) {
      new_name[class == i] <- sample(rownames(obj[class == 
            i, ]))
    }
    row.names(obj) <- new_name
    return(obj[order(match(row.names(obj), row.names(orig))), ])
  }

alpha.shuff <- function(com, dis, runs, value){ # !!! if null.model "1s" is used, delete ", abund.class.ratio = 4" - argument
  Res = list()
  for (r in 1:runs) {     
    Res <- c(Res, list(mpd(t(eval(parse(text=paste("resamp.", nullmod, sep = "")))(com)), dis)))
  }
  return(Res)
}

ses.alpha <- function(obs, rand){
  rand <- t(as.data.frame(lapply(rand, as.vector)))
  physo.obs <- as.numeric(obs)
  physo.mean <- apply(rand, MARGIN = 2, FUN = mean, na.rm = TRUE)
  physo.sd <- apply(rand, MARGIN = 2, FUN = sd, na.rm = TRUE)
  physo.ses <- (physo.obs - physo.mean)/physo.sd
  physo.obs.rank <- apply(X = rbind(physo.obs, rand), MARGIN = 2, FUN = rank)[1, ]
  physo.obs.rank <- ifelse(is.na(physo.mean), NA, physo.obs.rank)
  data.frame(physo.obs, physo.mean, physo.sd, physo.obs.rank, physo.ses, physo.obs.p = physo.obs.rank/(dim(rand)[1] + 1))
}

shuff <- alpha.shuff(com, dis, runs)
PD.obs <- mpd(t(com), dis)
ses.PD.alpha <- ses.alpha(PD.obs, shuff)
return(ses.PD.alpha)
}


######################################
to do: re-run: 
  
PD.obs <- taxondive(comm = (mat$comm), dis = cophenetic(mat$phy), match.force = TRUE)


# 1a
Grand.mpd.1a.czech.abu.false <- Grand.mpd.null.fun.abu.false(com = t(mat$comm), dis= cophenetic(mat$phy), runs = 999, nullmod = "1a")
rownames(Grand.mpd.1a.czech.abu.false) <- gsub("X", "", rownames(mat$comm))
write.table(Grand.mpd.1a.czech.abu.false, file = "Grand.mpd.1a.czech.abu.false.csv")

#############
# herb
Grand.mpd.1a.czech.abu.true <- Grand.mpd.null.fun.abu.true(com = t(mat$comm), dis= cophenetic(mat$phy), runs = 999, nullmod = "1a")
rownames(Grand.mpd.1a.czech.abu.true) <- gsub("X", "", rownames(mat$comm))
write.table(Grand.mpd.1a.czech.abu.true, file = "Grand.mpd.1a.czech.abu.true.herb.csv")
###############

pa <- decostand(mat$comm, method = "pa")
Grand.mpd.1a.czech.pa <- Grand.mpd.null.fun.pa(com = t(pa), dis= cophenetic(mat$phy), runs = 999, nullmod = "1a")
rownames(Grand.mpd.1a.czech.pa) <- gsub("X", "", rownames(mat$comm))
write.table(Grand.mpd.1a.czech.pa, file = "Grand.mpd.1a.czech.pa.csv")

#######################
# 1s
Grand.mpd.1s.czech <- Grand.mpd.null.fun.1s(com = t(mat2$comm), dis= cophenetic(mat2$phy), runs = 499, nullmod = "1s")
rownames(Grand.mpd.1s.czech) <- gsub("X", "", rownames(mat2$comm))
write.table(Grand.mpd.1s.czech, file = "Grand.mpd.1s.czech.csv")

Grand.mpd.1s.daphne <- Grand.mpd.null.fun.1s(com = t(mat3$comm), dis= cophenetic(mat3$phy), runs = 499, nullmod = "1s")
rownames(Grand.mpd.1s.daphne) <- gsub("X", "", rownames(mat2$comm))
write.table(Grand.mpd.1s.daphne, file = "Grand.mpd.1s.daphne.csv")

Grand.mpd.1s.czech.angio.all <- Grand.mpd.null.fun.1s(com = t(mat$comm), dis= cophenetic(mat$phy), runs = 499, nullmod = "1s")
rownames(Grand.mpd.1s.czech.angio.all) <- gsub("X", "", rownames(mat2$comm))
write.table(Grand.mpd.1s.czech.angio.all, file = "Grand.mpd.1s.czech.angio.all.csv")


pdf("hist.MPD_Abu_Angio_Herb.pdf", width = 12, height = 7)
par(mfrow = c(1,2))

hist(Grand.mpd.1a.czech.abu.true.angio$physo.ses, xlab = "SES", main = "MPD_Abu_Angio")
abline(v = 0, col = "blue", lwd = 2)
abline(v = -2, col = "red", lwd = 2)
abline(v = 2, col = "red", lwd = 2)

hist(Grand.mpd.1a.czech.abu.true.herb$physo.ses, xlab = "SES", main = "MPD_Abu_Herb")
abline(v = 0, col = "blue", lwd = 2)
abline(v = -2, col = "red", lwd = 2)
abline(v = 2, col = "red", lwd = 2)



hist(Grand.mpd.1a.czech.abu.true$physo.ses, xlab = "SES", main = "MPD_Abundance")
abline(v = 0, col = "blue", lwd = 2)
abline(v = -2, col = "red", lwd = 2)
abline(v = 2, col = "red", lwd = 2)

hist(Grand.mpd.1a.czech.pa$physo.ses, xlab = "SES", main = "daphne.1a")
abline(v = 0, col = "blue", lwd = 2)
abline(v = -2, col = "red", lwd = 2)
abline(v = 2, col = "red", lwd = 2)

hist(Grand.mpd.1s.czech.angio.all$physo.ses, xlab = "SES", main = "czech.angio.all.1s")
abline(v = 0, col = "blue", lwd = 2)
abline(v = -2, col = "red", lwd = 2)
abline(v = 2, col = "red", lwd = 2)

hist(Grand.mpd.1s.czech$physo.ses, xlab = "SES", main = "czech.1s")
abline(v = 0, col = "blue", lwd = 2)
abline(v = -2, col = "red", lwd = 2)
abline(v = 2, col = "red", lwd = 2)

hist(Grand.mpd.1s.daphne$physo.ses, xlab = "SES", main = "daphne.1s")
abline(v = 0, col = "blue", lwd = 2)
abline(v = -2, col = "red", lwd = 2)
abline(v = 2, col = "red", lwd = 2)
dev.off()


pdf("dens.abu.pa.pdf", width = 10, height = 7)

par(mfrow = c(1,3))

plot(density(Grand.mpd.1a.czech.pa$physo.ses), xlab = "SES", main = "czech.angio.all.1a")
abline(v = 0, col = "blue", lwd = 2)
abline(v = -2, col = "red", lwd = 2)
abline(v = 2, col = "red", lwd = 2)

plot(density(Grand.mpd.1a.czech.abu.false$physo.ses), xlab = "SES", main = "czech.1a")
abline(v = 0, col = "blue", lwd = 2)
abline(v = -2, col = "red", lwd = 2)
abline(v = 2, col = "red", lwd = 2)

plot(density(Grand.mpd.1a.czech.abu.true$physo.ses), xlab = "SES", main = "daphne.1a")
abline(v = 0, col = "blue", lwd = 2)
abline(v = -2, col = "red", lwd = 2)
abline(v = 2, col = "red", lwd = 2)


plot(density(Grand.mpd.1s.czech.angio.all$physo.ses), xlab = "SES", main = "czech.angio.all.1s")
abline(v = 0, col = "blue", lwd = 2)
abline(v = -2, col = "red", lwd = 2)
abline(v = 2, col = "red", lwd = 2)

plot(density(Grand.mpd.1s.czech$physo.ses), xlab = "SES", main = "czech.1s")
abline(v = 0, col = "blue", lwd = 2)
abline(v = -2, col = "red", lwd = 2)
abline(v = 2, col = "red", lwd = 2)

plot(density(Grand.mpd.1s.daphne$physo.ses), xlab = "SES", main = "daphne.1s")
abline(v = 0, col = "blue", lwd = 2)
abline(v = -2, col = "red", lwd = 2)
abline(v = 2, col = "red", lwd = 2)

dev.off()
#####################


# run the function
# !!! attention! can run a very long time on 
Grand.5.1a.czech <- Grand.distinct.null.fun(com = t(mat2$comm), dis= cophenetic(mat2$phy), runs = 1, value = 5, nullmod = "1a")

Grand.5.1a.daphne <- Grand.distinct.null.fun(com = t(mat3$comm), dis= cophenetic(mat3$phy), runs = 1, value = 5, nullmod = "1a")

mat <- match.phylo.comm(czech.tree, t(angio.hab))

Grand.5.1a.czech.angio.all <- Grand.distinct.null.fun(com = t(mat$comm), dis= cophenetic(mat$phy), runs = 1, value = 5, nullmod = "1a")

plot(Grand.5.1a.czech$physo.obs,Grand.5.1a.daphne$physo.obs)
plot(Grand.5.1a.daphne$physo.obs,Grand.5.1a.czech.angio.all$physo.obs)

mpd(mat$comm, cophenetic(mat$phy), abundance.weighted = FALSE)

# test whether MPD runs faster

# rewrite for grand.function for null model 1s
Grand.5.1a <- Grand.distinct.null.fun(com = mat3$comm, dis= cophenetic(mat3$phy), runs = 3, value = 2, nullmod = "1a")


nullmod <- "1a" # 1a - shuffles species with similar abundances (within distinct abundance classes) or "1s" for ordinary taxa.shuffle model
com <- t(mat$comm)
dis <- cophenetic(mat$phy)
value <- 5 

PD.obs <- taxondive(t(com), dis, match.force = TRUE)[[value]]

mpd(t(com), dis, abundance.weighted = TRUE)

##################################################################
### Czech-data 
## Phylocom-analyses (node-as-factor (naf) and nodesig analysis)

czech.tree <- read.tree("/home/oliver/Dokumente/PhD/PostPhD/Projects/Lososova_HabEurope_Phylo/DaPhnE_01_czech_1.8.tre")
czech.hab <- read.csv("/home/oliver/Dokumente/PhD/PostPhD/Projects/Lososova_HabEurope_Phylo/DAPHNE_Czech2_frequencies.csv", sep = "\t", head = T, row.names = 1)

mat <- match.phylo.comm(czech.tree, t(czech.hab))


czech.hab.cat <- read.csv("/home/oliver/Dokumente/PhD/PostPhD/Projects/Lososova_HabEurope_Phylo/czech_hab_cat.csv", sep = "\t")

##  naf and nodesig for angiosperms only:
czech.angio <- czech.hab[czech.hab$angio=="angiosperm",]
czech.angio <- czech.angio[,4:91]

mat <- match.phylo.comm(czech.tree, t(czech.angio))


# export data to phylocom



library(picante)
write.tree(mat$phy, file = "phyczechangio")

comm <- mat$comm[-c(1:3),]

comm.num <- apply(comm, 2, as.numeric)

rownames(comm.num) <- rownames(comm)

writesample(as.data.frame(comm.num), filename = "commczechall")

# write sample file for angio.only
writesample(mat$comm, filename = "commczechangio")


naf.angio <- read.table("/home/oliver/Dokumente/PhD/PostPhD/Halle/BEF-China/Code/NafResultsCzechAngio.txt", sep = "\t", head = TRUE)
naf.all <- read.table("/home/oliver/Dokumente/PhD/PostPhD/Halle/BEF-China/Code/NafResultsCzechAll.txt", sep = "\t", head = TRUE)

# function that imports node-as-factor and generates a matrix that sites x nodes, containing whether a node is represented in a particular site, weighted by species abundance

# arguments:
# x = node-as-factor data.frame generated by phylocom (first column containts species names, followed by t columns containing species trait values for each trait, followed by s columns containing species abundances for each site)
# t = number of traits
# s = number of sites

x <- naf
t <- 4
s <- 88

nodesite <- function (x, t, s){
    mat <- matrix(NA, nrow=s, ncol=dim(x)[2]-(1+t+s))
    rownames(mat) <- colnames(x)[(2+t):(1+t+s)]
    colnames(mat) <- colnames(x)[(2+t+s):(dim(x)[2])]
    for (i in (2+t+s):(dim(x)[2])){
        for (j in (2+t):(1+t+s)){  
            mat[j-(1+t),i-(1+t+s)] <- sum(x[,j][which(x[i]!=".")]) # "." may be exchanged by "0"
        }
    }
    mat
}


nodemat.angio <- nodesite(naf.angio, 4, 88)
nodemat.all <- nodesite(naf.all, 4, 88)

pdf("OrdiAngioEllipse.pdf", width = 12, height = 10)
#, xlim = c(0.8,1), ylim = c(-1.1,1.2)
ord <- metaMDS((nodemat.angio), distance = "bray", k = 2, autotransform = T)
plot(ord, type = "n", xlim = c(0.8,1), ylim = c(-1.1,1.2))
points(ord, display = "species", col = "grey", pch=19, cex = .5)
points(ord, display = "sites", col = as.numeric(habgroup), pch=16)
ordispider(ord, habgroup, col="black")
ordiellipse(ord, t(czech.hab.cat[2,]), col="black", label = TRUE)
dev.off()
pdf("OrdiAllEllipse.pdf", width = 12, height = 10)
#, xlim = c(0.8,1), ylim = c(-1.1,1.2)
ord <- metaMDS((nodemat.all), distance = "bray", k = 2, autotransform = T)
plot(ord, type = "n", xlim = c(0.8,1), ylim = c(-1.1,1.2))
points(ord, display = "species", col = "grey", pch=19, cex = .5)
points(ord, display = "sites", col = as.numeric(habgroup), pch=16)
ordispider(ord, habgroup, col="black")
ordiellipse(ord, t(czech.hab.cat[2,]), col="black", label = TRUE)
dev.off()

# to do: try phylogeny plot but based on beta diversity:


plot(ord, xlim = c(0,1), ylim = c(-1.1,1.1))
habgroup <- as.factor(t(czech.hab.cat[2,]))
ordispider


plot(mat$phy, "f", cex = .2, node.label = T)

# species nmds
pdf("OrdiSpeciesAllEllipse.pdf", width = 12, height = 10)
ord <- metaMDS(t(czech.hab[,-c(1:3)]), distance = "bray", k = 2, autotransform = TRUE)
plot(ord, type = "n", xlim = c(-1,2), ylim = c(-1.7,1.7))
points(ord, display = "species", col = "grey", pch=19, cex = .5)
points(ord, display = "sites", col = as.numeric(habgroup), pch=16)
ordispider(ord, habgroup, col="black")
ordiellipse(ord, habgroup, col="black", label = TRUE)
dev.off()


czech.hab.t <- t(czech.hab[,-c(1:3)])

# for angio-only
czech.hab.t <- t(czech.angio)
###

czech.bind <- cbind(habgroup,czech.hab.t)


czech.hab.t <- aggregate(czech.bind, list(habitat = habgroup), sum)

rownames(czech.hab.t) <- czech.hab.t[,1]
czech.hab.t <- czech.hab.t[,-c(1:2)]

writesample(czech.hab.t, filename = "commczechgroupangio")

# nodesig-analysis:
# import results from the nodesig-test

nodesig <- read.table("/home/oliver/Dokumente/PhD/PostPhD/Halle/BEF-China/Code/nodesigGroupResultsAngio", sep = "\t", head = TRUE, row.names = NULL)

colnames(nodesig) <- c("plot", "node", "node_name", "ntaxa", "median", "rank", "sig")

mat <- matrix(NA, ncol = 2, nrow = 13)
dimnames()



for (i in 1:13){
tab <- nodesig$node_name[which(nodesig$plot==i & nodesig$rank>=995)] # more
write.csv(tab, file = paste(paste("Sigmore_Angio", rownames(czech.hab.t)[i], sep = "_"), "csv", sep = "."))
}

for (i in 1:13){
tab <- nodesig$node_name[which(nodesig$plot==i & nodesig$sig>=995)] # more
write.csv(tab, file = paste(paste("Sigless_Angio", rownames(czech.hab.t)[i], sep = "_"), "csv", sep = "."))
}

nodesig$node_name[which(nodesig$plot==1 & nodesig$sig>=975)] # less




### shell script to run aot in phylocom:
# oliver@thinkpad-oliver:~/phylocom-4.2cd$ ./src/phylocom aotf > results.txt


##############
##############

# to do:
# sensitivity analysis to test whether daphne tree gives similar (stronger) signals than the czech tree
# 1) match the two trees, czech and daphne based on all shared species (two steps: 1. prune both trees using zdenka's angiosperm species list, 2. prune angiosperm czech tree using the tip labels from the reduced daphne tree)
# 2) carry out full null model analysis on the two matched trees and all 
# 3) + an additional analysis using the full czech tree

################################

mat <- match.phylo.comm(phy=befdat$phy.143.ultra, comm=t(befdat$com.order))
com <- t(mat$comm)
phy <- mat$phy
dis <- cophenetic(phy)

distinct <- taxondive(t(decostand(com, "pa")), cophenetic(befdat$phy.143.ultra))

taxondive(t(decostand(com, "pa")), cophenetic(befdat$phy.143.ultra), abundance.weighted = FALSE)

mpd(t(decostand(com, "pa")), dis, abundance.weighted = FALSE)

####################################################
# data David Eichenberg:
# all 90 species
# run MCMC analysis for david:
# http://www.mpcm-evolution.org/practice/online-practical-material-chapter-11
# http://www.mpcm-evolution.org/practice/online-practical-material-chapter-7/chapter-7-5-bivariate-opm
##################################################

# TO do david revision

# 1)
# easy stuff 1) run PIC analysis with measurement error
# + meta analysis
# + ANCOVA

# generate phylodistance matrix for the 51 species:
library(ape)
phy51 <- read.tree("davidphy51.tre")

write.tree(phy51, file = "phy51.tre")
plot(davidphy51)

phy51dist <- cophenetic(phy51)
save(phy51dist, file = "phy51dist.Rdata")


# check species names using species taxonstand
# tnrs:
# clean names in the phylogeny
library(Taxonstand)

daviddat$mat90$phy$tip.label

mynames <- daviddat$mat51mean$phy$tip.label
mynames <- gsub("_"," ", mynames)
phy51.tree.tnrs <- tnrs(query = mynames, source = "iPlant_TNRS")#[ , -c(5:7)]

write.csv(phy51.tree.tnrs, "phy51.tree.tnrs.csv")


phy90.plantlist <- make.clean.taxon.lookup(mynames)
phy90.plantlist

# match 51 species to phylogeny
library(picante)
names(daviddat)
mat51 <- match.phylo.comm(phy=daviddat$mat90$phy, comm=t(daviddat$mat51mean))

# up-to-date family information from TPL
r1 <- TPL(mynames, corr=TRUE)[,c(1,2,8)]
write.csv(r1, "family.TPL.csv")

# read in david's intra-spec data
# means at the indiviual level (186)
traits.spec <- read.csv("/home/oliver/Dokumente/PhD/PostPhD/Projects/BEF_China/David_Eichenberg_TradeOff/David_october/Data_species_specific_corr.csv")
head(traits.spec)

names(traits.spec)

traits.spec$Species <-  gsub(" ","_", traits.spec$Species)

# check whether species names match with tip.labels
unique(traits.spec$Species) %in% daviddat$mat51mean$phy$tip.label

traits.spec[,3] <- as.factor(traits.spec[,3])

test <- dlply(.data=traits.spec[,c(3,10)], .variables="Species")
str(test)
seq_along(test)
Y <- lapply(seq_along(test), function(x) as.data.frame(test[[x]])[, 2]) 
names(Y) <- names(test)
list2env(Y, envir = .GlobalEnv)

lt.spec <- Y


# all samples
traits.ind <- read.csv("/home/oliver/Dokumente/PhD/PostPhD/Projects/BEF_China/David_Eichenberg_TradeOff/David_october/Data_Individuals.csv", sep = ";")
head(traits.ind)
str(traits.ind)

traits.ind$Species <-  gsub(" ","_", traits.ind$Species)
unique(traits.ind$Species) %in% daviddat$mat51mean$phy$tip.label

names(traits.ind)

traits.ind[,3] <- as.factor(traits.ind[,3])

test <- dlply(.data=traits.ind[,c(3,17)], .variables="Species")
str(test)
seq_along(test)
Y <- lapply(seq_along(test), function(x) as.data.frame(test[[x]])[, 2]) 
names(Y) <- names(test)
list2env(Y, envir = .GlobalEnv)

lt.ind <- Y

# create PICs for spec.
pic.phen.spec <- pic.ortho(phen.spec, daviddat$mat51mean$phy, intra = TRUE)
pic.tan.spec <- pic.ortho(tan.spec, daviddat$mat51mean$phy, intra = TRUE)
pic.lt.spec <- pic.ortho(lt.spec, daviddat$mat51mean$phy, intra = TRUE)

# create PICs for ind.
pic.phen.ind <- pic.ortho(phen.ind, daviddat$mat51mean$phy, intra = TRUE)
pic.tan.ind <- pic.ortho(tan.ind, daviddat$mat51mean$phy, intra = TRUE)
pic.lt.ind <- pic.ortho(lt.ind, daviddat$mat51mean$phy, intra = TRUE)

ortho.pics <- cbind(pic.phen.spec, pic.tan.spec, pic.lt.spec, pic.phen.ind, pic.tan.ind, pic.lt.ind)

daviddat$ortho.pics <- ortho.pics

save(daviddat, file = "daviddat.Rdata")

summary(lm(daviddat$ortho.pics[,6] ~ daviddat$ortho.pics[,5] - 1))

# intra = F
pic.phen.spec <- pic.ortho(phen.spec, daviddat$mat51mean$phy, intra = F)
pic.tan.spec <- pic.ortho(tan.spec, daviddat$mat51mean$phy, intra = F)
pic.lt.spec <- pic.ortho(lt.spec, daviddat$mat51mean$phy, intra = F)

summary(lm(pic.lt.spec ~ pic.tan.spec - 1))

# 2)
# advanced version
# doing everything in MCMCglmm

distPlot(phy, trait[,3:4], dist.method="manhattan",scheme="color",circles="small",comparison="tree-char")

trait <- as.data.frame(t(daviddat$mat51mean$comm))
phy <- daviddat$mat51mean$phy



##################################################

load("/home/oliver/Dokumente/PhD/PostPhD/Projects/BEF_China/David_Eichenberg_TradeOff/daviddat.Rdata")
speclist <- read.csv("/home/oliver/Dokumente/PhD/PostPhD/Projects/BEF_China/David_Eichenberg_TradeOff/specieslist.csv")

speclist$Species <- gsub(" ", "_", speclist$Species)


phydavid <- befdat$phy.full.ultra

speclist$Species[which(speclist$Species %in% phydavid$tip.label == FALSE)]

phydavid$tip.label[phydavid$tip.label=="Quercus_myrsinifolia"] <- "Cyclobalanopsis_myrsinifolia"

rownames(speclist) <- speclist$Species

prunephy <- prune.sample(t(speclist), phydavid)


phydist20 <- as.dist(cophenetic(prunephy))

save(phydist20, file = "phydist20.Rdata")



plot(as.dist(cophenetic(phylocom$phylo)), dist(phylocom$traits))

write.tree(prunephy, "prunephy.tre")

plot(compute.brlen(prunephy, 1))
plot(prunephy)


###############


davidtraitsall <- read.csv("/home/oliver/Dokumente/PhD/PostPhD/Halle/BEF-China/DavidEichenberg/davidtraitsall.csv", dec = ",")

# 51 species only
davidtraits3 <- read.csv("/home/oliver/Dokumente/PhD/PostPhD/Projects/BEF_China/David_Eichenberg_TradeOff/davidtraits3.csv", dec = ",", sep = ";")


# convert traits into numeric variables
for (i in c(15:20)){
davidtraits3[, i] <- as.numeric(levels(davidtraits3[ ,i]))[davidtraits3[ ,i]]
}

# extract trait variables
davidtraits3 <- davidtraits3[,c(3,13:20)]

davidtraits3[,2] <- as.numeric(davidtraits3[,2])
davidtraits3[,3] <- as.numeric(davidtraits3[,3])


david3.mean <- aggregate(davidtraits3[,2:9], list(names = davidtraits3$Species), mean)
rownames(david3.mean) <- david3.mean[,1]

rownames(david3.mean) <- gsub(" ", "_", rownames(david3.mean))
david3.mean[,1] <- rownames(david3.mean)
david3.mean <- david3.mean[,-1]


rownames(david3.mean)[which(rownames(david3.mean) %in% befdat$phy.full.ultra$tip.label == FALSE)]

# checking for taxonomic inconsistencies and/or missing species
rownames(david3.mean)[which(rownames(david3.mean) %in% befdat$phy.full.ultra$tip.label == FALSE)]
#[1] "Cyclobalanopsis_myrsinaefolia" "Distylium_buxifolium"         
#[3] "Elaeocarpus_glabripetalus"     "Manglietia_yuyuanensis"       
#[5] "Photinia_hirsuta"              "Quercus_phillyreoides"        
#[7] "Sapium_sebiferum"              "Vaccinium_mandarinorum" 

phydavid <- befdat$phy.full.ultra

write.tree(phydavid, file = "phydavid.tre")

# renaming the following species:

phydavid$tip.label[phydavid$tip.label=="Vacciunium_mandarimorum"] <- "Vaccinium_mandarinorum"
phydavid$tip.label[phydavid$tip.label=="Quercus_phillyraeoides"] <- "Quercus_phillyreoides"
phydavid$tip.label[phydavid$tip.label=="Pourthiaea_hirsuta"] <- "Photinia_hirsuta"

phydavid$tip.label[phydavid$tip.label=="Manglietia_fordiana"] <- "Manglietia_yuyuanensis"
# phydavid$tip.label[phydavid$tip.label=="Distylium_myricoides"] <- "Distylium_buxifolium"

phydavid$tip.label[phydavid$tip.label=="Quercus_myrsinifolia"] <- "Cyclobalanopsis_myrsinaefolia"
phydavid$tip.label[phydavid$tip.label=="Sapium_sebifera"] <- "Sapium_sebiferum"


# the following species were added manually to the tree

# "Distylium_myricoides" as sister to "Distylium_buxifolium"
# "Elaeocarpus_glabripetalus" as sister to "Elaeocarpus_decipiens" and "Elaeocarpus_japonicus"

phydavid <- read.tree("/home/oliver/Dokumente/PhD/PostPhD/Halle/BEF-China/DavidEichenberg/phydavid.tre")

rownames(davidall.mean)[which(rownames(davidall.mean) %in% phydavid$tip.label == FALSE)]

# full (90 species) trait and phylo dataset
mat90 <- match.phylo.comm(phy=phydavid, comm=t(davidall.mean))

# without pinus massoniana
phy.ang <- drop.tip(mat90$phy, "Pinus_massoniana")
mat89 <- match.phylo.comm(phy=phy.ang, comm=t(davidall.mean))

# 51 species with at least 3 replicates
mat51mean <- match.phylo.comm(phy=phydavid, comm=t(david3.mean))
mat51sd <- match.phylo.comm(phy=phydavid, comm=t(david3.sd))

daviddat <- list("mat90"= mat90, "mat89"=mat89, "mat51mean"=mat51mean,"mat51sd"=mat51sd)
save(daviddat, file = "/home/oliver/Dokumente/PhD/PostPhD/Halle/BEF-China/DavidEichenberg/daviddat.Rdata")


load("/home/oliver/Dokumente/PhD/PostPhD/Projects/BEF_China/David_Eichenberg_TradeOff/daviddat.Rdata")

###

# Phylogeny and traits plot

phylpatho <- phylo4d(daviddat$mat51sd$phy, t(daviddat$mat51sd$comm)[,-c(1:2)])

postscript("PhyloDavid51sd.eps", width = 16, height = 24, paper = "special", onefile = FALSE, horizontal = FALSE, pointsize=14)
#pdf("PathoPhylofull.pdf", width = 16, height = 24)
phytab <- table.phylo4d(phylpatho, treetype="phylogram", show.node.label=F, box=F, ratio.tree=1/2, font=3, cex.label=1.3, cex.symbol=1.7, cex.legend = 1.1, scale = T, center = T, grid = T, var.label = colnames(t(daviddat$mat51sd$comm)[,-c(1:2)]))
dev.off()


# phylogenetic signal test:
daviddat$mat51mean$phy$edge.length <- daviddat$mat51mean$phy$edge.length+.01
multK <- MultiK(daviddat$mat51mean$phy, t(daviddat$mat51mean$comm))

######
> multK <- MultiK(daviddat$mat90$phy, t(daviddat$mat90$comm))
> multK
                   K     P
Lifeform       0.897 0.001
evergreen      0.429 0.001
Phenole        0.125 0.142
Tannin         0.146 0.121
LNC            0.019 0.493
C.N            0.008 0.536
LCC            0.208 0.036
Leaf.toughness 0.145 0.087

##########

> multK <- MultiK(daviddat$mat89$phy, t(daviddat$mat89$comm))
> multK
                   K     P
Lifeform       1.611 0.001
evergreen      0.771 0.002
Phenole        0.228 0.117
Tannin         0.271 0.110
LNC            0.030 0.504
C.N            0.012 0.535
LCC            0.413 0.015
Leaf.toughness 0.130 0.207

##########

> multK <- MultiK(daviddat$mat51mean$phy, t(daviddat$mat51mean$comm))
> multK
              K     P
Lifeform  1.421 0.001
evergreen 0.652 0.032
Phen      0.850 0.001
Tan       0.774 0.003
LNC       0.965 0.001
CNR       0.950 0.001
LCC       1.170 0.001
LT        0.664 0.027

### blombergs k test with intraspecific trait variability:

phylosig(daviddat$mat51mean$phy, t(daviddat$mat51mean$comm)[,3], method="K", test=TRUE, nsim=1000, se=NULL, start=NULL, control=list())
phylosig(daviddat$mat51mean$phy, t(daviddat$mat51mean$comm)[,3], method="K", test=TRUE, nsim=1000, se=t(daviddat$mat51sd$comm)[,3], start=NULL, control=list())

phylosig(daviddat$mat51mean$phy, t(daviddat$mat51mean$comm)[,4], method="K", test=TRUE, nsim=1000, se=NULL, start=NULL, control=list())
phylosig(daviddat$mat51mean$phy, t(daviddat$mat51mean$comm)[,4], method="K", test=TRUE, nsim=1000, se=t(daviddat$mat51sd$comm)[,4], start=NULL, control=list())

phylosig(daviddat$mat51mean$phy, t(daviddat$mat51mean$comm)[,8], method="K", test=TRUE, nsim=1000, se=NULL, start=NULL, control=list())
phylosig(daviddat$mat51mean$phy, t(daviddat$mat51mean$comm)[,8], method="K", test=TRUE, nsim=1000, se=t(daviddat$mat51sd$comm)[,8], start=NULL, control=list())

# lambda with measurement error:
phylosig(daviddat$mat51mean$phy, t(daviddat$mat51mean$comm)[,3], method="lambda", test=TRUE, nsim=1000, se=NULL, start=NULL, control=list())
phylosig(daviddat$mat51mean$phy, t(daviddat$mat51mean$comm)[,3], method="lambda", test=TRUE, nsim=1000, se=t(daviddat$mat51sd$comm)[,3], start=NULL, control=list())

phylosig(daviddat$mat51mean$phy, t(daviddat$mat51mean$comm)[,4], method="lambda", test=TRUE, nsim=1000, se=NULL, start=NULL, control=list())
phylosig(daviddat$mat51mean$phy, t(daviddat$mat51mean$comm)[,4], method="lambda", test=TRUE, nsim=1000, se=t(daviddat$mat51sd$comm)[,4], start=NULL, control=list())

phylosig(daviddat$mat51mean$phy, t(daviddat$mat51mean$comm)[,8], method="lambda", test=TRUE, nsim=1000, se=NULL, start=NULL, control=list())
phylosig(daviddat$mat51mean$phy, t(daviddat$mat51mean$comm)[,8], method="lambda", test=TRUE, nsim=1000, se=t(daviddat$mat51sd$comm)[,8], start=NULL, control=list())


summary(lm(LT~Tan, data = dat2))
summary(lm(LT~Phen, data = dat2))

summary(lm(crunchTab$LT~crunchTab$Tan))
summary(lm(crunchTab$LT~crunchTab$Phen))


CorTestPlot(t(daviddat$mat51mean$comm))


dat <- as.data.frame(t(daviddat$mat51mean$comm))

dat2 <- cbind(as.character(rownames(dat)), dat)

colnames(dat2)[1] <- "Species"

dat2$Species <- as.character(dat2$Species)

daviddat$mat51mean$phy$edge.length <- daviddat$mat51mean$phy$edge.length+.01

dat3 <- comparative.data(daviddat$mat51mean$phy, dat2, Species)

crunchMod <- crunch(LT ~ Phen+Tan+LNC, data=dat3, Species)
     summary(crunchMod)
     # plot the contrasts
     crunchTab <- caic.table(crunchMod)


pdf("PICvsNon51.pdf", width = 20, height = 12)
par(mfrow=c(1,2))
plot(LT ~ Tan, crunchTab, main = "PICs")
#cor.test(crunchTab$Tan, crunchTab$LT)
plot(dat2$LT, dat2$Tan, main = "Non_corrected")
#cor.test(dat2$Tan, dat2$LT)
#cor.test(dat2$Leaf.toughness, dat2$Phenole)
dev.off()

# pgls

pglsMod <- crunch(Phen ~ LT, data=dat3)
print(pglsMod)

# sma
com.test <- sma(LT~Tan+Lifeform, log="xy", data = dat2)
plot(com.test)


# ives -model

# with measurement error
Phen <- as.vector(scale(davidtraits3$Phen))
names(Phen) <- gsub(" ", "_",as.character(davidtraits3$Species))

Tan <- as.vector(scale(davidtraits3$Tan))
names(Tan) <- gsub(" ", "_",as.character(davidtraits3$Species))

LT <- as.vector(scale(davidtraits3$LT))
names(LT) <- gsub(" ", "_",as.character(davidtraits3$Species))

pgls.Ives(daviddat$mat51mean$phy, X=LT, y=Phen, Vx=NULL, Vy=NULL, Cxy=NULL, lower=c(1e-8,1e-8))

# without measurement error

Phen <- t(daviddat$mat51mean$comm)[,3]
Tan <- t(daviddat$mat51mean$comm)[,4]
LT <- t(daviddat$mat51mean$comm)[,8]

pgls.Ives(daviddat$mat51mean$phy, X=LT, y=Phen, Vx=randx+3, Vy=randy+3, Cxy=NULL, lower=c(1e-8,1e-8))

###############

phyl.pairedttest(daviddat$mat51mean$phy, x1=Phen, x2=Tan)


randx <- rnorm(51)
randy <- rnorm(51)
names(randx) <- daviddat$mat51mean$phy$tip.label
names(randy) <- daviddat$mat51mean$phy$tip.label
phyl.pairedttest(daviddat$mat51mean$phy, x1=scale(randx), x2=scale(randy))



Phen <- t(daviddat$mat51mean$comm)[,3]
Tan <- t(daviddat$mat51mean$comm)[,4]
LT <- t(daviddat$mat51mean$comm)[,8]

phyl.pairedttest(daviddat$mat51mean$phy, x1=scale(Phen), x2=scale(Tan))
                                                             

t.test(scale(Phen), scale(Tan))

load("daviddat.Rdata")

## co-phylo plot:

#pdf("TanToughCorEvo.pdf", width = 20, height = 12)
postscript("TanToughCorEvo2.eps", width = 22, height = 13, paper = "special", onefile = FALSE, horizontal = FALSE, pointsize=13)
 layout(matrix(1:3,1,3),widths=c(0.44,0.12,0.44))
 par(cex=1)
contMap(daviddat$mat51mean$phy, t(daviddat$mat51mean$comm)[,4] ,ftype="off",sig=1,legend=30, fsize=c(1,1.5))
text(50, -2, "Tannins", cex = 1.5)
 ylim<-c(1-0.12*(length(daviddat$mat51mean$phy$tip.label)-1),length(daviddat$mat51mean$phy$tip.label))
 plot.new(); plot.window(xlim=c(-0.1,0.1),ylim=ylim)
 text(rep(0,length(daviddat$mat51mean$phy$tip.label)), 1:length(daviddat$mat51mean$phy$tip.label),daviddat$mat51mean$phy$tip.label, cex = 1)
 contMap(daviddat$mat51mean$phy,t(daviddat$mat51mean$comm)[,8],ftype="off",direction="leftwards", sig=1,legend=30, fsize=c(1,1.5))
text(50, -2, "Leaf toughness", cex = 1.5)
dev.off()

#pdf("PhenToughCorEvo2.pdf", width = 20, height = 12)
postscript("PhenToughCorEvo2out.eps", width = 12, height = 10, paper = "special", onefile = FALSE, horizontal = FALSE, pointsize=10)
 layout(matrix(1:3,1,3),widths=c(0.44,0.18,0.44))
 par(cex=1)
contMap(daviddat$mat51mean$phy, t(daviddat$mat51mean$comm)[,3] ,ftype="off",sig=1,legend=50, fsize=c(1,1.6), outline=T, lwd = 5)
text(25, 0, "Phenolics", cex = 1.8)
 ylim<-c(1-0.12*(length(daviddat$mat51mean$phy$tip.label)-1),length(daviddat$mat51mean$phy$tip.label))
 plot.new(); plot.window(xlim=c(-0,0),ylim=ylim)
 text(rep(0,length(daviddat$mat51mean$phy$tip.label)), 1:length(daviddat$mat51mean$phy$tip.label),daviddat$mat51mean$phy$tip.label, cex = 1)
 contMap(daviddat$mat51mean$phy,t(daviddat$mat51mean$comm)[,8],ftype="off",direction="leftwards", sig=1,legend=50, fsize=c(1,1.6), outline=T, lwd = 5)
text(25, 0, "Leaf toughness", cex = 1.8)
dev.off()


### TO DO: gls in caper

# ..........


### nodewise phylogenetic structure (PHYLOCOM AOT-module)

# untransformed/unscaled
traits <- daviddat$mat51mean$comm

traits <- as.data.frame(t(daviddat$mat51mean$comm))

colnames(traits)

hist((traits[,8]))

traits.t <- traits

traits.t[,3] <- sqrt(traits.t[,3])
traits.t[,4] <- log(traits.t[,4])
traits.t.scale <- scale(traits.t[,3:8])

# transformed/scaled
# traits <- scale(phycom09$traits.all.t.imp.herb)

writetraits(traits.t.scale, file = "traits", bin = NULL, sigd = 3)
write.tree(daviddat$mat51mean$phy, file = "phylo")

## plot Tsd.rand.low (Significance of standard deviation, rank in low tail of null distribution; recommended in our case, where the phylogeny only represents small set of species)
# and  Nsd rand.low (Significance of divergence deviation, rank in low tail of null distribution, see swenson and enquist, 2009, but according to Ackerly (phylocom manual) recommended for large/complete phylogenies)

### shell script to run aot in phylocom:
# oliver@thinkpad-oliver:~/phylocom-4.2$ ./src/phylocom aotf > results.bci.txt

divergence <- read.csv("/home/oliver/Dokumente/PhD/PostPhD/Projects/BEF_China/David_Eichenberg_TradeOff/david.diverge.trans.scale.csv", dec = ",", sep = "\t")

divergence.scale <- read.csv("/home/oliver/Dokumente/PhD/PostPhD/Projects/BEF_China/David_Eichenberg_TradeOff/david.diverge.trans.scale.csv", dec = ",", sep = "\t")

library(lattice)

#levels(diverge$trait.name) <- c("Phen","Tan","LNC", "CNR" ,"LCC", "LT")
# grey-scale version:
div <- xyplot(Tsd.rankLow ~ age, groups=trait.name, data = divergence.scale[divergence.scale$trait.name=="Tan"|divergence.scale$trait.name=="Phen"|divergence.scale$trait.name=="LT", ], type = c("p","smooth"), xlim = c(10, 130), ylim = c(-25, 1050), pch = 1, lty = 1, cex = 1, par.settings = list(axis.line = list(col = 0)),scales=list(col=1,tck=c(-1,0)),  # remove top and right axes
              panel=function(...){
                lims <- current.panel.limits()
                panel.xyplot(...)
                panel.abline(h=lims$ylim[1],v=lims$xlim[1], lwd = 2.5)
              },
              layout.heights=list(axis.xlab.padding = 1),
lwd = 2.5, col = c(1:3), xlab = "Time (Myr)", ylab = "Observed divergence size (Rank)", key=list(space="inside",  between = 1, padding.text = 2, just = c(.7, .5), columns = 1, lines = list(lty = 1, lwd = 2.5, col = c(1:3)),text = list(levels(divergence.scale$trait.name)[4:6])))
plot(div)


pdf("cor.beta.pca.pdf", height = 6, width = 6)
#postscript(file = "DivergenceSize3col.eps",width = 6, height = 6.5, paper = "special", onefile = FALSE, horizontal = FALSE, pointsize=12)
plot(div)
dev.off()




# for the eight traits
#levels(diverge$trait.name) <- c("Lifeform", "evergreen","Phen","Tan","LNC", "CNR" ,"LCC", "LT")
div <- xyplot(Tsd.rankLow ~ age, groups=trait.name, data = divergence, type = "smooth", xlim = c(10, 130), ylim = c(-25, 1050), lty = c(1,2,3,4,1,2,3,4), par.settings = list(axis.line = list(col = 0)),scales=list(col=1,tck=c(-1,0)),  # remove top and right axes
              panel=function(...){
                lims <- current.panel.limits()
                panel.xyplot(...)
                panel.abline(h=lims$ylim[1],v=lims$xlim[1], lwd = 2.5)
              },
              layout.heights=list(axis.xlab.padding = 1),
lwd = 1.5, col = c("black","black","black","black","darkgrey","darkgrey","darkgrey","darkgrey"), xlab = "Time (Myr)", ylab = "Observed divergence size (Rank)", key=list(space="inside",  between = 1, padding.text = 2, just = c(.7, .5), columns = 2, lines = list(lty = c(1,2,3,4,1,2,3,4), lwd = 1.5, col = c("black","black","black","black","darkgrey","darkgrey","darkgrey","darkgrey")),text = list(levels(divergence$trait.name))))
plot(div)

postscript(file = "DivergenceSize.8.eps",width = 6, height = 6.5, paper = "special", onefile = FALSE, horizontal = FALSE, pointsize=12)
plot(div)
dev.off()

# plot trait means across phylogeny:
# Tip.mn: Mean value of trait across all descendent terminal taxa (T)
# Node.mn: Mean trait value calculated under ancestral averaging algorithm (A)

#levels(divergence.scale$trait.name) <- c("Phen","Tan","LNC", "CNR" ,"LCC", "LT")
# grey-scale version:
div <- xyplot(Tip.mn ~ age, groups=trait.name, data = divergence.scale, type = "smooth", xlim = c(10, 130), ylim = c(-.6, .8), lty = c(1,2,3,1,2,3), par.settings = list(axis.line = list(col = 0)),scales=list(col=1,tck=c(-1,0)),  # remove top and right axes
              panel=function(...){
                lims <- current.panel.limits()
                panel.xyplot(...)
                panel.abline(h=lims$ylim[1],v=lims$xlim[1], lwd = 2.5)
              },
              layout.heights=list(axis.xlab.padding = 1),
lwd = 1.5, col = c("black","black","black","darkgrey","darkgrey","darkgrey"), xlab = "Time (Myr)", ylab = "Trait mean value", key=list(space="inside",  between = 1, padding.text = 2, just = c(.7, .5), columns = 2, lines = list(lty = c(1,2,3,1,2,3), lwd = 1.5, col = c("black","black","black","darkgrey","darkgrey","darkgrey")),text = list(levels(divergence.scale$trait.name))))
plot(div)

postscript(file = "TraitMeansPhylo.eps",width = 6, height = 6.5, paper = "special", onefile = FALSE, horizontal = FALSE, pointsize=12)
plot(div)
dev.off()

# test: plot trait means at nodes agains each other:

plot(divergence.scale$Tip.mn[divergence.scale$trait.name=="Tan"], divergence.scale$Tip.mn[divergence.scale$trait.name=="LT"])

cor.test(divergence.scale$Tip.mn[divergence.scale$trait.name=="Tan"], divergence.scale$Tip.mn[divergence.scale$trait.name=="LT"])

######### plot raw divergence and 

# grey-scale version:
#, xlim = c(10, 130), ylim = c(-.6, .8)

div <- xyplot(ContributionIndex ~ age, groups=trait.name, data = divergence.scale[divergence.scale$trait.name=="Tan"|divergence.scale$trait.name=="Phen"|divergence.scale$trait.name=="LT", ], type = "smooth", xlim = c(10, 130), ylim = c(0.002, .03), pch = 1, lty = c(1,2,3), cex = 1, par.settings = list(axis.line = list(col = 0)),scales=list(col=1,tck=c(-1,0)),  # remove top and right axes
              panel=function(...){
                lims <- current.panel.limits()
                panel.xyplot(...)
                panel.abline(h=lims$ylim[1],v=lims$xlim[1], lwd = 2.5)
              },
              layout.heights=list(axis.xlab.padding = 1),
lwd = 2.5, col = "black", xlab = "Time (Myr)", ylab = "Total trait variance at node (%)", key=list(space="inside",  between = 1, padding.text = 2, just = c(.7, .5), columns = 1, lines = list(lty = c(1,2,3), lwd = 2.5, col = "black"),text = list(levels(divergence.scale$trait.name)[4:6])))
plot(div)


postscript(file = "PercVarAtNode.eps",width = 4.2, height = 4.5, paper = "special", onefile = FALSE, horizontal = FALSE, pointsize=12)
plot(div)
dev.off()



################################
###############################

mat <- match.phylo.comm(phy=befdat$phy.143.ultra, comm=t(befdat$com.order))

davidtraitsall[,7] <- as.numeric(davidtraitsall[,7])
davidtraitsall[,8] <- as.numeric(davidtraitsall[,8])

davidtraitsnum <- davidtraits[,7:14]

david.agg <- aggregate(davidtraitsnum, list(names = davidtraits$Species), mean)
david.agg.sd <- aggregate(davidtraitsnum, list(names = davidtraits$Species), sd)

rownames(david.agg) <- david.agg[,1]

rownames(david.agg) <- gsub(" ", "_", rownames(david.agg))
david.agg[,1] <- rownames(david.agg)

david.agg <- david.agg[,-1]

rownames(david.agg)[which(rownames(david.agg) %in% mat$phy$tip.label == FALSE)]

rownames(david.agg)[which(rownames(david.agg) %in% befdat$phy.full.ultra$tip.label == FALSE)]

CorTestPlot(david.agg[,-1])

# 

library(caper)

phydavid$edge.length <- phydavid$edge.length+.1

rownames(david.agg) <- david.agg[,1]

#################################


## prepare data for PGLS and PICs
traitmeans <- data.frame(t(daviddat$mat51mean$comm))
traitmeans2 <- cbind(rownames(traitmeans), traitmeans)
colnames(traitmeans2)[1] <- "names"
phylo <- daviddat$mat51mean$phy

phylo2 <- phylo[][1:4]
attr(phylo2, "class") <- "phylo"

# run PGLS analysis:
david.dat <- comparative.data(phylo2, traitmeans2, names, vcv=TRUE)

PGLSmod <- pgls(log(LT) ~ Tan, data=david.dat, )
summary(PGLSmod)

mod <- lm(log(LT) ~ Phen, data=traitmeans)
summary(mod)

anova(PGLSmod)

######################

# run PIC analysis

david.dat <- comparative.data(phylo2, traitmeans2, names)

crunchMod <- crunch(LT ~ Phenolics+Tannin, data=david.dat)
     summary(crunchMod)
     # plot the contrasts
     crunchTab <- caic.table(crunchMod)

     plot(LT ~ Tannin, crunchTab)

pdf("LT_Tannin_PIC.pdf")
plot(LT ~ Tannin, data = crunchTab)
dev.off()

cor.test(david.agg$LT, david.agg$Tannin, )
plot(crunchTab$Tan, crunchTab$LT)

#################################
# without gymnos

mat <- match.phylo.comm(phy=phy.ang, comm=t(david.agg[-1]))

mat$comm <- cbind(as.data.frame(colnames(mat$comm)) ,t(mat$comm))

colnames(mat$comm)[1] <- "names"

mat$phy$edge.length <- mat$phy$edge.length+.1



david.dat <- comparative.data(mat$phy, mat$comm, names)
crunchMod <- crunch(LT ~ Tannin, data=david.dat)
     summary(crunchMod)
     # plot the contrasts
     crunchTab <- caic.table(crunchMod)

     plot(LT ~ Tannin, crunchTab)

plot(LT ~ Tannin, data = david.agg)

#################################################

# tree - david

# "Manglietia_fordiana" - "Manglietia_yuyuanensis"
# "Distylium_myricoides" - "Distylium_buxifolium"

# 1) create tree for david (all 438 species)

phydavid <- befdat$phy.full.ultra

# 2) rename species according to david

phydavid$tip.label[phydavid$tip.label=="Vacciunium_mandarimorum"] <- "Vaccinium_mandarinorum"
phydavid$tip.label[phydavid$tip.label=="Quercus_phillyraeoides"] <- "Quercus_phillyreoides"
phydavid$tip.label[phydavid$tip.label=="Pourthiaea_hirsuta"] <- "Photinia_hirsuta"

phydavid$tip.label[phydavid$tip.label=="Manglietia_fordiana"] <- "Manglietia_yuyuanensis"
phydavid$tip.label[phydavid$tip.label=="Distylium_myricoides"] <- "Distylium_buxifolium"


rownames(david.agg)[which(rownames(david.agg) %in% phydavid$tip.label == FALSE)]


# 3) prune tree to davids names

mat <- match.phylo.comm(phy=phydavid, comm=t(david.agg))


phy.ang <- drop.tip(mat$phy, "Pinus_massoniana")

phydavid <- mat$phy

phylpatho <- phylo4d(mat$phy, t(mat$comm))

postscript("PhyloDavid.eps", width = 16, height = 24, paper = "special", onefile = FALSE, horizontal = FALSE, pointsize=14)
#pdf("PathoPhylofull.pdf", width = 16, height = 24)
phytab <- table.phylo4d(phylpatho, treetype="phylogram", show.node.label=F, box=F, ratio.tree=1/2, font=3, cex.label=1.3, cex.symbol=1.4, cex.legend = 1.1, scale = T, center = T, grid = T, var.label = colnames(david.agg))
dev.off()


MultiLambda <- function(tre, traits){
require(phytools)
mat <- matrix(NA, ncol = 3, nrow = dim(traits)[2])
colnames(mat) <- c("lambda","logL","P")
rownames(mat) <- colnames(traits)
for (i in 1:dim(traits)[2]){
    x <- phylosig(tre, traits[tre$tip.label,i], method="lambda", test=TRUE, nsim=1000)
    mat[i,] <- round(as.numeric(x), 4)
  }
    mat
}

MultiK<- function(tre, traits){
require(phytools)
mat <- matrix(NA, ncol = 2, nrow = dim(traits)[2])
colnames(mat) <- c("K","P")
rownames(mat) <- colnames(traits)
for (i in 1:dim(traits)[2]){
    x <- phylosig(tre, traits[tre$tip.label,i], method="K", test=TRUE, nsim=1000)
    mat[i,] <- round(as.numeric(x), 3)
  }
    mat
}

multK <- MultiK(mat$phy, t(mat$comm))

abou <- abouheif.moran(phylpatho)
abou

# phylo plotting function

table.phylo4d <- function (x, treetype = c("phylogram", "cladogram"), symbol = c("circles", 
    "squares", "colors"), repVar = 1:ncol(tdata(x, type = "tip")), 
    center = TRUE, scale = TRUE, legend = TRUE, grid = TRUE, 
    box = TRUE, show.tip.label = TRUE, show.node.label = TRUE, 
    show.var.label = TRUE, ratio.tree = 1/3, font = 3, tip.label = tipLabels(x), 
    var.label = colnames(tdata(x, type = "tip")), cex.symbol = 1, 
    cex.label = 1, cex.legend = 1, pch = 20, col = heat.colors(100), 
    coord.legend = NULL, ...) 
{
    if (is.character(chk <- checkPhylo4(x))) 
        stop("bad phylo4d object: ", chk)
    if (!require(ape)) 
        stop("the ape package is required")
    if (cex.label < 0.1) {
        show.tip.label <- FALSE
        show.node.label <- FALSE
        show.var.label <- FALSE
    }
    cex <- par("cex")
    symbol <- match.arg(symbol)
    treetype <- match.arg(treetype)
    SYMBSCALE <- 0.2
    if (symbol == "colors") {
        SYMBSCALE <- 0.05
      }
    tre <- suppressWarnings(as(x, "phylo"))
    if (ncol(tdata(x, type = "tip")) == 0) {
        plot.phylo(tre, type = treetype, direction = "rightwards",         
                   show.tip.label = show.tip.label, show.node.label = show.node.label, 
            cex = cex.label, no.margin = FALSE, x.lim = NULL, 
            y.lim = NULL, ...)
        return(invisible())
    }
    dat <- tdata(x, type = "tip")
    dat <- dat[, repVar, drop = FALSE]
    clas <- lapply(dat, class)
    isNum <- sapply(clas, function(e) e %in% c("integer", "numeric"))
    dat <- dat[, isNum, drop = FALSE]
    var.label <- var.label[repVar]
    var.label <- var.label[isNum]
    E <- edges(x)
    tips.ord <- E[, 2][!E[, 2] %in% E[, 1]]
    dat <- dat[tips.ord, , FALSE]
    tip.label <- tip.label[tips.ord]
    dat <- as.data.frame(scale(dat, center = center, scale = scale))
    temp <- var.label[which.max(nchar(var.label))]
    lab.height <- strwidth(temp, units = "inches", cex = cex.label)
    lab.height <- lab.height/par("pin")[1]
    plotreg <- plotreg0 <- par("plt")
    plotreg.width <- plotreg0[2] - plotreg0[1]
    plotreg.height <- plotreg0[4] - plotreg0[3]
    plotreg[2] <- plotreg[1] + (ratio.tree) * plotreg.width
    plotreg[3] <- plotreg[3] + plotreg.height * ifelse(show.var.label, 
        lab.height + 0.05, 0.05)
    plotreg[4] <- plotreg[4] - plotreg.height * 0.05
    par(plt = plotreg)
    plotres <- plot.phylo(tre, type = treetype, direction = "rightwards", 
        show.tip.label = FALSE, show.node.label = show.node.label, 
        cex = cex.label, no.margin = FALSE, x.lim = NULL, y.lim = NULL, 
        ...)
    par(plt = plotreg0)
    cur.usr.width <- par("usr")[2] - par("usr")[1]
    usr.width <- cur.usr.width/ratio.tree
    usr.height <- par("usr")[4] - par("usr")[3]
    x.inset <- SYMBSCALE * cex.symbol * usr.width/par("pin")[1]
    y.inset <- SYMBSCALE * cex.symbol * usr.height/par("pin")[2]
    x.base <- plotres$x.lim[2] + x.inset
    if (show.tip.label) {
        temp <- tipLabels(x)[which.max(nchar(tipLabels(x)))]
        lab.width <- strwidth(temp, units = "user", cex = cex.label)
    }
    else {
        lab.width <- 0
    }
    xrange.data <- c(x.base, (par("usr")[1] + usr.width) - lab.width - 
        2 * x.inset)
    if (diff(xrange.data) < (x.inset * ncol(dat))) 
        warning("There may not be enough room left to plot data; you may consider reducing ratio.tree or cex.label.")
    x.grid <- seq(xrange.data[1], xrange.data[2], length = ncol(dat))
    if (ncol(dat) == 1) {
        x.grid <- mean(c(xrange.data[1], xrange.data[2]))
    }
    y.grid <- seq(plotres$y.lim[1], plotres$y.lim[2], length = plotres$Ntip)
    temp <- expand.grid(y.grid, x.grid)
    xy.data <- data.frame(x = temp[, 2], y = temp[, 1])
    alldat <- cbind.data.frame(xy.data, unlist(dat))
    if (box) {
        box()
    }
    else {
        box(col = "transparent")
    }
    if (grid) {
        segments(x0 = x.grid, y0 = rep(min(y.grid), plotres$Ntip), 
            x1 = x.grid, y1 = rep(max(y.grid), plotres$Ntip), 
            col = "grey")
        segments(x0 = rep(min(x.grid), plotres$Ntip), y0 = y.grid, 
            x1 = rep(max(x.grid), plotres$Ntip), y1 = y.grid, 
            col = "grey")
    }
    makeColors <- function(x, col) {
        if (length(x) == 1) 
            return(col[1])
        nCol <- length(col)
        res <- x - min(x)
        res <- res/max(res)
        res <- res * (nCol - 1) + 1
        res <- round(res)
        res[res > nCol] <- nCol
        res[res < 1] <- 1
        return(col[res])
    }
    plotaux <- function(x, y, var, symbol, cex) {
        if (any(var[!is.na(var)] < 0)) {
            usebw <- TRUE
        }
        else {
            usebw <- FALSE
        }
        if (usebw) {
            ispos <- var > 0
            fg.col <- rep("black", length(var))
            fg.col[ispos] <- "white"
            bg.col <- rep("white", length(var))
            bg.col[ispos] <- "black"
            if (symbol == "squares") {
                symbols(x = x, y = y, squares = abs(var), inches = SYMBSCALE * 
                  cex, fg = fg.col, bg = bg.col, add = TRUE)
            }
            if (symbol == "circles") {
                symbols(x = x, y = y, circles = abs(var), inches = SYMBSCALE * 
                  cex, fg = fg.col, bg = bg.col, add = TRUE)
            }
            if (symbol == "colors") {
                myCol <- makeColors(var, col)
                points(x = x, y = y, pch = pch, cex = cex, col = myCol)
            }
        }
        else {
            if (symbol == "squares") {
                symbols(x = x, y = y, squares = var, inches = SYMBSCALE * 
                  cex, fg = "white", bg = "black", add = TRUE)
            }
            if (symbol == "circles") {
                symbols(x = x, y = y, circles = var, inches = SYMBSCALE * 
                  cex, fg = "white", bg = "black", add = TRUE)
            }
            if (symbol == "colors") {
                myCol <- makeColors(var, col)
                points(x = x, y = y, pch = pch, cex = cex, col = myCol)
            }
        }
        if (any(is.na(var))) {
            isNA <- is.na(var)
            points(x[isNA], y[isNA], pch = 4, cex = cex.symbol)
        }
    }
    plotaux(alldat[, 1], alldat[, 2], alldat[, 3], symbol, cex.symbol)
    if (show.var.label) 
        text(x = x.grid, y = rep(min(y.grid) - 1.5 * y.inset, 
            ncol(dat)), lab = var.label, adj = 1, srt = 90, cex = 1.2)
    if (show.tip.label) {
        x.base <- xrange.data[2] + x.inset
        text(x = rep(x.base, plotres$Ntip), y = 1:plotres$Ntip, 
            lab = tip.label, font = font, cex = cex.label, pos = 4)
    }
    if (legend) {
        addLegend <- function(x, y, z, cex.legend, cex.label, 
            cex.symbol) {
            z <- z * cex.legend
            leg.values <- pretty(z, n = 4, min.n = 1)
            temp <- length(leg.values)
            if (temp > 4) {
                leg.values <- leg.values[c(1, 2, temp - 1, temp)]
            }
            leg.txt <- as.character(leg.values)
            if (symbol == "colors") {
                sym.w <- strwidth("o", units = "user", cex = cex.symbol)
                sym.w <- rep(sym.w, length(leg.values))
                sym.h <- strheight("o", units = "user", cex = cex.symbol)
                sym.h <- rep(sym.h, length(leg.values))
            }
            else {
                usr.w <- (par("usr")[2] - par("usr")[1])/ratio.tree
                usr.h <- par("usr")[4] - par("usr")[3]
                sym.w <- usr.w * ((abs(leg.values)/max(abs(leg.values))) * 
                  SYMBSCALE * cex.symbol * cex.legend)/par("pin")[1]
                sym.h <- usr.h * (SYMBSCALE * cex.symbol * cex.legend)/par("pin")[2]
            }
            ann.w <- strwidth(leg.txt, units = "user", cex = cex.label * 
                cex.legend)
            ann.h <- strheight(leg.txt, units = "user", cex = cex.label * 
                cex.legend)
            space.w.sym <- sapply(1:(length(sym.w) - 1), function(i) sum(sym.w[c(i, 
                i + 1)]))
            space.w.ann <- sapply(1:(length(ann.w) - 1), function(i) sum(ann.w[c(i, 
                i + 1)]))/2
            temp <- cbind(space.w.sym, space.w.ann)
            space.w <- apply(temp, 1, max)
            if (symbol == "colors") {
                space.h <- sym.h + ann.h
            }
            else {
                space.w <- space.w + 0.01 * usr.w
                space.h <- sym.h + ann.h + 0.01 * usr.h
            }
            ann.coordX <- c(x, x + cumsum(space.w)) + max(sym.w[1], 
                ann.w[1]) + 0.01 * usr.w
            ann.coordY <- y
            sym.coordX <- ann.coordX
            sym.coordY <- y + space.h
            text(ann.coordX, ann.coordY, leg.txt, cex = cex.label * 
                cex.legend)
            plotaux(sym.coordX, sym.coordY, leg.values, symbol, 
                cex.symbol * cex.legend)
        }
        if (!is.null(coord.legend)) {
            x.leg <- coord.legend$x
            y.leg <- coord.legend$y
        }
        else {
            usr.w <- (par("usr")[2] - par("usr")[1])/ratio.tree
            usr.h <- par("usr")[4] - par("usr")[3]
            temp <- lab.height * usr.height/(1 - lab.height)
            y.base <- par("usr")[3] - temp - y.inset
            x.leg <- par("usr")[1] + 0.01 * usr.w
            y.leg <- y.base
        }
        addLegend(x = x.leg, y = y.leg, z = alldat[, 3], cex.legend = cex.legend, 
            cex.label = 1.7, cex.symbol = cex.symbol)
    }
    return(invisible())
}



####################################
## for Oecologia submission:##
####################################

##############################################
# 1) test for signal in traits (12-14.00)
# find the right trait data set
path.data.traits <- "/home/oliver/Dokumente/PhD/PostPhD/Projects/BEF_China/iDiv_BEF_Phylo/2_Phylosignal/Data/Traits/"
load(paste(path.data.traits,"befsignal.Rdata", sep = ""))

colnames(befsignal$traits.122)

# load 125-species syncsa data to get the phylogeny:
load("/home/oliver/Dokumente/PhD/PostPhD/Projects/BEF_China/Helge/SYNCSA/Data/syncsa.data.125.Rdata")

# choice of traits:
# leaf area, SLA, wood density, height, N, P (different axis of plant functional differentiation (see Swenson 2011 Proc.B.)):
traits.122.6 <- befsignal$traits.122[, c(7,8,11,13,26,27)]

summary(traits.122.6)


mat <- match.phylo.data(syncsa.data.125$phy.125.tree, traits.122.6)
mat$phy$edge.length <- mat$phy$edge.length+.001
plot(mat$phy, cex = .6)

MultiK<- function(tre, traits){
require(phytools)
mat <- matrix(NA, ncol = 2, nrow = dim(traits)[2])
colnames(mat) <- c("K","P")
rownames(mat) <- colnames(traits)
for (i in 1:dim(traits)[2]){
    x <- phylosig(tre, traits[tre$tip.label,i], method="K", test=TRUE, nsim=1000)
    mat[i,] <- round(as.numeric(x), 3)
  }
    mat
}

tip <- c("Machilus_grijsii")

phy.drop <- drop.tip(mat$phy, tip)
colnames(mat$data)
mat <- match.phylo.data(phy.drop, mat$data)
# mat$phy$edge.length <- mat$phy$edge.length+1

#### prepare data for Helge

BEF.phylo.traits.121 <- list("phylo"=mat$phy, "traits"=mat$data) 
save(BEF.phylo.traits.121, file = "BEF.phylo.traits.121.Rdata")


########

multk <- MultiK(mat$phy, ((mat$data)))
multk
write.csv(multk, file = "multk.csv", dec = ".")

# use lambda and moran

MultiLambda <- function(tre, traits){
require(phytools)
mat <- matrix(NA, ncol = 4, nrow = dim(traits)[2])
colnames(mat) <- c("lambda","logL","logL0","P")
rownames(mat) <- colnames(traits)
for (i in 1:dim(traits)[2]){
    x <- phylosig(tre, traits[tre$tip.label,i], method="lambda", test=TRUE)
    mat[i,] <- round(as.numeric(x), 3)
  }
    mat
}

multlam <- MultiLambda(mat$phy, mat$data)
multlam
write.csv(multlam, file = "multlam.csv", dec = ".")

# moran
phyl.traits.122.6 <- phylo4d(mat$phy, mat$data)

abou <- abouheif.moran(phyl.traits.122.6, alter="two-sided")
abou

write.csv(abou, file = "abou.csv")

# plot traits on the phylogeny

postscript(file = "Phyl.traits.122.6.eps", width = 10, height = 32, paper = "special", onefile = FALSE, horizontal = FALSE, pointsize=12)
#pdf("Phyl.traits.122.6.pdf", width = 10, height = 32)
phytab <- table.phylo4d(phyl.traits.122.6, treetype="phylogram", show.node.label=F, box=F, ratio.tree=1/3, font=3, cex.label=1.1, cex.symbol=1.8, cex.legend = 1.1, scale = T, center = T, grid = T, var.label = c("Leaf area", "SLA", "Leaf N", "Leaf P", "Wood density", "Height"))
dev.off()

#########################################################
# 2) re-run environmental data analysis (10.15 - 11.30)

# correct the aggregated P-data: sum over different layers instead of averaging 
path.data <- "/home/oliver/Dokumente/PhD/PostPhD/Projects/BEF_China/Data/"
load(paste(path.data,"befdat.Rdata", sep = ""))
save(befdat, file = paste(path.data,"befdat.Rdata", sep = ""))

rownames(befdat$site.order) <- befdat$site.order[,99]

names(befdat)
colnames(befdat$site.order)
befdat$site.order[,c(1,88,99,108,110)]

phos.all.sum <- aggregate(P_Initial_mg_kg ~ CSP, phos, FUN = sum)
colnames(phos.all.sum)[2] <- "P.tot.all.sum"

phos.all.sum.order <- phos.all.sum[befdat$site.order$CSP, ]

befdat$site.order <- cbind(befdat$site.order, phos.all.sum.order)

befdat$site.order[,c(1,3,5,6,9)]

# correct the topographic data
topo.new <- read.csv("/home/oliver/Dokumente/PhD/PostPhD/Projects/BEF_China/Data/BEF_Portal/Topography/CSP4all-aspect_new.csv")
# test correlation between old and corrected topogrophic data
topo.small <- topo.new[,c(2,3,4,8,9,13)]
str(topo.small)
topo.small$CSP <- 1:27

colnames(topo.small) <- paste(colnames(topo.small), "newtopo", sep = ".")
befdat$site.order <- cbind(befdat$site.order, topo.small[befdat$site.order$CSP,])

pdf("cor.topo.P.pdf", width = 10, height = 10)
pairs(befdat$site.order[, c(3,5,6,9,59,111:115,89,98,109)], lower.panel = panel.smooth,upper.panel = panel.cor, diag.panel = panel.hist)
dev.off()

# !! aspect and slope in the corrected data differ substantially from those in the old data, while the summed P values are perfectly correlated to the averaged ones

# carry out (partial) regression analysis with the updated topographic variables:

# 62,63 instead of 65 
# 93,94 instead of 95

# i) no3, nh4 and nmin x
# ii) no3, nh4 x
# iii) C, N
# iv) C, N, CN
# v) p.tot.1.2

env.new <- befdat$site.order[,c(111,112,113,114,  86,87, 45,50, 77,78,  95, 98)]

# final soil model
env.new <- befdat$site.order[,c(3,5,6,9,  86,87,  45,50,  79,  102,  98)]

# try wihout N.min
env.new <- befdat$site.order[,c(3,5,6,9,  86,87,  45,50,  79,    98)]

# with new topo.data:
# env.new <- befdat$site.order[,c(111,112,113,114,  86,87,  45,50,  79,  107,  98)]

# also try with only Nmin (without NO3 and NH4)
colnames(env.new)

colnames(befdat$site.order)

pdf("cor.env.new.pdf", width = 10, height = 10)
pairs(env.new, lower.panel = panel.smooth,upper.panel = panel.cor, diag.panel = panel.hist)
dev.off()


# pairs(befdat$site.order[,c(62,63,65, 77,78,79)], lower.panel = panel.smooth,upper.panel = panel.cor, diag.panel = panel.hist)

# [1] "Elevation.newtopo"        "slope_mean.newtopo"      
# [3] "aspect_northness.newtopo" "aspect_eastness.newtopo" 
# [5] "Light"                    "Red_far_red_ratio"       
# [7] "Soil_moisture"            "ph_H2O"                  
# [9] "C_N"                      "NO3"                     
#[11] "NH4"                      "Nmin"                    
#[13] "P.tot.all.sum" 

library(lmPerm)

timevec <- as.vector(dist(befdat$site.order$age_HB^3))

spatdist.all <- dist(befdat$site.order[,70:71])

pca.soil.log.scale <- rda(env.new, scale = T)

pdf("pca.soil11.log.scale.pdf", width = 10, height = 10.5)


biplot(pca.soil.log.scale)
dev.off()

#pdf("pca.soil11.log.scale.pdf", width = 10, height = 10.5)
postscript(file = "pca.soil11.log.scale.eps", width = 6, height = 6.2, paper = "special", onefile = FALSE, horizontal = FALSE, pointsize=12)
biplot(pca.soil.log.scale)
dev.off()



pca.soil.log.scale.pr <- prcomp(scale(env.new))

summary(pca.soil.log.scale.pr)

write.csv(scores(pca.soil.log.scale, choices = 1:6, display="species"), file = "env.scores.6.csv")
write.csv(summary(pca.soil.log.scale)$cont$importance, file = "pca.importance.csv")

screeplot(pca.soil.log.scale.pr, bstick=T)

soildist.all <- dist(pca.soil.log.scale$CA$u[,1:4])

# 2.1) use different number of PC axes (i.e. 2,5,all)

# number of axes to be chosen: 
# http://ordination.okstate.edu/overview.htm
# The eigenvalues represent the variance extracted by each axis, and are often conveniently expressed as a percentage of the sum of all eigenvalues (i.e. total variance). In the bryophyte example, The first four axes explain approximately 73%, 17%, 4%, and 3% of the variance, respectively. Since the first two axes explain (cumulatively) about 90% of the variance, we deem the 2-dimensional solution of Figure 7 adequate.

# or (BiodiversityR manual chapter 10):
# Two criteria are available to select the number
# of significant axes. The first criterion is to select
# axes for which the percentage of variance is larger
# than the corresponding percentage of variance of
# the broken-stick distribution. For the PCA results
# reported above, only two axes are significant:
# axis 1 with 29.5% (>18.7% of the broken-stick
# distribution) and axis 2 with 21.6% (>13.4%).
# Another criterion is to select the axes for which
# the cumulative percentage of variance is larger
# than the corresponding cumulative percentage of
# variance of the broken-stick distribution


# my text: "... the resulting first six principal compoments cummulatively explained about 90% of the total variance and were used to ... (alternative ... using eight axes (>95 of the total variation yielded similar results))"
# 

library(BiodiversityR)
PCAsignificance(pca.soil.log.scale,axes=8)

for (i in 2:dim(env.new)[2]){
    par(mfcol=c(dim(env.new)[2]-1,1))  
    
    #soildist.all1 <- dist(pca.soil.log.scale$CA$u[,1:6])
    soildist.all <- dist(scores(pca.soil.log.scale, choices = 1:6, display="sites"))
    
postscript("Succ.PIst.env.single.Oeco.eps", width = 9.5, height = 2.4, paper = "special", onefile = FALSE, horizontal = FALSE, pointsize=12)

    par(mfcol=c(1,5), mar=c(0,3.8,0.1,.1),oma=c(5.2,0,1.6,0), tcl=.3, las=1, cex = .75)
#for (i in c(1,5,3)){
par(bty = "l")    
res <- lmp(as.vector(as.dist(as.matrix(befdat$spacodi.temp.PIst.All$Pairwise$All)[1:5,1:5])) ~ as.vector(as.dist(as.matrix(spatdist.all)[1:5,1:5])))$residuals
# stage 1
summary(lmp(res ~ as.vector(as.dist(as.matrix(soildist.all)[1:5,1:5]))))    
plot(as.vector(as.dist(as.matrix(soildist.all)[1:5,1:5])), res, axes = FALSE, pch = 19, xlab = "", ylab = expression(paste(Pi[ST], " (partial residuals)")), mgp=c(2,0,0), ylim = c(-0.006, 0.007))
#abline(lm(res ~ as.vector(as.dist(as.matrix(soildist.all)[1:5,1:5]))), lty = 1, col = "red")
text(.5, -.005, "R² = 0.01, n.s.")
axis(side = 2, hadj=.5)
axis(side = 1, las = 1)
#text(1.9,55, "Taxonomic", cex = 1.4)
box()  
res <- lmp(as.vector(as.dist(as.matrix(befdat$spacodi.temp.PIst.All$Pairwise$All)[6:9,6:9])) ~ as.vector(as.dist(as.matrix(spatdist.all)[6:9,6:9])))$residuals
# stage 2
summary(lmp(res ~ as.vector(as.dist(as.matrix(soildist.all)[6:9,6:9]))))    
plot(as.vector(as.dist(as.matrix(soildist.all)[6:9,6:9])), res, axes = FALSE, pch = 19, xlab = "", ylab = "", mgp=c(2,0,0), ylim = c(-0.004, 0.003))
#abline(lm(res ~ as.vector(as.dist(as.matrix(soildist.all)[6:9,6:9]))), lty = 1, col = "red")
text(.6, -.0025, "R² = 0.18, n.s.")
axis(side = 2, hadj=.5)
axis(side = 1, las = 1)
#text(1.9,55, "Taxonomic", cex = 1.4)
box()   
res <- lm(as.vector(as.dist(as.matrix(befdat$spacodi.temp.PIst.All$Pairwise$All)[10:14,10:14])) ~ as.vector(as.dist(as.matrix(spatdist.all)[10:14,10:14])))$residuals
# stage 3
summary(lmp(res ~ as.vector(as.dist(as.matrix(soildist.all)[10:14,10:14]))))
plot(as.vector(as.dist(as.matrix(soildist.all)[10:14,10:14])), res, axes = FALSE, pch = 19, xlab = "", ylab = "", mgp=c(2,0,0), ylim = c(-0.005, 0.008))
#abline(lm(res ~ as.vector(as.dist(as.matrix(soildist.all)[10:14,10:14]))), lty = 1, col = "red")
text(.8, -.0045, "R² = 0.05, n.s.")
axis(side = 2, hadj=.5)
axis(side = 1, las = 1)
#text(1.9,55, "Taxonomic", cex = 1.4)
box()
res <- lm(as.vector(as.dist(as.matrix(befdat$spacodi.temp.PIst.All$Pairwise$All)[15:20,15:20])) ~ as.vector(as.dist(as.matrix(spatdist.all)[15:20,15:20])))$residuals
# stage 4
summary(lmp(res ~ as.vector(as.dist(as.matrix(soildist.all)[15:20,15:20]))))
plot(as.vector(as.dist(as.matrix(soildist.all)[15:20,15:20])), res, axes = FALSE, pch = 19, xlab = "", ylab = "", mgp=c(2,0,0), ylim = c(-0.009, 0.012))
abline(lm(res ~ as.vector(as.dist(as.matrix(soildist.all)[15:20,15:20]))), lty = 1, col = "red")
text(.95,-.007, "R² = 0.17*")
axis(side = 2, hadj=.5)
axis(side = 1, las = 1)
#text(1.9,55, "Taxonomic", cex = 1.4)
box()    
res <- lm(as.vector(as.dist(as.matrix(befdat$spacodi.temp.PIst.All$Pairwise$All)[21:27,21:27])) ~ as.vector(as.dist(as.matrix(spatdist.all)[21:27,21:27])))$residuals
# stage 5
summary(lmp(res ~ as.vector(as.dist(as.matrix(soildist.all)[21:27,21:27]))))    
plot(as.vector(as.dist(as.matrix(soildist.all)[21:27,21:27])), res, axes = FALSE, pch = 19, xlab = "", ylab = "", mgp=c(2,0,0), ylim = c(-0.006, 0.008))
abline(lm(res ~ as.vector(as.dist(as.matrix(soildist.all)[21:27,21:27]))), lty = 1, col = "red")
text(.8, -.005, "R² = 0.20*")
axis(side = 2, hadj=.5)
axis(side = 1, las = 1)
#text(1.9,55, "Taxonomic", cex = 1.4)
box()
mtext("Environmental distance", side=1, outer = T, line=2.5, at = .54, cex = .8)
mtext("Stage 1", side=3, at = .13, outer = T, line=.4, cex = .9)
mtext("Stage 2", side=3, at = .33, outer = T, line=.4, cex = .9)
mtext("Stage 3", side=3, at = .53, outer = T, line=.4, cex = .9)
mtext("Stage 4", side=3, at = .73, outer = T, line=.4, cex = .9)
mtext("Stage 5", side=3, at = .92, outer = T, line=.4, cex = .9) 
    
dev.off()  
       
}

# 3) resampling analysis: phylo.beta ~ environmental turnover (16.00-18.30)
# use my all.subsets PCA script on Rstudio

# i) for stages 4 and 5, generate all possible subsets of 5 (or 4) sites, store these combinations and carry out regression between env. distance and phylo.beta

# generate all subsets:
colnames(befdat$site.order)

befdat$site.order[15:20, c(59,99)]

library(picante)
library(gtools)
befdat$site.order[,c(59,99)]

stage <- 5 # successional stage
comb.numb <- 5 # number of plots to be included in 
comb.csp <- combinations(sum(befdat$site.order$age_HB==stage), comb.numb, as.character(befdat$site.order[befdat$site.order$age_HB==stage, 99]), set=TRUE, repeats.allowed=FALSE)
#dim(comb.csp)
library(foreach)
library(iterators)
iters <- dim(comb.csp)[1]
tab <- foreach(i = icount(iters), .combine=c) %do% {  
                                        #comb.csp <- combinations(6, 5, v=15:20, set=TRUE, repeats.allowed=FALSE)
                                        #gc()
                                        #i <- 1
    comb.csp.2  <- t(as.data.frame(comb.csp[i,])) #i
    colnames(comb.csp.2) <- comb.csp.2
    mat.pi <- match.comm.dist(comm=comb.csp.2, dis = befdat$spacodi.temp.PIst.All$Pairwise$All)$dis
                                        #mat.pi
    mat.soil <- match.comm.dist(comm=comb.csp.2, dis = soildist.all)$dis
                                        #mat.soil
    mat.spat <- match.comm.dist(comm=comb.csp.2, dis = spatdist.all)$dis
                                        #mat.spat
    res <- lmp(as.vector(mat.pi) ~ as.vector(mat.spat), perm="Prob")$residuals
    #summary(lmp(res ~ as.vector(mat.soil), perm="Prob"))$coefficients[2,3]
    summary(lmp(res ~ as.vector(mat.soil), perm="Prob"))$r.squared
}
mean(tab)

# methods: Because relationships between env. turnover and phylogenetic turnover may be a reflection of a different number, we assessed relationships between  

# results: strong associations between phylogenetic turnover and environmental differentation between plots belonging to late successional stages were maintained, even after subsampling of all combinations of (four or) five plots:
$r.squared:
#####################
# rarefy to 4 plots:
#####################
stage 1, 4 plots:
0.1349445
#
stage 2, 4 plots:
0.1863555
#
stage 3, 4 plots:
0.1156397
#
stage 4, 4 plots:
0.2442467
#
stage 5, 4 plots:
0.1933517

#####################
# rarefy to 5 plots:
#####################
stage 4, 5 plots:
0.2038736
#
stage 5, 5 plots:
0.2056937


# correlations between  
env.new.2 <- cbind(befdat$site.order[,c(59)], env.new)
colnames(env.new.2) <- c("Stage","Elevation","Aspect_E","Aspect_N","Slope","Light (PAR)","Red/far-red","Soil moisture","pH","Soil C/N","N mineral","P total")
as.dist(cor.table(env.new.2, cor.method = "pearson")$r)

write.csv(cor.table(env.new.2, cor.method = "pearson")$r, file = "Age.pearson.r.csv")

p.adj <- p.adjust(p=as.dist(cor.table(env.new.2, cor.method = "pearson")$P), method = "BH", n = length(p))

vec2dist <- function(betavec, com){
  mat <- matrix(NA, nrow = dim(com)[1], ncol = dim(com)[1])
  rownames(mat) <- rownames(com) 
  colnames(mat) <- rownames(com) 
  d <- as.dist(mat)
  for (i in 1:length(betavec)){
      d[i] <- betavec[i]
    }
  d
}

round(vec2dist(p.adj, t(env.new.2)),2)

write.csv(as.matrix(vec2dist(as.vector(as.dist(cor.table(env.new.2, cor.method = "pearson")$P)), t(env.new.2))), file = "Age.pearson.P.csv")


write.csv(cor.table(env.new.2, cor.method = "pearson")$P, file = "Age.pearson.r.csv")


postscript("cor.stage.env.eps", width = 10, height = 10, paper = "special", onefile = FALSE, horizontal = FALSE)
#pdf("cor.stage.env.pdf", width = 10, height = 10)
pairs(env.new.2, lower.panel = panel.smooth,upper.panel = panel.cor)
dev.off()

#####
# plot environmental turnover for single environmental variables against phylogenetic turnover
# i) collect (stack) vectors for 1) residuals (PIst~Spat.dist), 2) 

colnames(env.new) <- c("Elevation","Aspect_E","Aspect_N","Slope","Light (PAR)","Red/far-red","Soil moisture","pH","Soil C/N","N mineral","P total")

iter.env <- 11
iter.stage <- 5

x <- foreach (i = icount(iter.env), .combine=rbind) %:%  # for each of the 11 env. variables   
  foreach (j = icount(iter.stage), .combine=rbind) %do% { # for each of the 5 successional stages    
      comb.csp.2  <- as.data.frame(t(as.character(befdat$site.order[befdat$site.order$age_HB==j, 99])), stringsAsFactors=F)
    colnames(comb.csp.2) <- as.character(comb.csp.2[1,])
    mat.pi <- match.comm.dist(comm=comb.csp.2, dis = befdat$spacodi.temp.PIst.All$Pairwise$All)$dis
    soil.dis <- dist(env.new[,i])
    attr(soil.dis, "Labels") <- rownames(env.new)
    mat.soil <- match.comm.dist(comm=comb.csp.2, dis = soil.dis)$dis                                    #mat.soil
    mat.spat <- match.comm.dist(comm=comb.csp.2, dis = spatdist.all)$dis
    res <- lmp(as.vector(mat.pi) ~ as.vector(mat.spat), perm="Prob")$residuals
    res.soil <- cbind(res, scale((as.vector(mat.soil))), j, i)
    colnames(res.soil) <- c("res", "mat.soil", "stage", "env.var")
      res.soil
    }
x

x[,c(1,2)] <- scale(x[,c(1,2)]) # 

library(dplyr)
dat <- data_frame(PI_st= x[,1], Environmental_distance= x[,2], stage = x[,3], env.var = x[,4])

# give proper names to env. variables
for (i in 1:11){
dat$env.var[dat$env.var==i] <- colnames(env.new)[i]
 }

for (i in 1:5){
dat$stage[dat$stage==i] <- paste("Stage",i, sep = " ")
 }

dat <- within(dat, env.var <- factor(env.var, levels = unique(dat$env.var)))

#pdf("Succ.PIst.env.single.pdf", width = 6, height = 12)
postscript("Succ.PIst.env.single.eps", width = 6, height = 12, paper = "special", onefile = FALSE, horizontal = FALSE, pointsize=12)
ggplot(dat, aes(Environmental_distance, PI_st)) + 
    geom_smooth(method = "lm") + geom_point() + 
    facet_grid(env.var~stage, margins=F) +
    labs(y=expression(Pi[ST]*" (partial residuals)"), x= "Environmental distance")
dev.off()
# 

n <- 8
n*(n-1)/2

@

%\bibliographystyle{apa}
\bibliography{/home/oliver/Dokumente/PhD/Literatur/Bibfile/dislit}


\end{document}
