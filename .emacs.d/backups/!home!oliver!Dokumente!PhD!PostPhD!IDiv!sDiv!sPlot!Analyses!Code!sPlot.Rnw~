\renewcommand{\sfdefault}{lmss}
\renewcommand{\ttdefault}{lmtt}
\usepackage[T1]{fontenc}
\usepackage{geometry}
\geometry{verbose,tmargin=2.5cm,bmargin=2.5cm,lmargin=2.5cm,rmargin=2.5cm}
\usepackage{url}
\usepackage[authoryear]{natbib}

\makeatletter
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% User specified LaTeX commands.
% \VignetteIndexEntry{An Introduction to knitr}

\makeatother

\begin{document}

\title{Lab report: "Phylogenetic signal in species' co-occurrence"}

\author{Oliver Purschke}

\maketitle

<<show-off>>=

# load packages
library(multitable)
library(knitr)
library(taxize)
library(plyr)
library(vegdata)
library(reshape)
library(reshape2)
library(dplyr)
library(lattice)
library(Hmisc)
library(stringr)
library(rgdal)
library(ggplot2)
library(maptools)
library(pez)
library(Taxonstand)
library(willeerd)
library(curl)

# set paths

path.code.generic <- "/home/oliver/Dokumente/PhD/Code/"
path.code <- "/home/oliver/Dokumente/PhD/PostPhD/IDiv/sDiv/sPlot/Analyses/Code/"
path.data <- "/home/oliver/Dokumente/PhD/PostPhD/IDiv/sDiv/sPlot/Analyses/Data/"

# load additional functions
source(paste(path.code.generic, "OPfunc.R", sep = ""))

## read in sPlot species data
splot.spec <- read.csv(paste(path.data,
"Species/sPlot/sPlot_species_27_08_2014woStrata.csv", sep = ""))
splot.loc.schultz <- read.csv(paste(path.data,
"Species/sPlot/sPlot_species_26_08_2014.csv", sep = ""))
splot.spec.schultz <- read.csv(paste(path.data,
"Species/sPlot/sPlot_species_26_08_2014.csv", sep = ""))

# ! import species list with only vascular plants (group ID > 1) + exclude Austria-Species that are not in Symbiosis (as they contain very many Bryophytes)

splot.spec.vasc <- read.csv(paste(path.data, "Species/sPlot/sPlot_species_29_08_2014Vascular.csv", sep = ""))


## explore data:
dim(splot.spec.vasc)
# 72377 rows
summary(splot.spec.vasc)

head(splot.spec.vasc)

splot.spec.vasc[1:200, c(5, 8)]
sort(unique(splot.spec.vasc[, 5]))[1:20000]

splot.spec.vasc[, 5][duplicated(splot.spec.vasc[, 5])]

length(sort(unique(splot.spec.vasc[, 5])))
# 32188 unique species

###
# data cleaning 
snam <- as.character(splot.spec.vasc[, 5])
snam[1:30]


snam <- gsub(" sp.", " sp", snam, fixed = T)
snam[1:30]

snam <- gsub(" species", " sp", snam)

#snam <- gsub("spcies", " sp", snam)

snam <- gsub(" cf.", " ", snam)
snam[1:30]

#snam <- gsub("x ", "", snam, fixed = T)

snam <- gsub(" x ", " ", snam, fixed = T)
snam <- gsub(" gr. ", " ", snam, fixed = T)
snam <- gsub(" sect. ", " ", snam, fixed = T)
snam <- gsub(" Sec. ", " ", snam, fixed = T)
snam <- gsub(" sectie ", " ", snam)
snam <- gsub("  ", " ", snam)
snam <- gsub("  ", " ", snam)

#snam <- gsub("x ", "", snam)
#snam[1:500]

snam <- tolower(snam)
snam <- capitalize(snam)

sort(unique(snam))[20000:30000]

# indentify names that have just one part:
nam.len <- unlist(lapply(strsplit(snam, " "), FUN=length))
sum(nam.len==1)
snam[nam.len==1]
                                        
                                        # reduce the full species
names to just two parts 
# BUT only of those species with more than one name part
snam[nam.len!=1] <- word(snam[nam.len!=1],1,2)


# combine with the rest of the table
### check whether tables have similar lengths
length(snam)
str(snam)

length(splot.spec.vasc[, 5])
str(as.character(splot.spec.vasc[, 5]))

str(splot.spec.vasc)
splot.spec.vasc$TV.name.clean <- snam

names(splot.spec.vasc)

splot.spec.vasc[200:320,c(5,11)]

### remove species that have just on name part (as they do not make
sense)
splot.spec.vasc.2 <- splot.spec.vasc[nam.len!=1, ]
length(unique(splot.spec.vasc.2$TV.name.clean))
# 25433

###
# 2) clean the biome species list
###
# ! import species list with only vascular plants (group ID > 1) +
exclude Austria-Species that are not in Symbiosis (as they contain
very many Bryophytes)

splot.spec.biom.vasc <- read.csv(paste(path.data,
"Species/sPlot/sPloty_Species_Schulz_bio_29_08_2014Vascular.csv", sep
= ""))
dim(splot.spec.biom.vasc)
summary(splot.spec.biom.vasc)

head(splot.spec.biom.vasc)

###
# data cleaning 
snam <- as.character(splot.spec.biom.vasc[, 5])
snam[1:50]
snam[100:150]
sort(unique(snam))[20000:30000]
length(unique(snam))
# there are now only 30006 instead of >32000 species

snam <- gsub(" sp.", " sp", snam, fixed = T)
snam[1:30]

snam <- gsub(" species", " sp", snam)

#snam <- gsub("spcies", " sp", snam)

snam <- gsub(" cf.", " ", snam)
snam[1:30]

#snam <- gsub("x ", "", snam, fixed = T)

snam <- gsub(" x ", " ", snam, fixed = T)
snam <- gsub(" gr. ", " ", snam, fixed = T)
snam <- gsub(" sect. ", " ", snam, fixed = T)
snam <- gsub(" Sec. ", " ", snam, fixed = T)
snam <- gsub(" sectie ", " ", snam)
snam <- gsub("  ", " ", snam)
snam <- gsub("  ", " ", snam)

# indentify names that have just one part:
nam.len <- unlist(lapply(strsplit(snam, " "), FUN=length))
sum(nam.len==1)
snam[nam.len==1]
                                        
# reduce the full species names to just two parts 
# BUT only of those species with more than one name part
snam[nam.len!=1] <- word(snam[nam.len!=1],1,2)

# combine with the rest of the table
### check whether tables have similar lengths
length(snam)
# 85221
str(snam)

length(splot.spec.biom.vasc[, 5])
str(as.character(splot.spec.biom.vasc[, 5]))

str(splot.spec.biom.vasc)
splot.spec.biom.vasc$TV.name.clean <- snam

names(splot.spec.biom.vasc)

splot.spec.biom.vasc[200:320,c(5,9)]

### remove species that have just on name part (as they do not make
sense)
splot.spec.biom.vasc.2 <- splot.spec.biom.vasc[nam.len!=1, ]
dim(splot.spec.biom.vasc.2)
# 85197

length(unique(sPlot.TRY.data$splot.spec.biom.vasc$TV.name.clean))
# 24442

# save the data
sPlot.TRY.data <- list("splot.spec.vasc" = splot.spec.vasc,
"splot.spec.biom.vasc" = splot.spec.biom.vasc.2)

sPlot.TRY.data$splot.spec.biom.vasc <- splot.spec.biom.vasc.2

save(sPlot.TRY.data, file = "sPlot.TRY.data.Rdata")

# in "splot.spec.vasc": aggregate "count" and "cover" at the species level
load("sPlot.TRY.data.Rdata")

names(sPlot.TRY.data$splot.spec.vasc)
# [7] "Count"  "Avg_Cover_Perc"      

test <- sPlot.TRY.data$splot.spec.vasc[,c(7,8,11)]
spec.group <- group_by(test, TV.name.clean)
spec.agg <- summarise(spec.group, mean(Count), mean(Avg_Cover_Perc))
dim(spec.agg)

sPlot.TRY.data$splot.spec.vasc.agg <- spec.agg

#### 
# 3) Merge with TRY-Data
####
library(colbycol)

# 3.1)
# for two columns
try.spec <- cbc.read.table("/home/oliver/Dokumente/PhD/PostPhD/IDiv/sDiv/sPlot/Analyses/Data/Species/TRY/Species/AccSpecies.txt", just.read = c(1, 2))
try.spec <- as.data.frame(try.spec)
try.spec[,2] <- as.character(try.spec[,2])

# for one column
try.spec <-
read.table("/home/oliver/Dokumente/PhD/PostPhD/IDiv/sDiv/sPlot/Analyses/Data/Species/TRY/Species/AccSpecies_Height.txt")
try.spec[,1] <- as.character(try.spec[,1])
colnames(try.spec) <- "AccSpeciesName"
dim(try.spec)

sPlot.TRY.data$try.height <- try.spec

100*(length(
    sPlot.TRY.data$splot.spec.vasc.agg$TV.name.clean
    [which(sPlot.TRY.data$splot.spec.vasc.agg$TV.name.clean 
           %in% 
           sPlot.TRY.data$try.height$AccSpeciesName)])/
     length(sPlot.TRY.data$splot.spec.vasc.agg$TV.name.clean))

# 55.06483% of the species are covered by traits in TRY
# 44.9666% of the species for which gap-filled traits (of the 100 most common traits in TRY)
# 29.63458% of the species in splot for which height is available
# 25.46562% of the sPlot species, seed mass data is available
# 14.51866% SLA

# create stats for i) the most frequent species, and ii) the most dominant species (with the highest percentage cover)

names(sPlot.TRY.data$splot.spec.vasc.agg)

fac1 <- cut(sPlot.TRY.data$splot.spec.vasc.agg[,2], quantile(sPlot.TRY.data$splot.spec.vasc.agg[,2],(0:3)/3),labels=c("Low","Medium","High"))

#mean(Count):
# quantile(sPlot.TRY.data$splot.spec.vasc.agg[,2]
#   0%   25%   50%   75%  100% 
 #   1     3     9    35 18865 

#mean(Avg_Cover_Perc):
#quantile(sPlot.TRY.data$splot.spec.vasc.agg[,3],(0:3)/3)
#       0% 33.33333% 66.66667%      100% 
#0.010000  2.000000  3.344444 88.000000 

sPlot.TRY.data$splot.spec.vasc.agg$count.fac <- fac1
sPlot.TRY.data$splot.spec.vasc.agg$cover.fac <- fac2

# 3.1) how many of the most common species in sPlot are covered by TRY?
# create single splot species lists for count=high and cover=high

count.high <- sPlot.TRY.data$splot.spec.vasc.agg[which(sPlot.TRY.data$splot.spec.vasc.agg[,4]=="High"),
]

cover.high <- sPlot.TRY.data$splot.spec.vasc.agg[which(sPlot.TRY.data$splot.spec.vasc.agg[,5]=="High"),
]


100*(length(
    cover.high$TV.name.clean
    [which(cover.high$TV.name.clean 
           %in% 
           sPlot.TRY.data$try.see$AccSpeciesName)])/
     length(cover.high$TV.name.clean))

# count.high:
# all: 70.83579
# gap.filled: 62.52505
# height: 48.07262
# seed mass: 40.78746
# sla: 29.50607

# cover.high:
# all: 63.89249
# gap.filled: 55.03949
# height: 40.49275
# seed mass: 35.83638
# sla: 23.47047

####
# 3.2) 
####

dim(sPlot.TRY.data$splot.spec.biom.vasc)

sort(unique(sPlot.TRY.data$splot.spec.biom.vasc$SCHULZ_BIO))

biom.vec <- sPlot.TRY.data$splot.spec.biom.vasc$SCHULZ_BIO
sPlot.biome <- sPlot.TRY.data$splot.spec.biom.vasc

100*(length(
    sPlot.biome$TV.name.clean[biom.vec==1]
    [which(sPlot.biome$TV.name.clean[biom.vec==1]
           %in% 
           sPlot.TRY.data$try.see$AccSpeciesName)])/
     length(unique(sPlot.biome$TV.name.clean[biom.vec==1])))

sPlot.biome$TV.name.clean[biom.vec==1]sPlot.biome$TV.name.clean[biom.vec==1]
    

res.biome.sla <- NA
for (i in 1:9){
res.biome.sla <- c(res.biome.sla, 100*(length(
    unique(sPlot.biome$TV.name.clean[biom.vec==i])
    [which(unique(sPlot.biome$TV.name.clean[biom.vec==i])
           %in% 
           sPlot.TRY.data$try.sla$AccSpeciesName)])/
     length(unique(sPlot.biome$TV.name.clean[biom.vec==i]))))
}
res.biome.sla

results.biomes <- cbind(res.biome.all, res.biome.gap,
res.biome.height, res.biome.seed, res.biome.sla)

results.biomes <- results.biomes[-1,]

rownames(results.biomes) <- (c(1:9))

results.biomes <- as.data.frame(results.biomes)


spec.num <- NA
for (i in 1:9){
    spec.num <- c(spec.num,
length(unique(sPlot.biome$TV.name.clean[biom.vec==i])))
}

spec.num <- spec.num[-1]
                                        
# add number of species per biome
results.biomes <- cbind(rownames(results.biomes), spec.num,
results.biomes)

colnames(results.biomes) <- c("Biome.Schultz", "Spec.num",
"TRY.all","Gap.filled","Height","Seed.mass","SLA")

sPlot.TRY.data$Match.sPlot.TRY.Biomes <- results.biomes

# type table for global trait match (+ count, cover)

match.count.cover <- read.csv("/home/oliver/Dokumente/PhD/PostPhD/IDiv/sDiv/sPlot/Analyses/Data/Species/Match.TRY.sPlot.count.cover.csv")

rownames(match.count.cover) <- match.count.cover$X
match.count.cover <- match.count.cover[,-1]
match.count.cover <- t(match.count.cover)

sPlot.TRY.data$Match.sPlot.TRY.Count.Cover <- match.count.cover

write.table(sPlot.TRY.data$Match.sPlot.TRY.Count.Cover, file =
"Match.sPlot.TRY.Count.Cover.txt")
write.csv(sPlot.TRY.data$Match.sPlot.TRY.Count.Cover, file =
"Match.sPlot.TRY.Count.Cover.csv")

write.table(sPlot.TRY.data$Match.sPlot.TRY.Biomes, file =
"Match.sPlot.TRY.Biomes.txt")
write.csv(sPlot.TRY.data$Match.sPlot.TRY.Biomes, file =
"Match.sPlot.TRY.Biomes.csv")


######
# create maps (for global)
######

# read in shape file for biomes
### 

library(maptools)
library(shapefiles)
library(rgdal)

schultzBiomesShape <-readOGR("/home/oliver/Dokumente/PhD/PostPhD/IDiv/sDiv/sPlot/Analyses/Data/GIS/SchulzBiomes","schultzDissolve3")
summary(schultzBiomesShape)
plot(schultzBiomesShape)

# reproject to Robinson
schultzBiomesRobinson <- spTransform(schultzBiomesShape, CRS("+proj=longlat +lon_0=0 +x_0=0 +y_0=0 +ellps=WGS84 +datum=WGS84 +units=m +no_defs"))
summary(schultzBiomesRobinson)  
plot(schultzBiomesRobinson, col = "grey")  

#schultzBiomesShape@data

biome.ggmap <- fortify(schultzBiomesShape, region = "BiomeCode", trait
= "Gap_filled")
summary(biome.ggmap)
str(biome.ggmap)

n <- length(unique(biome.ggmap$id)) 
# 9 corresponds to the groups
df <- data.frame(id = unique(biome.ggmap$id),
                 Trait.match_TRY.Gap.filled_Perc=
schultzBiomesRobinson@data$Gap_filled,
                 Biome =
factor(schultzBiomesRobinson@data$Schulz_Bio))

png(filename="Trait.match.Biome.TRY.gap.filled.png", height = 50,
width = 120, pointsize = 12)
#postscript(file = "Trait.match.Biome.TRY.gap.filled.eps", height = 5,
width = 12, paper = "special", onefile = FALSE, horizontal = FALSE,
pointsize=12)
#pdf("Trait.match.Biome.TRY.gap.filled.pdf", height = 5, width = 12)
ggplot(df, aes(map_id = id)) +
     geom_map(aes(fill = Trait.match_TRY.Gap.filled_Perc, color =
Biome), map =biome.ggmap) +
     expand_limits(x = biome.ggmap$long, y = biome.ggmap$lat) +
     scale_fill_gradient(low = "red", high = "blue", guide =
"colorbar")
dev.off()

#####
# produce barcharts in ggplot2

biome <- as.data.frame(sPlot.TRY.data$Match.sPlot.TRY.Count.Cover)
biome <- t(biome)
biome <- as.data.frame(biome)
biome$Traits <- factor(rownames(biome), levels=c("TRY.all",
"Gap.filled", "Height", "Seed.mass", "SLA"))
colnames(biome)[1:3] <- c("All", "Most Frequent", "Most Dominant")
mdat <- melt(biome, id.vars="Traits")
head(mdat)

postscript(file = "Trait.match.cover.dominance.eps", height = 4, width
= 8, paper = "special", onefile = FALSE, horizontal = FALSE,
pointsize=12)
#pdf("Trait.match.cover.dominance.pdf", height = 4, width = 8)
ggplot(mdat, aes(variable, value, fill=Traits)) + 
  geom_bar(stat="identity", position="dodge")+
    xlab("Species") +
  ylab("Percentage")+
  ggtitle("Match sPlot - TRY")
dev.off()

## for all biomes

biome2 <-
as.data.frame((as.data.frame(sPlot.TRY.data$Match.sPlot.TRY.Biomes)))

biome2 <- biome2[, -c(1:2)]

biome2$Biome <-
factor(c("Tropics.with.year-round.rain","Tropics.with.summer.rain","Dry.tropics.and.subtropics","Subtropics.with.winter.rain","Subtrop.with.year-round.rain","Temperate.midlatitudes","Dry.midlatitudes","Boreal.zone","Polar.and.subpolar.zone"),
levels=c("Tropics.with.year-round.rain","Tropics.with.summer.rain","Dry.tropics.and.subtropics","Subtropics.with.winter.rain","Subtrop.with.year-round.rain","Temperate.midlatitudes","Dry.midlatitudes","Boreal.zone","Polar.and.subpolar.zone"))

#colnames(biome2)[1:9] <-
as.character(schultzBiomesShape@data$Schulz_Bio)

mdat2 <- melt(biome2, id.vars="Biome")
head(mdat2)

#postscript(file = "Trait.match.biomes.eps", height = 4, width = 8,
paper = "special", onefile = FALSE, horizontal = FALSE, pointsize=12)
pdf("Trait.match.biomes.pdf", height = 4, width = 8)
ggplot(mdat2, aes(variable, value, fill=Biome)) + 
  geom_bar(stat="identity", position="dodge")+
    xlab("Traits") +
  ylab("Percentage")+
  ggtitle("Match sPlot - TRY")
dev.off()


# change projection of map:
#
http://gis.stackexchange.com/questions/44387/use-proj4-to-specify-robinson-projection-with-r-ggmap-and-ggplot2-packages

#############
# phylogeny #
#############

load("sPlot.TRY.data.Rdata")

save(sPlot.TRY.data, file = "sPlot.TRY.data.Rdata")

library(ape)
tank.tree <-
read.tree("/home/oliver/Dokumente/PhD/PostPhD/IDiv/sDiv/sPlot/Analyses/Data/Phylogeny/2/PhylogeneticResources/Vascular_Plants_rooted.dated.tre")

pdf("Fagaceae.pdf", width=20, height =30)
plot(extract.clade(tank.tree, "Fagaceae", root.edge = 0, interactive =
FALSE))
dev.off()

pdf("Rubiaceae.pdf", width=50, height =120)
plot(extract.clade(tank.tree, "Rubiaceae", root.edge = 0, interactive
= FALSE))
dev.off()

length(unique(tank.tree$tip.label))

unique(tank.tree$tip.label) %in%
unique(sPlot.TRY.data$splot.spec.vasc$TV.name.clean.2)

str(unique(tank.tree$tip.label)[1:10])
str(unique(sPlot.TRY.data$splot.spec.vasc$TV.name.clean)[1:10])

library(willeerd)
library(Taxonstand)

sPlot.TRY.data$splot.spec.vasc$TV.name.clean.2 <- gsub(" ", "_",
sPlot.TRY.data$splot.spec.vasc$TV.name.clean)

# how many splot species are in the tank tree?:
sum(unique(sPlot.TRY.data$splot.spec.vasc$TV.name.clean.2) %in%
unique(tank.tree$tip.label))
# 6637

sort(unique(sPlot.TRY.data$splot.spec.vasc$TV.name.clean.2[sPlot.TRY.data$splot.spec.vasc$TV.name.clean.2
%in% tank.tree$tip.label]))

sort(unique(sPlot.TRY.data$splot.spec.vasc$TV.name.clean.2[sPlot.TRY.data$splot.spec.vasc$TV.name.clean.2
%in% tank.tree$tip.label==F]))

# stuff to fix:
# 1) correct genera (using plant list or TNRS)
# e.g.: Elymus -> Leymus

nam <- unique(sPlot.TRY.data$splot.spec.vasc$TV.name.clean)[2000:2020]
nam <- as.vector(nam)
splot.plantlist <- make.clean.taxon.lookup(nam)

# 2) add genera: e.g. Elatine_sp
# consider skipping .sp131

# 3) add missing species to congeners
tree.con <-
congeneric.merge(sPlot.TRY.data$splot.spec.vasc$TV.name.clean.2,
tank.tree)

length(unique(tree.con$tip.label))

plot(tree.con, "f", cex = .01)

# 4) bind in another tree, e.g. Daphne tree

# what about gymnosperms

# which species missing from the Tank-tree are in GenBank?

# use willeerd to add missing species as congeners:

# use setdiff, intersect, union
                                        
# how many splot species are in the tank tree?:
sum(unique(sPlot.TRY.data$splot.spec.vasc$TV.name.clean.2) %in%
unique(tree.con$tip.label))

sPlot.TRY.data$splot.spec.vasc$TV.name.clean.2) %in%
unique(tree.con$tip.label)

?prune

phy.splot

?prune.tree
    
uni <- unique(sPlot.TRY.data$splot.spec.vasc$TV.name.clean.2)

uninam <- cbind(uni, uni)

rownames(uninam) <- uninam[,1]

mat <- match.phylo.data(tree.con, uninam)

mat$phy

pdf(file = "Phy.splot.pdf", height = 50, width = 50)
plot(mat$phy, "f", cex = .1)
dev.off()

make.clean.taxon.lookup <- function (species) {
    original <- species
    species <- gsub("_", " ", species)
    species <- gsub("  ", " ", species)
    search <- ldply(species, function(x) TPLck(x))
    lookup <- with(search, data.frame(original = original, clean =
ifelse(Plant.Name.Index, 
        paste(New.Genus, New.Species), NA)))
    return(lookup)
}

ptm <- proc.time()

for (i in seq(from =1, to = 25450, 1272)){
nam <-
sort(unique(sPlot.TRY.data$splot.spec.vasc$TV.name.clean))[i:(i+1271)]
splot.plantlist <- make.clean.taxon.lookup(nam)
write.csv(splot.plantlist, paste(paste("splotTPL", i), ".csv"))
}


# [2545:3817]
for (i in seq(from =2545, to = 3817, 127)){
nam <-
sort(unique(sPlot.TRY.data$splot.spec.vasc$TV.name.clean))[i:(i+126)]
splot.plantlist <- make.clean.taxon.lookup(nam)
write.csv(splot.plantlist, paste(paste("splotTPL", i), ".csv"))
}

# 2545:3816
nam <-
sort(unique(sPlot.TRY.data$splot.spec.vasc$TV.name.clean))[2545:3816]
splot.plantlist <- make.clean.taxon.lookup(nam)
splot.plantlist
write.csv(splot.plantlist, paste("splotTPL", "2545.csv"))


proc.time() - ptm

 User       System      verstrichen    
1.508       0.365      26.059 
1.327       0.375      23.627 
1.583       0.508      36.036


sPlot.TRY.data$splot.spec.vasc$TV.name.clean[sPlot.TRY.data$splot.spec.vasc$TV.name.clean
== "Astragalus psoraloides"] <- "Astragalus gjunaicus"


# start 13.30 runs till 16.30-18.30

tab1 <-
read.csv("/home/oliver/Dokumente/PhD/PostPhD/IDiv/sDiv/sPlot/Analyses/Code/splotTPL
1 .csv", head = T)
head(tab1)

tab <- NA
for (i in seq(from =1, to = 25450, 1272))
{
    tab <- rbind(tab, read.csv(paste(paste("splotTPL", i), ".csv")))
}

tab[,2] <- as.character(tab[,2])
tab[,3] <- as.character(tab[,3])

tab[3000:4000]


length(unique(tab[,2]))
#25451

length(unique(tab[,3]))
#20202

# why are there so much less unique cleaned species:
# 1) ~ 2500 synonyms
# 2) only genus information available e.g. ".sp"
# 3) name does not exist in TPL

sort((tab[,3]))
# 22634


tab[is.na(tab[,3]),2]

# export cleaned list

sPlot.TRY.data$TPLclean <- tab

save(sPlot.TRY.data, file = "sPlot.TRY.data.Rdata")


#################################
# building phylogenetic trees: 
#################################

# match species list from tank tree with 1) the plant list and 2)
tnrs:

# tnrs:
mynames <- sort(tank.tree$tip.label)
mynames <- gsub("_"," ", mynames)
tank.tree.tnrs <- tnrs(query = mynames, source = "iPlant_TNRS")#[ ,
-c(5:7)]
tank.tree.tnrs

# the plant list:
tank.tree.tpl <- tpl_search(mynames, paral = TRUE)

sPlot.TRY.data$tank.tree.tpl <-tank.tree.tpl
sPlot.TRY.data$tank.tree.tnrs <-tank.tree.tnrs

tpl_search("Kosteletzkya buettneri")

tnrs(query = "Crinum glaucum", source = "iPlant_TNRS")

temp <- gnr_resolve(names = "Paronychia kayseriana")

# Three different kinds of trees:

#################
# 1) just based on the cleaned list:
clean <- gsub(" ", "_", unique(sPlot.TRY.data$TPLclean$clean))

tree.congen.clean <- congeneric.merge(clean[-1], tank.tree)
# Number of species in tree before: 6595
# Number of species in tree now:    18748

uninam <- cbind(clean[-1], clean[-1])
rownames(uninam) <- uninam[,1]
library(picante)
mat <- match.phylo.data(tree.congen.clean, uninam)
mat$phy
sPlot.TRY.data$phy.clean.18748 <- mat$phy

# 18748 species

pdf(file = "Phy.splot.clean.pdf", height = 90, width = 90)
plot(mat$phy, "f", cex = .1, edge.width = .3, label.offset = .1)
dev.off()

#################
# 2) cleaned list + species that are not in the cleaned list (but in
the original list) but that are in the Tank-tree
tail(sPlot.TRY.data$TPLclean)
# which NA-species in the cleaned list are in the Tank-tree
# 18.50-19.15:
non.clean <-
unique(sPlot.TRY.data$TPLclean[is.na(sPlot.TRY.data$TPLclean[,3]),2])[-1]

# 2816 species in the original, non-cleaned list are not in the
cleaned list
# which of those species are in the Tank-tree?:
non.clean.unique <- gsub(" ", "_", non.clean)
length(non.clean.unique)
sum(non.clean.unique %in% unique(tank.tree$tip.label))
non.clean.unique <- non.clean.unique[non.clean.unique %in%
unique(tank.tree$tip.label)]

uninam.nonclean <- cbind(non.clean.unique, non.clean.unique)
rownames(uninam.nonclean) <- uninam.nonclean[,1]

clean.nonclean <-  rbind(uninam, uninam.nonclean)

mat <- match.phylo.data(tree.congen.clean, clean.nonclean)
mat$phy

sPlot.TRY.data$phy.clean.nonclean.18773 <- mat$phy

pdf(file = "Phy.splot.clean.nonclean.all.18773.pdf", height = 90,
width = 90)
plot(mat$phy, "f", cex = .1, edge.width = .3, label.offset = .1)
dev.off()

# try TNRS for non-resolved species
library(taxize)
temp <- gnr_resolve(names = non.clean[3:10])
temp$results[ , -c(1,4)]

mynames <- non.clean[10:20]
tnrs(query = mynames, source = "iPlant_TNRS")#[ , -c(5:7)]

#################
# 3) see 2) but including .sp-species
non.clean.unique <- gsub(" ", "_", non.clean)

uninam.nonclean <- cbind(non.clean.unique, non.clean.unique)
rownames(uninam.nonclean) <- uninam.nonclean[,1]

clean.nonclean.all <-  rbind(clean.nonclean, uninam.nonclean)
# 23042 species

tree.congen.clean.nonclean.all <-
congeneric.merge(clean.nonclean.all[,1], tank.tree)
# Number of species in tree before: 6645
# Number of species in tree now:    20817

# continue here:
mat <- match.phylo.data(tree.congen.clean.nonclean.all,
clean.nonclean.all)
mat$phy
sPlot.TRY.data$phy.clean.nonclean.all.20792 <- mat$phy

pdf(file = "Phy.splot.clean.nonclean.all.20792.pdf", height = 100,
width = 100)
plot(mat$phy, "f", cex = .1, edge.width = .3, label.offset = .1)
dev.off()

##########

# which species from the cleaned species list are in the tank tree

clean.unique <- gsub(" ", "_", unique(tab[,2]))
length(clean.unique)
sum(clean.unique %in% unique(tank.tree$tip.label))
# 6595

sort(unique(sPlot.TRY.data$splot.spec.vasc$TV.name.clean.2[sPlot.TRY.data$splot.spec.vasc$TV.name.clean.2
%in% tank.tree$tip.label]))

sort(unique(sPlot.TRY.data$splot.spec.vasc$TV.name.clean.2[sPlot.TRY.data$splot.spec.vasc$TV.name.clean.2
%in% tank.tree$tip.label==F]))


pdf(file = "Tank.Tree.pdf", height = 150, width = 150)
plot(tank.tree, "f", cex = .1, edge.width = .3, label.offset = .1)
dev.off()

##############################
### read in sPlot database ###
##############################

## this is where the real taxon cleaning of sPlot 1.0 started

path.sPlot <-
"/home/oliver/Dokumente/PhD/PostPhD/IDiv/sDiv/sPlot/Analyses/Data/Species/sPlot/sPlot_21_11_2014/"

# read species data (takes ~2 min on my 64bit, 2.5GHz machine)
splot.species <- read.csv(paste(path.sPlot,
"sPlot_21_11_2014_species.csv", sep = ""), sep = "\t")
dim(splot.species)
length(unique(splot.species$PlotObservationID))
# 15501064       10
summary(splot.species)
str(splot.species)
colnames(splot.species)
length(unique(splot.species$Turboveg2.concept))

unique(splot.species$Turboveg2.concept)

[3442] Oxalis commutata v. commutata                                
 [3443] Thesium frisea v. frisea                                     
 [3444] Ficinia indica v. indica                                     
 [3445] Cliffortia ruscifolia v. purpurea                            
 [3446] Crassula capensis v. albertiniae                             
 [3447] Pinus radiata                                                
 [3448] Chrysanthemoides monilifera s. canescens                     
 [3449] Babiana striata v. striata                                   
 [3450] Erica sphaeroidea v. sphaeroidea                             
 [3451] Oxalis tenuifolia                                            
 [3452] Hibiscus aethiopicus v. aethiopicus                          
 [3453] Oxalis nidulans v. nidulans                                  
 [3454] Bobartia gladiata s. gladiata                                
 [3455] Stipagrostis zeyheri s. barbata    

[5204]                                                              
 [5205] r                                                            
 [5206] Syzygium rowlandii        

[5309] 1285 Indigofera lange Bl-Stiele*                             
 [5310] 1304 Polygala*                                               
 [5311] Acalypha ciliata                                             
 [5312] Aeollanthus pubescens                                        
 [5313] Amorphophallus abyssinicus                                   
 [5314] Andropogon pseudapricus                                      
 [5315] Aneilema lanceolatum                                         
 [5316] Biophytum umbraculum                                         
 [5317] Brachystelma bingeri                                         
 [5318] Brachystoma africana (gibt es nicht)                         
 [5319] Ctenium sp.                                      

[6300] Floscopa sp.                                                 
 [6301] Kyllinga sp.                                                 
 [6302] Chrysochloa hindsii                                          
 [6303] Kyllinga odorata                                             
 [6304] Goldrute ?*                                                  
 [6305] Fimbristylis debilis                                         
 [6306] Striga cf.aspera*                                            
 [6307] Hibiscus cf. micranthus*                                     
 [6308] Celbel Baleewol ?*                                           
 [6309] Cyperus rotundus                                             
 [6310] Fimbristylis cf. albo-viridis*                               
 [6311] Cucumis sp.        

[6385] AT441 (Euphorbia)*                                           
 [6386] KHH Composite (breite Bl.)*                                  
 [6387] KHH 3037 (Ficus)*                                            
 [6388] KHH 3054 (Ficus cf. iteophylla  Miq.)*                       
 [6389] Dioscorea cf. togoensis*                                     
 [6390] Indigofera cf. colutea*                                      
 [6391] Cyperus cf. sphacelatus*                                     
 [6392] Pandiaka sp.                                                 
 [6393] Sida sp.                                                     
 [6394] Solanum sp.                                                  
 [6395] KHH 3012 (Geophyt, gescheckte Bl, Muscari?)*                 
 [6396] KHH 3025 (Liliaceae, gelbe Blüten, breite Blätter)*     
     
     [6519] ms477 Sida klein*                                            
 [6520] ms507 Commiphora*                                            
 [6521] ms509 Cyperus*                                               
 [6522] Cassia italica                                               
 [6523] ms515 Cyperus flache Ährchen*                                
 [6524] ms521 Sterculiacée*                                          
 [6525] ms525 Brachiaria spitz*                                      
 [6526] ms526 Bulbostylis*                                           
 [6527] ms531 Crotalaria*                                            
 [6528] ms749*                                                       
 [6529] ms741*                                                       
 [6530] Cymbopogon giganteus v. giganteus                            
 [6531] Tephrosia groß schlank rosa                                  
 [6532] Striga weiß                                                  
 [6533] ms757*                                                       
 [6534] Tephrosia groß schlank                                       
 [6535] Ipomoea cf. eriocarpa*                                       
 [6536] ms761*                                                       
 [6537] Cissus cf. populnea*                                         
 [6538] ms770*                                                       
 [6539] Aneilema sp. (Commelina 'Traube')                            
 [6540] ms776*                                                       
 [6541] Cissus polyantha                                             
 [6542] ms781*                                                       
 [6543] ms795*                
     
     [6551] AT435 Cyperaceae fine*                                       
 [6552] AT445 Cyperaceae étoile*                                     
 [6553] AT447 Commelina*                                             
 [6554] AT451 Scrophulariacée à fleurs jaunes*                       
 [6555] AT454 Indigofera deux fruits (geminata?)*                    
 [6556] AT456 Corchorus fascicularis ?*                              
 [6557] AT460 Polygalacée ferrière*                                  
 [6558] AT462 Urginea sp.*                                           
 [6559] AT467 Aristolochia*                                          
 [6560] AT469 Indigofera*                                            
 [6561] AT471 Aspilia fleurs blanches*                               
 [6562] AT473 Composée à fruits picants*                             
 [6563] AT476 Dioscorea feuilles …*                                  
 [6564] AT477 Dioscorea feuilles triangulaires*                      
 [6565] AT479 Striga fleurs blanches*                                
 [6566] AT480 Composée lianescente*                                  
 [6567] AT482 Vigna ressemble à feuilles d’haricot*                  
 [6568] AT483 Hyparrhenia rufa ?*                                    
 [6569] AT498 Euphorbia resembl. À Dioscorea*                        
 [6570] AT501 Sida sp. Fleur blanche grande*                         
 [6571] AT468 Papilionacée collante*                                 
 [6572] KHH Composée feuilles scabreux Nr.???*                       
 [6573] Ipomoea resembl. À Dioscorea Nr.??*                          
 [6574] Grewia cf. barteri*            
     
     
unique(splot.species$Matched.concept)


# read header information
splot.header <- read.csv(paste(path.sPlot, "sPlot_header.csv", sep =
""), sep = "\t")

dim(splot.header)
# 
summary(splot.header)
str(splot.header)
colnames(splot.header)


# for saturday morning start here

##############################
#### read in TRY database ####
##############################

# 

path.TRY <- "/home/oliver/Dokumente/PhD/PostPhD/IDiv/sDiv/sPlot/Analyses/Data/Traits/"

# LHS-traits from TRY 2.0 (2012/2013), gapfilled and log-transformed (15 more traits are available, see Shan et al. paper), Einzelmessungen, keine Mittelwerte
TRY.2.0.all.gapfilled.ln <- read.csv(paste(path.TRY, "allPredBackTrans.csv", sep = ""), sep = ",")

dim(TRY.2.0.all.gapfilled.ln)
# 259559      4
summary(TRY.2.0.all.gapfilled.ln)
str(TRY.2.0.all.gapfilled.ln)

length(unique(ID.names$AccSpeciesName))

# link Observation IDs to species names:
# read table that contains and IDs and accepted names 
ID.names <- read.table(paste(path.TRY, "TRY_pmf_DataRelease_cleaned_2012_08_25_SLA_Height_SeedMass.txt", sep = ""), sep = ";", head=T, stringsAsFactors=FALSE)
str(ID.names)
dim(ID.names)
# 281325     33
names(ID.names)

TRY.2.0.all.gapfilled.ln.acc.names <- merge(ID.names[,c(1,7,8,11,13:17)], TRY.2.0.all.gapfilled.ln, by.x = "ObservationID", by.y = "ObservationID")

str(TRY.2.0.all.gapfilled.ln.acc.names)
names(TRY.2.0.all.gapfilled.ln.acc.names)
dim(TRY.2.0.all.gapfilled.ln.acc.names)
# 259559     27

save(TRY.2.0.all.gapfilled.ln.acc.names, file = "TRY.2.0.all.gapfilled.ln.acc.names.Rdata")


# 1) create unified lookup table 

# generate combined unique species list for sPlot and TRY species:
spec.list.TRY.sPlot <-
sort(unique(c(as.character(splot.species$Turboveg2.concept),
as.character(TRY.2.0.LHS.gapfilled.ln.acc.names$AccSpeciesName))))
length(spec.list.TRY.sPlot)
# 81573
write.csv(spec.list.TRY.sPlot, file = "spec.list.TRY.sPlot.csv")

spec.list.TRY.sPlot.2 <- cbind(spec.list.TRY.sPlot,
spec.list.TRY.sPlot)
str(spec.list.TRY.sPlot.2)
spec.list.TRY.sPlot.2 <- as.data.frame(spec.list.TRY.sPlot.2)

spec.list.TRY.sPlot.2[,1] <- as.character(spec.list.TRY.sPlot.2[,1])
spec.list.TRY.sPlot.2[,2] <- as.character(spec.list.TRY.sPlot.2[,2])

colnames(spec.list.TRY.sPlot.2) <- c("names.sPlot.TRY",
"names.corr.string")
write.csv(spec.list.TRY.sPlot.2, file = "spec.list.TRY.sPlot.2.csv")

############################################################
# read in string-corrected table
#######

spec.list.TRY.sPlot <- read.csv("spec.list.TRY.sPlot.2.csv")
dim(spec.list.TRY.sPlot)
spec.list.TRY.sPlot <- spec.list.TRY.sPlot[, 2:3]
spec.list.TRY.sPlot[,1] <- as.character(spec.list.TRY.sPlot[,1])
spec.list.TRY.sPlot[,2] <- as.character(spec.list.TRY.sPlot[,2])
# correct some species that cause TPL to crash manually:
spec.list.TRY.sPlot[which(spec.list.TRY.sPlot[,2]=="Astragalus
psoraloides"),2] <- "Astragalus gjunaicus"
spec.list.TRY.sPlot[which(spec.list.TRY.sPlot[,2]=="Hedysarum
mackenzii"),2] <- "Hedysarum dasycarpum"

###########################################################

dim(spec.list.TRY.sPlot)

# check whether now 
# Tetraria burmannii is resolved

tpl.clean <- tpl_search(spec.list.TRY.sPlot[1:100], paral =
TRUE)[,c(1,2,6,8,9)]
# runs until ~2pm
# !!! continue here !!!
write.csv(tpl.clean, file = "tpl.clean.csv")

# use Taxonstand:
tpl.clean.sPlot.TRY <- TPL(splist=spec.list.TRY.sPlot[1:200, 2], genus
= NULL, species = NULL, infrasp = NULL, infra = TRUE, abbrev = TRUE,
corr = TRUE, diffchar = 2, max.distance = 1, version = "1.1", file =
"test.csv")
write.csv(tpl.clean.sPlot.TRY, file = "tpl.clean.sPlot.TRY.csv")

## cut into pieces:
#####################################################
for (i in seq(from =1, to = 10000, 1000)){
    nam <- spec.list.TRY.sPlot[i:(i+999),2]
    tpl.clean.sPlot.TRY <- TPL(nam, genus = NULL, species = NULL,
infrasp = NULL, infra = T, abbrev = TRUE, corr = TRUE, diffchar = 2,
max.distance = 1, version = "1.1", file = "")
    write.csv(tpl.clean.sPlot.TRY, paste(paste("splotTPL", i),
".csv"))
}
######################################################

# correct some species that cause TPL to crash manually:
spec.list.TRY.sPlot[which(spec.list.TRY.sPlot[,2]=="Astragalus
psoraloides"),2] <- "Astragalus gjunaicus"
spec.list.TRY.sPlot[which(spec.list.TRY.sPlot[,2]=="Hedysarum
mackenzii"),2] <- "Hedysarum dasycarpum"


# to check single species within a set of species
sp1 <- TPL(spec.list.TRY.sPlot[37348,2], genus = NULL, species = NULL,
infrasp = NULL, infra = T, abbrev = TRUE, corr = TRUE, diffchar = 2,
max.distance = 1, version = "1.1", file = "")
sp1

sp1 <- TPLck("Senecio erucaeformis", corr=TRUE, diffchar = 3,
max.distance=3)
sp1

# 1) read in TPL files:

tab <- NA
for (i in seq(from =1, to = 82000, 1000))
{
    tab <- rbind(tab, read.csv(paste(paste("splotTPL", i), ".csv")))
}

str(tab)

tab[81000:82002, c(1,10,11)]

TPL.81573 <- tab
TPL.81573 <- TPL.81573[-1,]

TPL.81573 <- TPL.81573[1:81573, ]

tail(TPL.81573)

# original names from splot and TRY
TPL.81573$names.sPlot.TRY.original <- spec.list.TRY.sPlot[,1]

TPL.81573$names.TPL.combined <- paste(TPL.81573$New.Genus,
TPL.81573$New.Species, sep = " ")


TPL.81573 <- TPL.81573[,-c(18:22)]

save(TPL.81573, file = "TPL.81573.Rdata")
write.csv(TPL.81573, file = "TPL.81573.csv")

colnames(TPL.81573)

TPL.81573[1:1000, c(8,16)]

str(TPL.81573$Taxonomic.status)

TPL.81573[,8] <- as.character(TPL.81573[,8])
TPL.81573[,16] <- as.character(TPL.81573[,16])

sum(TPL.81573$Taxonomic.status=="Accepted")
# 56546

sum(TPL.81573$Taxonomic.status=="Synonym")
# 11933

sum(TPL.81573$Taxonomic.status=="Misapplied")
# 6


###################
# to be corrected:
###################

sum(TPL.81573$Taxonomic.status=="Unresolved")
# 5105

sum(TPL.81573$Taxonomic.status=="")
# 7983



# 2) run unresolved against TNRS
mynames <- non.clean[10:20]
tnrs.nonresolved <- tnrs(query = mynames, source = "iPlant_TNRS")#[ ,
-c(5:7)]

tnrs.nonresolved <- tnrs(query =
TPL.81573[TPL.81573$Taxonomic.status=="", c(8,17)][1:100,2], source =
"iPlant_TNRS")[,c(1,2,4,5)]

tnrs.nonresolved[ ,1:2]

sum(tnrs.nonresolved[ ,2]!="")
# 27 TPL list

TPL.81573$tnrs.resolve <- NA

TPL.81573$tnrs.submitted <- NA
TPL.81573$tnrs.accepted <- NA
TPL.81573$tnrs.score <- NA
TPL.81573$tnrs.matched <- NA


for (i in
which(TPL.81573[10000:81573,]$Taxonomic.status=="Unresolved")){
    TPL.81573[i, 19:22] <- tnrs(query =
TPL.81573$names.TPL.combined[i], source = "iPlant_TNRS")[,c(1,2,4,5)]
}

for (i in which(TPL.81573[10008:81573,]$Taxonomic.status=="")){
    TPL.81573[i, 19:22] <- tnrs(query =
TPL.81573$names.TPL.combined[i], source = "iPlant_TNRS")[,c(1,2,4,5)]
}

save(TPL.81573, file = "TPL.81573.Rdata")

load("sPlot_TRY_Backbone_v._0.1.Rdata")

### continue here
# start 8.13 with 1000 names
tnrs.nonresolved <- tnrs(query =
TPL.81573[TPL.81573$Taxonomic.status=="Unresolved", 17], source =
"iPlant_TNRS")[,c(1,2,4,5)]
tnrs.nonresolved[ ,1:2]
sum(tnrs.nonresolved[ ,2]!="")
# 2160
save(tnrs.nonresolved, file = "tnrs.nonresolved.Rdata")
write.csv(tnrs.nonresolved, file = "tnrs.nonresolved.csv")

tnrs.missing <- tnrs(query = TPL.81573[TPL.81573$Taxonomic.status=="",
17], source = "iPlant_TNRS")[,c(1,2,4,5)]
tnrs.missing[ ,1:2]
sum(tnrs.missing[ ,2]!="")

# import TNRS unresolved & missing and TPL.grep unresolved & missing:
load("tnrs.nonresolved.Rdata")
load("tnrs.missing.Rdata")
load("TPL.grep.unresolved.Rdata")
load("TPL.grep.missing.Rdata")

##
length((TPL.81573$names.TPL.combined))
# 81573
length(unique(TPL.81573$names.TPL.combined))
# 63410

# merge tnrs with (taxonomic backbone) TBB
head(tnrs.missing)
str(tnrs.missing)


dim(tnrs.missing[which(tnrs.missing$acceptedname!="" &
tnrs.missing$score > .95), ])
# 2160 # where accepted names are available
# 446 ... which scores > 0.95

names(tnrs.missing[which(tnrs.missing$acceptedname!="" &
tnrs.missing$score > .95), ])

tnrs.missing.clean <- tnrs.missing[which(tnrs.missing$acceptedname!=""
& tnrs.missing$score > .95), 1:2]

write.csv(tnrs.missing.clean, file = "tnrs.missing.clean.csv")

names(tnrs.missing.clean)
names(tnrs.missing.clean)[1] <- "names.TPL.combined"

require(dplyr)
TPL.81573.merge.tnrs <- left_join(TPL.81573, tnrs.missing.clean)
dim(TPL.81573.merge.tnrs)
names(TPL.81573.merge.tnrs)[20] <- "tnrs.miss.accept"

write.csv(TPL.81573.merge.tnrs, "TPL.81573.merge.tnrs.csv")
TPL.81573 <- TPL.81573.merge.tnrs

# create empty columns "Final names 1" and "Final names 2"

TPL.81573$Final.names.1 <- NA
TPL.81573$Final.names.2 <- NA

# fill in final names column 

# Final.names.1: only fully resolved names

table(TPL.81573$Taxonomic.status)

TPL.81573$Final.names.1[which(TPL.81573$Taxonomic.status=="Misapplied")]
<-
TPL.81573$names.TPL.combined[TPL.81573$Taxonomic.status=="Misapplied"]

names(TPL.81573)

!is.na(TPL.81573$tnrs.miss.accept)

TPL.81573$Final.names.1[!is.na(TPL.81573$tnrs.miss.accept)] <-
TPL.81573$tnrs.miss.accept[!is.na(TPL.81573$tnrs.miss.accept)]

sum(!is.na(TPL.81573$Final.names.1))

# Final.names.2: full species list: resolved names and filling gaps
with all unmachted (including potentially erroneous and synonymous
names from TPL (new.genus & new.species = names.TPL.combined))

TPL.81573$Final.names.2 <- TPL.81573$Final.names.1
TPL.81573$Final.names.2[is.na(TPL.81573$Final.names.1)] <-
TPL.81573$names.TPL.combined[is.na(TPL.81573$Final.names.1)]

# Final.names.3: full species list: resolved names and filling gaps
with correct genus names from TPL:
TPL.81573$Final.names.3 <- TPL.81573$Final.names.1
TPL.81573$New.Genus <- as.character(TPL.81573$New.Genus)
TPL.81573$Final.names.3[is.na(TPL.81573$Final.names.1)] <-
TPL.81573$New.Genus[is.na(TPL.81573$Final.names.1)]

names(TPL.81573)


length(unique(TPL.81573$names.sPlot.TRY.original))

length(unique(TPL.81573$Final.names.1))
# 52226 resolved binomials

length(unique(TPL.81573$Final.names.2))
# 63116 (including non-resolved binomials)

length(unique(TPL.81573$Final.names.3))
# 56584 ()


write.csv(TPL.81573, "TPL.81573.csv")

save(TPL.81573, file = "TPL.81573.Rdata")

##
# import merged file for x-y-coords and biome shape
xy.db <- read.csv(file =
"/home/oliver/Dokumente/PhD/PostPhD/IDiv/sDiv/sPlot/Analyses/Data/GIS/SchulzBiomes/Biome_Christian/Oliver_Biome/xycoords.csv")
dim(xy.db)
head(xy.db)

# check whether there are really 700.000 unique lat lon-combinations:
latlon <- NA
latlon <- paste(splot.header$Longitude, splot.header$Latitude, sep =
"")
dim(latlon)
head(splot.header)
names(splot.header)
str(splot.header)

# check which rows have messed up coordinates
write.csv(splot.header[,c(1,25:26, 28)], file = "splot.header.xy.csv")

# which plot observ. IDs in the full header are not in the x.y db
file?
header.nonmatch.xy <- splot.header[splot.header$PlotObservationID %in%
xy.db$PlotObserv == FALSE, ]

head(header.nonmatch.xy)
write.csv(header.nonmatch.xy, file = "header.nonmatch.xy.csv")

######### generate community matrix
library(picante)
data(phylocom)
samp <- matrix2sample(phylocom$sample)

samp <- as.data.frame(samp)

samp2 <- cbind(samp, rnorm((1:48))+2)
names(samp2) <- c("plot", "abund", "spec", "trait")

save(samp2, file = "samp2.Rdata")

mat <- sample2matrix(samp)

###########
# match splot species with new species list based on original species
names
# should contain: 

# load backbone
load("/home/oliver/Dokumente/PhD/PostPhD/IDiv/sDiv/sPlot/Analyses/Code/sPlot_TRY_Backbone_v._0.1.Rdata")

# clean splot.species (Helge):


dim(splot.species)
index2 <-
match(splot.species$PlotObservationID,splot.header$PlotObservationID)
length(index2) #  15501064
any(is.na(index2)) # T
length(index2[is.na(index2)]) # 2
index2a <- which(is.na(index2))
splot.species$PlotObservationID[index2a] 
#[1] Myrianthus serratus Myrianthus serratus
which(splot.species$PlotObservationID==index2a[1])
length(which(splot.species$PlotObservationID==index2a[1]))
#-> REMOVE these 16 entries
dim(splot.species) # 15501064
splot.species <-
splot.species[-which(splot.species$PlotObservationID==index2a[1]),]
dim(splot.species) # 15501048 
length(levels(splot.species$PlotObservationID)) # 705273
splot.species$PlotObservationID <-
splot.species$PlotObservationID[,drop=T]
number.plots.total <- length(levels(splot.species$PlotObservationID))
# 705272

# this splot list is cleaned
dim(splot.species)

# simplify splot.species 
names(splot.species)
splot.species.small <- splot.species[,c(1,5,9)]
dim(splot.species.small)
# 15501048        3
str(splot.species.small)

splot.species.small$Turboveg2.concept <- as.character(splot.species.small$Turboveg2.concept)

backbone.small$names.sPlot.TRY.original[backbone.small$names.sPlot.TRY.original %in% splot.species.small$names.sPlot.TRY.original==F]

splot.species.small$names.sPlot.TRY.original[splot.species.small$names.sPlot.TRY.original %in% backbone.small$names.sPlot.TRY.original ==F]

# merge with tax. backbone:
dim(TPL.81573)
names(TPL.81573)

backbone.small <- TPL.81573[,c(18,21:23)]
head(backbone.small)

write.csv(backbone.small, file = "backbone.small.csv")
write.csv(backbone.small, file = "backbone.small.csv")


names(splot.species.small)[2] <- "names.sPlot.TRY.original"

splot.species.stand <- merge(splot.species.small, backbone.small, by.x = "Turboveg2.concept", by.y = "names.sPlot.TRY.original")

which(splot.species.stand$PlotObservationID %in%
splot.species$PlotObservationID)

#####
require(plyr)
splot.species.stand <- join(splot.species.small, backbone.small)
dim(splot.species.stand)
head(splot.species.stand)
names(splot.species.stand)

splot.species.stand$names.sPlot.TRY.original <-
splot.species.stand$Final.names.3

splot.species.stand <- splot.species.stand[,1:3]
names(splot.species.stand)[2] <- "StandSpeciesName" 

write.csv(splot.species.stand[500000:501000,], file = "splot.merge.csv")

save(splot.species.stand, file = "splot.species.stand.Rdata")

splot.species.stand

# !!!! check again some abundances against the origin 
# why are there more rows in "splot.species.stand" compared to
"splot.species"
which(splot.species.stand$PlotObservationID %in%
splot.species$PlotObservationID==F)


# next steps: species-trait means
####

names(backbone.small)
names(TRY.2.0.all.gapfilled.ln.acc.names)
dim(TRY.2.0.all.gapfilled.ln.acc.names)
# 259559     21

TRY.2.0.all.gapfilled.ln.acc.names$names.sPlot.TRY.original <- as.character(TRY.2.0.all.gapfilled.ln.acc.names$names.sPlot.TRY.original)

names(TRY.2.0.all.gapfilled.ln.acc.names)[3] <- "names.sPlot.TRY.original"

TRY.all.stand <- join(TRY.2.0.all.gapfilled.ln.acc.names, backbone.small)

dim(TRY.all.stand)

write.csv(TRY.all.stand, file = "TRY.all.stand.csv")

# traits, standardized species names, single observations, log-transformed
TRY.stand.sing <- TRY.all.stand
str(TRY.stand.sing)
names(TRY.stand.sing)

TRY.stand.sing$names.sPlot.TRY.original <- TRY.stand.sing$Final.names.3

TRY.stand.sing <- TRY.stand.sing[,c(3:21)]
str(TRY.stand.sing)
names(TRY.stand.sing)[1] <- "StandSpeciesName"

write.csv(TRY.stand.sing, file = "TRY.stand.sing.csv")

save(TRY.stand.sing, file = "TRY.stand.sing.Rdata")

# calculate species level trait values
library(data.table)

# match TRY with sPlot

TRY.stand.sing$StandSpeciesName <- as.factor(TRY.stand.sing$StandSpeciesName)
names(TRY.stand.sing)[2:19] <- c("SLA", "PlantHeight", "SeedMass",
"LDMC", "StemDens", "LeafArea", "LeafN", "LeafP", "LeafNperArea",
"Leaffreshmass", "LeafNPratio", "LeafC.perdrymass", "Leaf.delta.15N",
"Stem.cond.dens", "Seed.num.rep.unit", "Wood.vessel.length",
"Seed.length", "Disp.unit.leng")

TRY.stand.sing.DT <- data.table(TRY.stand.sing[,c(1:19)])
tables()
TRY.mean.sd <-  TRY.stand.sing.DT[, 
                               list(
                               n = length(SLA),
                               SLA.mean = mean(SLA), 
                               PlantHeight.mean = mean(PlantHeight), 
                               SeedMass.mean = mean(SeedMass),
                               LDMC.mean = mean(LDMC),
                               StemDens.mean = mean(StemDens),
                               LeafArea.mean = mean(LeafArea),
                               LeafN.mean = mean(LeafN),
                               LeafP.mean = mean(LeafP),
                               LeafNperArea.mean = mean(LeafNperArea),
                               Leaffreshmass.mean =
mean(Leaffreshmass),
                               LeafNPratio.mean = mean(LeafNPratio),
                               LeafC.perdrymass.mean =
mean(LeafC.perdrymass),
                               Leaf.delta.15N.mean =
mean(Leaf.delta.15N),
                               Stem.cond.dens.mean =
mean(Stem.cond.dens),
                               Seed.num.rep.unit.mean =
mean(Seed.num.rep.unit),
                               Wood.vessel.length.mean =
mean(Wood.vessel.length),
                               Seed.length.mean = mean(Seed.length),
                               Disp.unit.leng.mean =
mean(Disp.unit.leng),
                               
                               SLA.sd = sd(SLA), 
                               PlantHeight.sd = sd(PlantHeight), 
                               SeedMass.sd = sd(SeedMass),
                               LDMC.sd = sd(LDMC),
                               StemDens.sd = sd(StemDens),
                               LeafArea.sd = sd(LeafArea),
                               LeafN.sd = sd(LeafN),
                               LeafP.sd = sd(LeafP),
                               LeafNperArea.sd = sd(LeafNperArea),
                               Leaffreshmass.sd = sd(Leaffreshmass),
                               LeafNPratio.sd = sd(LeafNPratio),
                               LeafC.perdrymass.sd =
sd(LeafC.perdrymass),
                               Leaf.delta.15N.sd = sd(Leaf.delta.15N),
                               Stem.cond.dens.sd = sd(Stem.cond.dens),
                               Seed.num.rep.unit.sd =
sd(Seed.num.rep.unit),
                               Wood.vessel.length.sd =
sd(Wood.vessel.length),
                               Seed.length.sd = sd(Seed.length),
                               Disp.unit.leng.sd = sd(Disp.unit.leng)                                                              
                               ),
                               by=StandSpeciesName]

TRY.all.mean.sd <- as.data.frame(TRY.mean.sd)
write.csv(TRY.all.mean.sd, file = "TRY.all.mean.sd.csv")
save(TRY.all.mean.sd, file ="TRY.all.mean.sd.Rdata")

names(TRY.all.mean.sd)

index <- unique(splot.species.stand$StandSpeciesName) %in%
TRY.all.mean.sd$StandSpeciesName
sum(index)

100*(length(
    unique(splot.species.stand$StandSpeciesName)
    [which(unique(splot.species.stand$StandSpeciesName)
           %in% 
           TRY.all.mean.sd$StandSpeciesName)])/
     length(unique(splot.species.stand$StandSpeciesName)))


### match between splot and TRY
# 41.02522% of the species for which gap-filled trait in TRY 2.0 based on (2012/2013) is available

splot.species.try <- splot.species.stand[which(splot.species.stand$StandSpeciesName %in%
TRY.all.mean.sd$StandSpeciesName), ]
# 12349 species

dim(splot.species.try)
# 13693421        3

save(splot.species.try, file ="splot.species.try.Rdata")

# match TRY to splot
TRY.mean.sd.splot <- TRY.all.mean.sd[which(TRY.all.mean.sd$StandSpeciesName %in% splot.species.stand$StandSpeciesName), ]
dim(TRY.mean.sd.splot)

save(TRY.mean.sd.splot, file = "TRY.mean.sd.splot.Rdata")
write.csv(TRY.mean.sd.splot, file = "TRY.mean.sd.splot.csv")

########################################
########### calculate CWMs #############
########################################

load("splot.species.try.Rdata")
load("TRY.mean.sd.splot.Rdata")

# merge splot with LHS traits
library(dplyr) 
names(splot.species.try)
TRY.mean.sd.splot$StandSpeciesName <- as.character(TRY.mean.sd.splot$StandSpeciesName)
dim(splot.species.try)
names(splot.species.try)
names(TRY.mean.sd.splot)

rm(list = "splot.try")

# 13693421  
splot.try <- left_join(splot.species.try,
TRY.mean.sd.splot[,c(1,3:6)])
gc()
dim(splot.try)
head(splot.try)
names(splot.try)

library(data.table)
DT <- data.table(splot.try[,c(1:3)])
head(DT)
gc()
tables()
CWM.splot <-  DT[,list(CWM.SLA = weighted.mean(SLA.mean, Cover..), 
                       CWM.PlantHeight =
weighted.mean(PlantHeight.mean, Cover..), 
                       CWM.SeedMass = weighted.mean(SeedMass.mean,
Cover..),
                       CWM.LDMC = weighted.mean(LDMC.mean, Cover..),
                       CWM.StemDens = weighted.mean(StemDens.mean,
Cover..),
                       CWM.LeafArea = weighted.mean(LeafArea.mean,
Cover..),
                       CWM.LeafN = weighted.mean(LeafN.mean, Cover..),
                       CWM.LeafP = weighted.mean(LeafP.mean, Cover..),
                       CWM.LeafNperArea =
weighted.mean(LeafNperArea.mean, Cover..),
                       CWM.Leaffreshmass =
weighted.mean(Leaffreshmass.mean, Cover..),
                       CWM.LeafNPratio =
weighted.mean(LeafNPratio.mean, Cover..),
                       CWM.LeafC.perdrymass =
weighted.mean(LeafC.perdrymass.mean, Cover..),
                       CWM.Leaf.delta.15N =
weighted.mean(Leaf.delta.15N.mean, Cover..),
                       CWM.Stem.cond.dens =
weighted.mean(Stem.cond.dens.mean, Cover..),
                       CWM.Seed.num.rep.unit =
weighted.mean(Seed.num.rep.unit.mean, Cover..),
                       CWM.Wood.vessel.length =
weighted.mean(Wood.vessel.length.mean, Cover..),
                       CWM.Seed.length =
weighted.mean(Seed.length.mean, Cover..),
                       CWM.Disp.unit.leng =
weighted.mean(Disp.unit.leng.mean, Cover..)

                       ), 
                 
                 by=PlotObservationID]
str(CWM.splot)
dim(CWM.splot)
CWM.splot <- as.data.frame(CWM.splot)
save(CWM.splot, file = "CWM.splot.Rdata")
write.csv(CWM.splot, file = "CWM.splot.csv")

###############
# trait ranges
##############

Range.splot <-  DT[,list(Range.SLA = diff(range(SLA.mean)), 
                       Range.PlantHeight =
diff(range(PlantHeight.mean)),
                       Range.SeedMass = diff(range(SeedMass.mean)),
                       Range.LDMC = diff(range(LDMC.mean)),
                       Range.StemDens = diff(range(StemDens.mean)),
                       Range.LeafArea =diff(range(LeafArea.mean)),
                       Range.LeafN = diff(range(LeafN.mean)),
                       Range.LeafP = diff(range(LeafP.mean)),
                       Range.LeafNperArea =
diff(range(LeafNperArea.mean)),
                       Range.Leaffreshmass =
diff(range(Leaffreshmass.mean)),
                       Range.LeafNPratio =
diff(range(LeafNPratio.mean)),
                       Range.LeafC.perdrymass =
diff(range(LeafC.perdrymass.mean)),
                       Range.Leaf.delta.15N =
diff(range(Leaf.delta.15N.mean)),
                       Range.Stem.cond.dens =
diff(range(Stem.cond.dens.mean)),
                       Range.Seed.num.rep.unit =
diff(range(Seed.num.rep.unit.mean)),
                       Range.Wood.vessel.length =
diff(range(Wood.vessel.length.mean)),
                       Range.Seed.length =
diff(range(Seed.length.mean)),
                       Range.Disp.unit.leng =
diff(range(Disp.unit.leng.mean))

                       ), 
                 
                 by=PlotObservationID]
str(Range.splot)
dim(Range.splot)
head(Range.splot)
Range.splot <- as.data.frame(Range.splot)
save(Range.splot, file = "Range.splot.Rdata")
write.csv(Range.splot, file = "Range.splot.csv")

############################
### calculate FD indices ###
############################

# use data.table

# create distance matrix
rownames(TRY.mean.sd.splot) <- TRY.mean.sd.splot$StandSpeciesName
# one NA in TRY species names ()
## !!!! need to remove rows with NA s from 

TRY.mean.sd.splot <-
TRY.mean.sd.splot[which(is.na(TRY.mean.sd.splot$StandSpeciesName)==FALSE),
]
dim(TRY.mean.sd.splot)
str(TRY.mean.sd.splot)
save(TRY.mean.sd.splot, file = "TRY.mean.sd.splot.Rdata")

SLA.vec <- TRY.mean.sd.splot[,3]
names(SLA.vec) <- rownames(TRY.mean.sd.splot)
SLA.dist.mat <- as.matrix(dist(SLA.vec))
gc()

# get rid of NAs in splot.species.try
splot.species.try <-
splot.species.try[which(is.na(splot.species.try$Cover..)==FALSE), ]
str(splot.species.try)
save(splot.species.try, file = "splot.species.try.Rdata")

# create data.table
library(data.table)
DT <- data.table(splot.species.try)
head(DT)
gc()
tables()

# create small splot.DT
index <- 1:700
DT700 <- DT[which(DT$PlotObservationID %in% index),]
str(DT700)

DTall <- DT[which(DT$PlotObservationID %in% index),]


# test with small splot data set
mpd.phycom <-  DT.phycom[,list(MPD = mpd(t(abund),
as.matrix(dist(trait)), abundance.weighted=FALSE)),by=plot]

phycom.mat <- cophenetic(phylocom$phylo)

# problem: no species names associated with abund

# potential solution: need to write a 
mpd(as.data.frame(t(phylocom$sample[1,])), cophenetic(phylocom$phylo),
abundance.weighted=TRUE)

# function to assign species names to abundance vectors:
library(picante)
mpd.fun.dt <- function(abu, dis, nam, abundance.weighted){
    abu <- t(abu)
    colnames(abu) <- nam
    res <- mpd(abu, dis, abundance.weighted=abundance.weighted)
    res
}

mntd.fun.dt <- function(abu, dis, nam, abundance.weighted){
    abu <- t(abu)
    colnames(abu) <- nam
    res <- mntd(abu, dis, abundance.weighted=abundance.weighted)
    res
}


system.time(
mntd.sla.no.abu <-  DT[,list(mntd.sla = mntd.fun.dt(Cover..,
SLA.dist.mat, StandSpeciesName,
abundance.weighted=FALSE)),by=PlotObservationID]
)

system.time(
mntd.sla.no.abu <-  DT[,list(mntd.sla = mntd.fun.dt(Cover..,
SLA.dist.mat, StandSpeciesName,
abundance.weighted=TRUE)),by=PlotObservationID]
)

system.time(
mntd.sla.no.abu <-  DT[,list(mntd.sla = mntd.fun.dt(Cover..,
SLA.dist.mat, StandSpeciesName,
abundance.weighted=FALSE)),by=PlotObservationID]
)
system.time(
mntd.sla.no.abu <-  DT[,list(mntd.sla = mntd.fun.dt(Cover..,
SLA.dist.mat, StandSpeciesName,
abundance.weighted=TRUE)),by=PlotObservationID]
)



colnames(sla.mpd.mntd)[2:5] <- c("mpd.sla.no.abu", "mpd.sla.abu",
"mntd.sla.no.abu", "mntd.sla.abu")

head(sla.mpd.mntd)

save(sla.mpd.mntd, file = "sla.mpd.mntd.Rdata")
write.csv(sla.mpd.mntd, file = "sla.mpd.mntd.csv")


#


# MPD #

# 1) either provide full distance matrix
# 2) recalculate distances for each set

# test with small data set across 100 sites
mpd100 <-  mpd(phylocom$sample, cophenetic(phylocom$phylo),
abundance.weighted=FALSE)

CWM1 <-  DT[,list(CWM =
sd(Cover..)*mean(Cover..)),by=PlotObservationID]


# system.time()

CWM1 <-  DT[,list(CWM =
sd(Cover..)*mean(Cover..)),by=PlotObservationID]

DT %>% 
    group_by(PlotObservationID) %>% 
    summarise(mittel=sd(Cover..)*mean(Cover..),.parallel=TRUE)

ddply(data=DT, .(PlotObservationID),
summarise(mittel=sd(Cover..)*mean(Cover..)), .parallel=TRUE)
#############

str(dummy$abun)

trait <- as.data.frame(dummy$trait[,2])
rownames(trait) <- rownames(dummy$trait)

abun <- t(as.data.frame(dummy$abun[1,]))[]
abun[1,] <- 1:8

test <- dbFD(dummy$trait, abun, stand.x = TRUE,
         ord = c("podani", "metric"), asym.bin = NULL,
         corr = c("sqrt", "cailliez", "lingoes", "none"),
         calc.FRic = TRUE, m = "max", stand.FRic = FALSE,
         scale.RaoQ = FALSE, calc.FGR = FALSE, clust.type = "ward",
         km.inf.gr = 2, km.sup.gr = nrow(x) - 1, km.iter = 100,
         km.crit = c("calinski", "ssi"), calc.CWM = FALSE,
         CWM.type = c("dom", "all"), calc.FDiv = TRUE, dist.bin = 2, 
         print.pco = FALSE, messages = TRUE)
test

#######
dim(TRY.mean.sd.splot)

LHS.dist.mat <- as.matrix(dist(TRY.mean.sd.splot[,3:5]))
gc()

save(mat, file = "mat.Rdata")


## span functional distance for the 3 single LHS traits and the three
LHS traits together
    # save this matrices and use it for i) dendrogram construction and
ii) to calculate mpd, etc.

# run on FD (dendrogram-based) - possibly span distance matrix server
    # (use PD function and create dendrogram according my approach in
my PD-paper)

# mpd and mntd
  data(phylocom)
    test <- mntd(phylocom$sample[, 1:10], cophenetic(phylocom$phylo),
abundance.weighted=TRUE)
 
# 
################





tnrs.missing$score <- as.numeric(tnrs.missing$score)

tnrs.missing.greater.0.95 <- tnrs.missing[tnrs.missing$score > .95, ]
str(tnrs.missing.greater.0.95)

names(TPL.81573)

TPL.81573 <- TPL.81573.merge.tnrs

tnrs.nonresolved.greater.0.95$submittedname %in%
TPL.81573$names.TPL.combined

TPL.81573.merge.tnrs <- merge(TPL.81573,
tnrs.nonresolved.greater.0.95, by.x = "names.TPL.combined", by.y =
"submittedname", all = TRUE, all.x = TRUE, all.y = FALSE)

#### continue here, try match based on COMMON field
require(dplyr)
TPL.81573.merge.tnrs <- left_join(TPL.81573,
tnrs.nonresolved.greater.0.95, by = c("names.TPL.combined",
"submittedname"))

dim(TPL.81573.merge.tnrs)
str(TPL.81573.merge.tnrs)
names(TPL.81573.merge.tnrs)
write.csv(TPL.81573.merge.tnrs, file = "TPL.81573.merge.tnrs.csv")

names(TPL.81573.merge.tnrs)[19:21] <- c("tnrs.miss.accept",
"tnrs.miss.score", "tnrs.miss.matched")

##
table(TPL.grep.missing$Taxonomic.status)

TPL.grep.missing <- cbind(paste(TPL.grep.missing$Genus,
TPL.grep.missing$Species, sep = " "), TPL.grep.missing[,c(7)],
(paste(TPL.grep.missing$New.Genus, TPL.grep.missing$New.Species, sep =
" ")))

TPL.grep.missing <- as.data.frame(TPL.grep.missing)
TPL.grep.missing[,2] <- as.character(TPL.grep.missing[,2])
TPL.grep.missing[,1] <- as.character(TPL.grep.missing[,1])
TPL.grep.missing[,3] <- as.character(TPL.grep.missing[,3])

which(TPL.grep.missing[,2]=="Accepted")


TPL.81573.merge.tnrs <- merge(TPL.81573, TPL.grep.missing, by.x =
"names.TPL.combined.1", by.y = "V1", all = TRUE, all.x = TRUE, all.y =
FALSE)
dim(TPL.81573.merge.tnrs)
str(TPL.81573.merge.tnrs)
names(TPL.81573.merge.tnrs)

names(TPL.81573.merge.tnrs)[30:31] <- c("TPL.grep.status.miss",
"TPL.grep.names.miss")

write.csv(TPL.81573.merge.tnrs, file = "TPL.81573.merge.tnrs.csv")

########
TPL.81573 <- read.csv("TPL.81573.csv")
TPL.81573$Taxonomic.status <- as.character(TPL.81573$Taxonomic.status)
TPL.81573$names.sPlot.TRY.original <-
as.character(TPL.81573$names.sPlot.TRY.original)
TPL.81573$names.TPL.combined <-
as.character(TPL.81573$names.TPL.combined)

# unified list next steps:
# 1) read in all 80+ files from TPL ! check whether there are 81573
rows
# 2) run unresolved against TNRS
# 3) run missing against TNRS
# 4) run still unmatched (unresolved + missing) species with
appropriate grepping against TPL (diffchar = 3, max.distance = 3)
# 5) merge with huge tax.backbone

############################
# To Do (note to myself): #
############################

# 1) create unified lookup table for species names (taxonomic
backbone) based on TPL (TNRS is erroneous), ask Florian Jansen
regarding unresolved species names
# clean taxonomy in TRY and sPlot
# 2) calculate species-level traits means, sd & n
# !!! put everything in a multitable object
# 3) calculate community-levels mean traits (with and without
abundance-weighting), range and higher moments of the trait
distribution (variance, skewness, kurtosis)
# 4) evtl. calculate more FD indices, FEve, FDis, Rao, MPD etc.
# 5) assign biomes to plots (intersect x-y coords and biome-shape, ask
Gunnar)
# 6) link plot data to env. data (i.e. bioclim, FAO-soil, etc.), ask
Gunnar, and temporal variability (Miguel)

# other crucial steps:
# filter grassland and forest plots
# know

## ... more advanced analysis:
# standardized effect sizes within biomes
# functional turnover within between biomes, env. and spatial distance
decay within and among biomes
# .... etc.... 


############################
# New summary statistics on TRY-splot match across biomes #
############################

# (a) wie viele Plots (absolut) haben wir pro Biom
# (b) wie hoch ist die Plotdichte (plots pro 100 km²) in jedem der
Biome
# (c) wie viele Arten haben wir in den Plots der Biome
# (d) wie ist die Trait-Abdeckung der Arten pro Biom


# kick out erroneous plotIDs:

err <- 
c(464754,464845,464867,464930,465053,465109,465124,465125,465126
,465193,465283,465287,465339,465340,465341,465432,465438,465473
,465482,465576,465604,465612,465623,465630,465678,465721,465729
,465770,465793,465845,465905,465925,466043,466097,466098,466099
,466100,466101,466327,466347,466348,466477,466508,466509,466510
,466511,466602,466603,466641,466687,466688,466689,466690,466692
,466694,466695,466696,466915,466938,466999,467008,467093,467094
,467121,467122,467123,467124,467125,467126,467127,467128,467129
,467143,467214,467215,467236,467340,467363,467533,467612,467613
,467614,467667,467668,467679,467743,467758,467769,467804,467809
,467852,467990,468036,468205,468306,468324,468462,468491,468533
,468543,468567,468568,468627,468656,468727,468779,468780,468805
,468866,468896,468918,469016,469058,469306,469312,469699,469700
,469701,469702,469703,469711,469756,469757,469767,469768)

err <- as.factor(err)

# test: how many plots in old CWM file:

load("/home/oliver/Dropbox/sPlot_Analysis/FD/MPD_MNTD/SLA.mpd.mntd.Rdata")

##

# (a) wie viele Plots (absolut) haben wir pro Biom

load("splot.species.try.Rdata")
load("TRY.mean.sd.splot.Rdata")

# load whole sPlot:
load("splot.species.stand.Rdata")
length(unique(splot.species.stand$PlotObservationID))

splot.species.try <-
splot.species.try[which((splot.species.try$PlotObservationID %in%
err)==FALSE), ]
save(splot.species.try, file = "splot.species.try.Rdata")

# 13693419
splot.species.stand <-
splot.species.stand[which((splot.species.stand$PlotObservationID %in%
err)==FALSE), ]
save(splot.species.stand, file = "splot.species.stand.Rdata")


# and exclude abund=NA:
splot.species.stand <-
splot.species.stand[which(is.na(splot.species.stand$Cover..)==FALSE),
]
save(splot.species.stand, file = "splot.species.stand.Rdata")

## 
load("biome.xy.Rdata")
head(biome.xy)
which((biome.xy$PlotObserv %in% err)==TRUE)
plot(biome.xy$Longitude, biome.xy$Latitude)

# 

# 
100*(length(
    unique(splot.species.stand$StandSpeciesName)
    [which(unique(splot.species.stand$StandSpeciesName)
           %in% 
           TRY.mean.sd.splot$StandSpeciesName)])/
     length(unique(splot.species.stand$StandSpeciesName)))

# for 41.02598% of the species in splot gap-filled trait in TRY 2.0
based on (2012/2013) is available

length(unique(splot.species.stand$StandSpeciesName))
# after taxonomic standardization there are now 30099 unique species
names in splot

length(unique(TRY.all.mean.sd$StandSpeciesName))
# after taxonomic standardization there are 38831 unique species names
in TRY 2.0

length(unique(TRY.mean.sd.splot$StandSpeciesName))
# joining the two cleaned species list from TRY and sPlot yielded in
12348 species


# load entire TRY
load("TRY.all.mean.sd.Rdata")

# how many of the species Try are in splot?:
100*(length(
    unique(TRY.all.mean.sd$StandSpeciesName)
    [which(unique(TRY.all.mean.sd$StandSpeciesName)
           %in% 
           splot.species.stand$StandSpeciesName)])/
     length(unique(TRY.all.mean.sd$StandSpeciesName)))

# 31.79934% of all TRY species are in sPlot

#####################################################
# (a) wie viele Plots (absolut) haben wir pro Biom
#####################################################

# read Plot biome x-y table:

load("biome.xy.Rdata")
str(biome.xy)
biome.xy$PlotObserv <- as.factor(biome.xy$PlotObserv)

dim(biome.xy)

biome.xy <- biome.xy[which((biome.xy$PlotObserv %in% err)==FALSE), ]

save(biome.xy, file = "biome.xy.Rdata")

names(biome.xy)

length(unique(biome.xy$PlotObserv))

# 705813

# count number of plots within each biomes

library(data.table)
DTbiome <- data.table(biome.xy[,c(3:5,8)])
no.plots.biome <-  DTbiome[,list(No.plots = length(PlotObserv)),
by=Schulz_Bio]                      #                       
Schulz_Bio No.plots
#1:  1 Tropics with year-round rain     1470
#2:      2 Tropics with summer rain     5407
#3:    3 Dry tropics and subtropics     9998
#4:   4 Subtropics with winter rain    73185
#5: 5 Subtrop. with year-round rain    12179
#6:        6 Temperate midlatitudes   588419
#7:              7 Dry midlatitudes     5644
#8:                   8 Boreal zone     8133
#9:       9 Polar and subpolar zone     1378

write.csv(no.plots.biome, file = "no.plots.biome.csv")

library(dplyr)
library(reshape2)
no.plots.biome <- as.data.frame(no.plots.biome)
mdat2 <- melt(no.plots.biome, id.vars="Schulz_Bio")
head(mdat2)

library(ggplot2)

postscript(file = "NumberPlotsBiomeLog.eps", height = 4, width = 7,
paper = "special", onefile = FALSE, horizontal = FALSE, pointsize=12)
#pdf("NumberSpeciesBiome.pdf", height = 4, width = 8)
ggplot(mdat2, aes(variable, log(value), fill=Schulz_Bio)) + 
  geom_bar(stat="identity", position="dodge")+
    xlab("Biomes") +
  ylab("log(Number of plots)")+
  ggtitle("Number of species per biome")
dev.off()

library(scales)

postscript(file = "NumberPlotsBiome.eps", height = 4, width = 7, paper
= "special", onefile = FALSE, horizontal = FALSE, pointsize=12)
#pdf("NumberSpeciesBiome.pdf", height = 4, width = 8)
ggplot(mdat2, aes(variable, value, fill=Schulz_Bio)) + 
  geom_bar(stat="identity", position="dodge")+
      scale_y_continuous(name="Number of plots", labels = comma) +
  scale_x_discrete(name="Biomes") +
ggtitle("Number of plots per biome") 
dev.off()
                                        
# (b) wie hoch ist die Plotdichte (plots pro 100 km²) in jedem der
Biome
# 

biome.area <-
read.csv("/home/oliver/Dokumente/PhD/PostPhD/IDiv/sDiv/sPlot/Analyses/Data/GIS/SchulzBiomes/biome.area.csv")

str(biome.area)

DTarea <- data.table(biome.area)
area.biome <-  DTarea[,list(Area = sum(Area.N.19.11)),
by=Schulz_Bio.C.31]

no.plots.biome$Area <- area.biome$Area

no.plots.biome
                        Schulz_Bio No.plots         Area
#1:  1 Tropics with year-round rain     1470 7.393349e+13
#2:      2 Tropics with summer rain     5407 5.529372e+13
#3:    3 Dry tropics and subtropics     9998 1.434031e+14
#4:   4 Subtropics with winter rain    73185 2.594170e+13
#5: 5 Subtrop. with year-round rain    12179 3.432313e+13
#6:        6 Temperate midlatitudes   588419 6.463106e+13
#7:              7 Dry midlatitudes     5644 1.565747e+13
#8:                   8 Boreal zone     8133 2.331021e+13
#9:       9 Polar and subpolar zone     1378 6.264147e+13

no.plots.biome$plot.dens <-
no.plots.biome$No.plots/no.plots.biome$Area

no.plots.biome <- as.data.frame(no.plots.biome)

library(dplyr)
arrange(no.plots.biome, Area)

# (c) wie viele Arten haben wir in den Plots der Biome
# join splot with biomes
names(biome.xy)[3] <- "PlotObservationID"
biome.xy$PlotObservationID <- as.character(biome.xy$PlotObservationID)
splot.species.stand$PlotObservationID <-
as.character(splot.species.stand$PlotObservationID)

any(is.na(splot.species.stand$PlotObservationID))

splot.biome <- left_join(splot.species.stand, biome.xy[,c(3:5,8)])

# export coordinates for julia joswig:
splot.xy <- biome.xy[,c(3:5)]
save(splot.xy, file = "splot.xy.Rdata")
###

DTsplot <- data.table(splot.biome)

species.biome <-  DTsplot[,list(No.spec =
length(unique(StandSpeciesName))), by=Schulz_Bio]
species.biome

species.biome <- as.data.frame(species.biome)

mdat2 <- melt(species.biome, id.vars="Schulz_Bio")
head(mdat2)

postscript(file = "NumberSpeciesBiome.eps", height = 4, width = 7,
paper = "special", onefile = FALSE, horizontal = FALSE, pointsize=12)
#pdf("NumberSpeciesBiome.pdf", height = 4, width = 8)
ggplot(mdat2, aes(variable, value, fill=Schulz_Bio)) + 
  geom_bar(stat="identity", position="dodge")+
    xlab("Biomes") +
  ylab("Number of species")+
  ggtitle("Number of species per biome")
dev.off()


# (d) wie ist die Trait-Abdeckung der Arten pro Biom

# number of all species within plots:
splot.biome <- left_join(splot.species.stand, biome.xy[,c(3:5,8)])
DTsplot <- data.table(splot.biome)
species.biome <-  DTsplot[,list(No.spec =
length(unique(StandSpeciesName))), by=Schulz_Bio]
species.biome

# number of TRY species within plots:

splot.biome.try <- left_join(splot.species.try, biome.xy[,c(3:5,8)])
DTsplot <- data.table(splot.biome.try)
species.biome.try <-  DTsplot[,list(No.spec =
length(unique(StandSpeciesName))), by=Schulz_Bio]
species.biome.try

species.biome.all.try <- cbind(species.biome, species.biome.try)
species.biome.all.try <- as.data.frame(species.biome.all.try)
species.biome.all.try <- species.biome.all.try[,-3]

names(species.biome.all.try)[2:3] <- c("no.spec.all", "no.spec.try")
species.biome.all.try$match <-
100*(species.biome.all.try$no.spec.try/species.biome.all.try$no.spec.all)

write.csv(species.biome.all.try, file = "species.biome.all.try.csv")

mdat2 <- melt(species.biome.all.try[, c(1,4)], id.vars="Schulz_Bio")
head(mdat2)

postscript(file = "TraitMatchBiome.eps", height = 4, width = 7, paper
= "special", onefile = FALSE, horizontal = FALSE, pointsize=12)
#pdf("NumberSpeciesBiome.pdf", height = 4, width = 8)
ggplot(mdat2, aes(variable, value, fill=Schulz_Bio)) + 
  geom_bar(stat="identity", position="dodge")+
    xlab("Biomes") +
  ylab("Percentage match")+
  ggtitle("Match sPlot and TRY")
dev.off()

## phylogeny for splot
# load tank.tree:

library(ape)
tank.tree <-
read.tree("/home/oliver/Dokumente/PhD/PostPhD/IDiv/sDiv/sPlot/Analyses/Data/Phylogeny/2/PhylogeneticResources/Vascular_Plants_rooted.dated.tre")
tank.tree$tip.label[1:10]

# prune the tree to the species in splot:
load("splot.species.stand.Rdata")
str(splot.species.stand)
length(unique(splot.species.stand$StandSpeciesName))
nam.splot <- unique(splot.species.stand$StandSpeciesName)
nam.splot[1:10]
# identify the species in splot which are not in the tank tree
# add those species are congeners

nam.splot <- gsub(" ", "_", nam.splot)
length(nam.splot) 
nam.splot[1:10]

index <- which(nam.splot %in% tank.tree$tip.label)
nam.splot[index]

index <- which(tank.tree$tip.label %in% nam.splot)

tank.tree.splot <- tank.tree[tank.tree$tip.label[index]]
str(tank.tree.splot)

tips <- 
    
tree.con <- congeneric.merge(nam.splot[20000:30000], tank.tree)
tree.con2 <- congeneric.merge(nam.splot[10000:20000], tree.con)
tree.con3 <- congeneric.merge(nam.splot[8000:10000], tree.con2)
tree.con4 <- congeneric.merge(nam.splot[6000:8000], tree.con3)


tree.con4 <- congeneric.merge(nam.splot[30011:30030], tree.con3)



tree.con4 <- congeneric.merge(nam.splot[6000:8000], tree.con3)


any(is.na(nam.splot))
length(nam.splot)


# tree grafting function by brody:
#For each species in kew, check to see if it's on the tree. If it is
not,
    #graft it next to a random congener, if one exists

    #In case there's an effect of the order things are grafted,
probably wise
    #to randomly reorder the i index each time
    gtree = tank.tree
spList <- nam.splot[6000:8000]
    for(i in sample(1:length(spList),length(spList),replace = F))
        {
        #Update the genus list, because new tips should be graftable
onto previous new tips
        gtreeGenera =
unlist(lapply(strsplit(gtree$tip,"_"),function(i){i[[1]]}))
        
        #If the species isn't on the tree but a congener is
        if(!spList[i] %in% gtree$tip & strsplit(spList[i],"_")[[1]][1]
%in% gtreeGenera)
            {
            branchName = gtree$tip[resample(which(gtreeGenera ==
strsplit(spList[i],"_")[[1]][1]),1)]
            newtree = rtree(2)
            newtree$tip.label = c(branchName,spList[i])
           
            edgeL = gtree$edge.length[which.edge(gtree,branchName)]
           
            #Splice in at a random depth between 0 and 1
            depth = runif(1,0,1)
            newtree$edge.length =
depth*newtree$edge.length*edgeL/max(newtree$edge.length)

            whereToGraft = which(gtree$tip == branchName)
            gtree = bind.tree(gtree,newtree,where =
whereToGraft,position = edgeL*depth)

            #The grafting process duplicates the branchName tip. Drop
one of them.
            gtree = drop.tip(gtree, which(gtree$tip == branchName)[1])

            #Just to make sure things look good throughout
            #print(paste(spList[i]," with ",branchName))
            }
        }

    # store the gtree for safety
    store = gtree

resample <- function(x, ...) x[sample.int(length(x), ...)]
###################

# CWM covariation across biomes
# load x-y coords biomes
load("biome.xy.Rdata")

dim(biome.xy)
str(biome.xy)
names(biome.xy)[3] <- "PlotObservationID"

# load CWMs
load("CWM.splot.Rdata")
str(CWM.splot)
names(CWM.splot)

library(dplyr)
biome.xy.cwm <- left_join(biome.xy[,c(3:5,8)], CWM.splot[,c(1:4)])
names(biome.xy.cwm)

library(data.table)
DTbiome <- data.table(biome.xy.cwm[,c(1,4:7)])
mean.sla.biome <-  DTbiome[,list(mean.sla.cwm = mean(CWM.SLA,
na.rm=TRUE)), by=Schulz_Bio]               
mean.sla.biome

# plot covariation 
library(reshape2)
mdat2 <- melt(biome.xy.cwm[,c(4,6)], id.vars="Schulz_Bio")
mdat3 <- melt(biome.xy.cwm[,c(4,7)], id.vars="Schulz_Bio")
mat2.3 <- cbind(mdat2[,c(1,3)], mdat3[,3])
names(mat2.3)[2:3] <- c("PlantHeight", "SeedMass")
head(mat2.3)

library(ggplot2)

postscript(file = "PlantHeightSeedMassBiome.eps", height = 2.3, width
= 15, paper = "special", onefile = FALSE, horizontal = FALSE,
pointsize=12)
qplot(PlantHeight, SeedMass, data=mat2.3, facets = . ~ Schulz_Bio) +
geom_smooth()
dev.off()

# load bioclim

library(colbycol)
bioclim <-
cbc.read.table("/home/oliver/Dokumente/PhD/PostPhD/IDiv/sDiv/sPlot/Analyses/Data/Environment/Bioclim/sPlot_bioClim.csv",
just.read = c(1:3))
bioclim <- as.data.frame(bioclim)

bioclim <-
read.csv("/home/oliver/Dokumente/PhD/PostPhD/IDiv/sDiv/sPlot/Analyses/Data/Environment/Bioclim/sPlot_bioClim.csv",
head=T)
str(bioclim)

str(biome.xy.cwm)
biome.xy.cwm$PlotObservationID <-
as.factor(biome.xy.cwm$PlotObservationID)
bioclim$PlotObservationID <- as.factor(bioclim$PlotObservationID)
biome.xy.cwm <- left_join(biome.xy.cwm, bioclim[,c(1,29)])
names(biomes)
biome.xy.cwm$BIO_1 <- as.numeric(biome.xy.cwm$BIO_1)

mdat2 <- melt(biome.xy.cwm[,c(4,6)], id.vars="Schulz_Bio")
mdat3 <- melt(biome.xy.cwm[,c(4,8)], id.vars="Schulz_Bio")
mat2.3 <- cbind(mdat2[,c(1,3)], mdat3[,3])
names(mat2.3)[2:3] <- c("CWM.SLA", "MAT")
head(mat2.3)

postscript(file = "CWM.SLA.MATBiome.eps", height = 2.3, width = 15,
paper = "special", onefile = FALSE, horizontal = FALSE, pointsize=12)
qplot(MAT, CWM.SLA, data=mat2.3, facets = . ~ Schulz_Bio) +
geom_smooth()
dev.off()

names(mat2.3)
hist(mat2.3$MAT)

# plot phylogeny:
phylo.splot.try <-
read.tree("/home/oliver/Dokumente/PhD/PostPhD/IDiv/sDiv/sPlot/Analyses/Data/Phylogeny/sPlotPhylo/phylo.tree.splot.try.11870.tre")

pdf(file = "phylo.splot.try.11870.pdf", height = 90, width = 90)
plot(phylo.splot.try, "f", cex = .1, edge.width = .3, label.offset =
.1)
dev.off()

##
phylo.splot.stand <-
read.tree("/home/oliver/Dokumente/PhD/PostPhD/IDiv/sDiv/sPlot/Analyses/Data/Phylogeny/sPlotPhylo/phylo.tree.splot.stand.26426.tre")

pdf(file = "phylo.tree.splot.stand.26426.pdf", height = 90, width =
90)
plot(phylo.splot.stand, "f", cex = .1, edge.width = .3, label.offset =
.1)
dev.off()


################################################
# get families for the 12000 species
names(TRY.2.0.all.gapfilled.ln.acc.names)
names(TRY.2.0.all.gapfilled.ln.acc.names)

try.spec.fam <- TRY.2.0.all.gapfilled.ln.acc.names[,c(3,4)]
head(try.spec.fam) 
str(try.spec.fam) 

try.spec.fam[,1] <- as.character(try.spec.fam[,1])
try.spec.fam[,2] <- as.character(try.spec.fam[,2])

# join with backbone:

# taxonomic backbone to TRY:
backbone.small <- read.csv("backbone.small.csv")
head(backbone.small)

backbone.small$names.sPlot.TRY.original <-
as.character(backbone.small$names.sPlot.TRY.original)
backbone.small$Final.names.3 <-
as.character(backbone.small$Final.names.3)

str(try.spec.fam)

names(try.spec.fam)[1] <- "names.sPlot.TRY.original"

try.fam <- left_join(try.spec.fam, backbone.small)
str(try.fam)
# take try.fam[,5] # final.names.3

# merge with splot.species.try
load("splot.species.try.Rdata")
head(splot.species.try)
str(splot.species.try)

# join try.fam on unique.splot.names based on standardized names


names(splot.species.try)[2] <- "Final.names.3"
splot.species.try$Final.names.3 <-
as.character(splot.species.try$Final.names.3)

str(splot.species.try)

splot.try.nam <-
as.data.frame(unique(splot.species.try$Final.names.3))

names(splot.try.nam)[1] <- "Final.names.3"
splot.try.nam$Final.names.3 <-
as.character(splot.try.nam$Final.names.3)

splot.try.fam <- plyr::join(splot.try.nam,
splot.species.stand[,c(2,6)], match = "first")

str(splot.try.fam)
splot.try.fam[1:100,1]
head(splot.try.fam)

save(splot.try.fam, file = "splot.try.fam.Rdata")

###################
# linking TRY plant growth forms:

names(ID.names)[13:17]
unique(ID.names$LeafType) 
unique(ID.names$PlantGrowthForm) 
unique(ID.names$LeafPhenology) 
unique(ID.names$PhotosyntheticPathway) 
unique(ID.names$Woodiness) 


TRY.2.0.all.gapfilled.ln.acc.names$AccSpeciesName <-
as.character(TRY.2.0.all.gapfilled.ln.acc.names$AccSpeciesName)

# just select the categorical traits
try.obs.lifeform <- TRY.2.0.all.gapfilled.ln.acc.names[, c(3,5:9)]

names(try.obs.lifeform)[1] <- "Final.names.3"

splot.try.nam2 <- cbind(splot.try.nam, splot.try.nam)


try.obs.lifeform.stand <- left_join(try.obs.lifeform, splot.try.nam)
str(try.obs.lifeform.stand)



#merge to stand.names
try.spec.cat.traits <- TRY.2.0.all.gapfilled.ln.acc.names[,c(3,5:9)]
head(try.spec.cat.traits) 
str(try.spec.cat.traits) 

names(try.spec.cat.traits)[1] <- "names.sPlot.TRY.original"

try.spec.cat.traits.stand <- left_join(try.spec.cat.traits,
backbone.small)
str(try.spec.cat.traits.stand)

try.growth.stand <- try.spec.cat.traits.stand[,c(10,2)]

try.growth.stand.tab <-
as.data.frame.matrix(table(try.growth.stand[,c(1,2)]))
head(try.growth.stand.tab)
str(try.growth.stand.tab)

try.growth.stand.tab$names <- rownames(try.growth.stand.tab)

# match it with the species that occur in splot and TRY:

nam.splot.try <- unique(splot.species.try$Final.names.3)
length(nam.splot.try)

nam.splot.try <- cbind(nam.splot.try, nam.splot.try)
nam.splot.try <- as.data.frame(nam.splot.try)
str(nam.splot.try)
names(nam.splot.try)[2] <- "names"
nam.splot.try$names <- as.character(nam.splot.try$names)


splot.try.gro <- left_join(nam.splot.try, try.growth.stand.tab)
str(splot.try.gro)
splot.try.gro[1:5,1:5]

splot.try.gro <- splot.try.gro[,-1]
head(splot.try.gro)
splot.try.gro[, c(1:3)]
splot.try.growthform <- splot.try.gro

save(splot.try.growthform, file = "splot.try.growthform.Rdata")


# extract TRY woodyness information
# (and for other categorical traits)

try.woody.stand <- try.spec.cat.traits.stand[,c(10,6)]
str(try.woody.stand)
unique(try.woody.stand$Woodiness)

index.na <- which(try.woody.stand$Woodiness=="")
try.woody.stand$Woodiness[index.na] <- NA

try.woody.stand$Woodiness <- as.character(try.woody.stand$Woodiness)

index.non.woody <- which(try.woody.stand$Woodiness=="non-woody/woody
rootstock")
try.woody.stand$Woodiness[index.non.woody] <- "non.woody"
unique(try.woody.stand$Woodiness)
head(try.woody.stand)

names(try.woody.stand)[1] <- "names.sPlot.TRY.original"
summary(try.woody.stand)
str(try.woody.stand)

try.spec.woody.traits.stand <- try.woody.stand
# merge with sPlot-species list:
try.spec.woody.traits.stand <- left_join(try.spec.woody.traits.stand,
backbone.small)
str(try.spec.woody.traits.stand)

try.woody.stand <- try.spec.woody.traits.stand[,c(6,2)]
str(try.woody.stand)

# match it with the species that occur in splot and TRY:

nam.splot.try <- unique(splot.species.try$Final.names.3)
length(nam.splot.try)

nam.splot.try <- cbind(nam.splot.try, nam.splot.try)
nam.splot.try <- as.data.frame(nam.splot.try)
str(nam.splot.try)
names(nam.splot.try)[2] <- "names"
nam.splot.try$names <- as.character(nam.splot.try$names)

head(nam.splot.try)
str(nam.splot.try)


names(nam.splot.try)[2] <- "Final.names.3"
splot.try.wood <- plyr::join(nam.splot.try, try.woody.stand, match =
"first")

str(splot.try.wood)
head(splot.try.wood)

# create two splot files: 
# 1) splot.woody
# 2) splot.non.woody

str(splot.species.try)

# woody
index.splot.wood <- which(splot.species.try$Final.names.3 %in%
splot.try.wood$Final.names.3[splot.try.wood$Woodiness == "woody"])
length(index.splot.wood)

splot.species.try.woody <- splot.species.try[index.splot.wood, ]
head(splot.species.try.woody)

save(splot.species.try.woody, file = "splot.species.try.woody.Rdata")


# non.woody
index.splot.non.wood <- which(splot.species.try$Final.names.3 %in%
splot.try.wood$Final.names.3[splot.try.wood$Woodiness == "non.woody"])
length(index.splot.non.wood)

splot.species.try.non.woody <- splot.species.try[index.splot.non.wood,
]
head(splot.species.try.non.woody)

save(splot.species.try.non.woody, file =
"splot.species.try.non.woody.Rdata")

# 3) percentage of woody species in a plot

##  to do

# 13693421  
load("TRY.mean.sd.splot.Rdata")
load("splot.species.try.non.woody.Rdata")
dim(TRY.mean.sd.splot)
str(splot.species.try.non.woody)
names(splot.species.try.non.woody)[2] <- "StandSpeciesName"

library(dplyr)
splot.try <- left_join(splot.species.try.non.woody,
TRY.mean.sd.splot[,c(1,3:20)])
gc()
dim(splot.try)
head(splot.try)
names(splot.try)

library(data.table)
DT <- data.table(splot.try[,c(1,3:21)])
head(DT)
gc()
tables()

CWM.splot.non.woody <-  DT[,list(CWM.SLA.non.woody =
weighted.mean(SLA.mean, Cover..), 
                       CWM.PlantHeight.non.woody =
weighted.mean(PlantHeight.mean, Cover..), 
                       CWM.SeedMass.non.woody =
weighted.mean(SeedMass.mean, Cover..),
                       CWM.LDMC.non.woody = weighted.mean(LDMC.mean,
Cover..),
                       CWM.StemDens.non.woody =
weighted.mean(StemDens.mean, Cover..),
                       CWM.LeafArea.non.woody =
weighted.mean(LeafArea.mean, Cover..),
                       CWM.LeafN.non.woody = weighted.mean(LeafN.mean,
Cover..),
                       CWM.LeafP.non.woody = weighted.mean(LeafP.mean,
Cover..),
                       CWM.LeafNperArea.non.woody =
weighted.mean(LeafNperArea.mean, Cover..),
                       CWM.Leaffreshmass.non.woody =
weighted.mean(Leaffreshmass.mean, Cover..),
                       CWM.LeafNPratio.non.woody =
weighted.mean(LeafNPratio.mean, Cover..),
                       CWM.LeafC.perdrymass.non.woody =
weighted.mean(LeafC.perdrymass.mean, Cover..),
                       CWM.Leaf.delta.15N.non.woody =
weighted.mean(Leaf.delta.15N.mean, Cover..),
                       CWM.Stem.cond.dens.non.woody.non.woody =
weighted.mean(Stem.cond.dens.mean, Cover..),
                       CWM.Seed.num.rep.unit.non.woody =
weighted.mean(Seed.num.rep.unit.mean, Cover..),
                       CWM.Wood.vessel.length.non.woody =
weighted.mean(Wood.vessel.length.mean, Cover..),
                       CWM.Seed.length.non.woody =
weighted.mean(Seed.length.mean, Cover..),
                       CWM.Disp.unit.leng.non.woody =
weighted.mean(Disp.unit.leng.mean, Cover..)

                       ), 
                 
                 by=PlotObservationID]


str(CWM.splot.non.woody)
dim(CWM.splot.non.woody)
CWM.splot.non.woody <- as.data.frame(CWM.splot.non.woody)
save(CWM.splot.non.woody, file = "CWM.splot.non.woody.Rdata")
write.csv(CWM.splot.non.woody, file = "CWM.splot.non.woody.csv")


# join splot.try with woody.non.woody CWM
# seperate file for bioclim for the same plots:
load("CWM.splot.woody.Rdata")
load("CWM.splot.non.woody.Rdata")
load("CWM.splot.Rdata")

load("splot.species.try.Rdata")
load("TRY.mean.sd.splot.Rdata")

names(splot.species.try)
names(TRY.mean.sd.splot)
names(CWM.splot)
dim(CWM.splot)

dim(splot.species.try)

gc()
library(dplyr)
CWM.wood <- left_join(CWM.splot[,c(1:2)], CWM.splot.woody)
dim(CWM.wood)

CWM.wood.non.wood <- left_join(CWM.wood, CWM.splot.non.woody)
gc()

CWM.wood.non.wood <- CWM.wood.non.wood[,c(-2)]
save(CWM.wood.non.wood, file = "CWM.wood.non.wood.Rdata")


dim(CWM.wood.non.wood)
names(CWM.wood.non.wood)
CWM.wood.non.wood


# match bioclim to woody-non.woody:

bioclim <-
read.csv("/home/oliver/Dokumente/PhD/PostPhD/IDiv/sDiv/sPlot/Analyses/Data/Environment/Bioclim/sPlot_bioClim_temp_prec.csv",
sep ="\t")
str(bioclim)
dim(bioclim)
bioclim$PLOTOBSERV <- as.character(bioclim$PLOTOBSERV)

names(bioclim)[1] <- "PlotObservationID"

index <- which(bioclim$PlotObservationID %in%
CWM.wood.non.wood$PlotObservationID)

bioclim.woody.non.woody <- bioclim[index, ]
dim(bioclim.woody.non.woody)

save(bioclim.woody.non.woody, file = "bioclim.woody.non.woody.Rdata")
load("bioclim.woody.non.woody.Rdata")
names(bioclim.woody.non.woody)


## sPlot 2.0 
library(data.table)
path.sPlot <- "/home/oliver/Dokumente/PhD/PostPhD/IDiv/sDiv/sPlot/Analyses/Data/Species/sPlot/sPlot_14_04_2015/"

# read species data (takes ~2 min on my 64bit, 2.5GHz machine)

splot.species.DT <- fread("/home/oliver/Dokumente/PhD/PostPhD/IDiv/sDiv/sPlot/Analyses/Data/Species/sPlot/sPlot_14_04_2015/sPlot_14_4_2015_species.csv")
dim(splot.species.DT)
head(splot.species.DT)

splot.species <- read.csv(paste(path.sPlot, "sPlot_14_4_2015_species.csv", sep = ""), sep = "\t")
gc()
dim(splot.species)
length(unique(splot.species$PlotObservationID))
# 24.241.941       11

# old
# 24.235.008
summary(splot.species)
str(splot.species)

colnames(splot.species)
length(unique(splot.species$Turboveg2.concept))
# 93917
length(unique(splot.species$Matched.concept))
# 87424

splot.species$Turboveg2.concept <-
as.character(splot.species$Turboveg2.concept)
splot.species$Matched.concept<-
as.character(splot.species$Matched.concept)



Match.conc.unique <-
cbind(sort(unique(splot.species$Matched.concept)),
unique(splot.species$Matched.concept))

colnames(Match.conc.unique) <- c("Match.conc.sort", "Match.conc")

head(Match.conc.unique)
dim(Match.conc.unique)

write.csv(Match.conc.unique, file = "Match.conc.unique.csv")

# in european data, check for differences between TV.2 names and
matched concept:

paste(unique(splot.species$Taxonomy)[62:89], sep = "")


splot.species.euro <- splot.species[which(splot.species$Taxonomy %in%
unique(splot.species$Taxonomy)[62:89]), ]

splot.eur.sample <- splot.species.euro[sample(1:20159421, 100000),
c(2,5,6)]


write.csv(splot.eur.sample, file = "splot.eur.sample.csv")


dim(splot.species.euro)

colnames(splot.species.euro)


# extract excerpt from sPlot Europe:

Europe                      
[63] Austria                      Balkan                      
[65] Euskadi                      Floranld_2013               
[67] Britain                      Bulgaria                    
[69] Croatia                      C_Europe_Croatia            
[71] Czechia_slovakia_2010        Europe_lenoir               
[73] France_sophy                 Germansl 1.2                
[75] Greece                       Natura                      
[77] C_Europe_Hungary             Italy_conti                 
[79] Latvia                       Lithuania                   
[81] C_Europe_Macedonia           Poland                      
[83] Romania                      C_Europe_Serbia             
[85] Slovenia                     Spain_sivim                 
[87] Switzerland                  Turkey                      
[89] Vegitaly       

# import "weird species" list:

weird.names <-
read.csv("/home/oliver/Dokumente/PhD/PostPhD/IDiv/sDiv/sPlot/Analyses/Code/Weird.names.match.conc.csv",
colClasses = "character")

weird.names.unique <- unique(weird.names)

write.csv(weird.names.unique, file = "splot.weird.names.csv")

dim(weird.names.unique)
str(weird.names.unique)

splot.species.weird <-
splot.species[which(splot.species$Matched.concept %in%
weird.names.unique$weird.names), c(1,2,6,9)]

head(splot.species.weird)
tail(splot.species.weird)

dim(splot.species.weird)


splot.species.weird[1:100,1:3]

write.csv(splot.species.weird, file = "splot.species.weird.csv")

splot.species[c(675115,675145,675192), c(1,2,6,9)]


#####################  


### load header data:

path.sPlot <-
"/home/oliver/Dokumente/PhD/PostPhD/IDiv/sDiv/sPlot/Analyses/Data/Species/sPlot/sPlot_14_04_2015/"

# read species data (takes ~2 min on my 64bit, 2.5GHz machine)
splot.header <- read.csv(paste(path.sPlot,
"sPlot_header_no_locality.csv", sep = ""), sep = "\t", quote = "")

splot.header.DT <- fread(paste(path.sPlot,
"sPlot_header_no_locality.csv", sep = ""))
                      
dim(splot.header.DT)
                  
gc()
                      
dim(splot.header)
length(unique(splot.header$PlotObservationID))
# 24.241.941       11

# old
# 24.235.008
summary(splot.header)
str(splot.header)
colnames(splot.header)

library(colbycol)

splot.header <-
cbc.read.table("/home/oliver/Dokumente/PhD/PostPhD/IDiv/sDiv/sPlot/Analyses/Data/Species/sPlot/sPlot_13_04_2015/sPlot_13_04_2015_header.csv",
just.read = c(1,2))
splot.header <- as.data.frame(splot.header)
dim(splot.header)


require(data.table)
DT <-
fread("/home/oliver/Dokumente/PhD/PostPhD/IDiv/sDiv/sPlot/Analyses/Data/Species/sPlot/sPlot_14_04_2015/sPlot_14_04_2015_header.csv")


test <-
read.csv2(file("/home/oliver/Dokumente/PhD/PostPhD/IDiv/sDiv/sPlot/Analyses/Data/Species/sPlot/sPlot_14_04_2015/sPlot_14_04_2015_header.csv",
encoding="UTF-8"), sep = "\t")

dim(test)


## Stephan's header import test

library(data.table)
path.sPlot <-
"/home/oliver/Dokumente/PhD/PostPhD/IDiv/sDiv/sPlot/Analyses/Data/Species/sPlot/sPlot_14_04_2015/"
splot.header <- fread(paste(path.sPlot, "sPlot_header.csv", sep = "",
sep2 = ""))
nrow(splot.header)

system.time(
splot.header <- read.csv(paste(path.sPlot, "sPlot_header.csv", sep =
""), sep = "\t", na.strings=c("","NA"), fileEncoding = "UTF-8", quote
= "")
    )
nrow(splot.header)


###########################################################
## generate taxonomic backbone for sPlot 2.0 and TRY 3.0
##

# 1) combine unique names lists of species in sPlot 2.0 and TRY 3.0:
# first check whether some of the weird names can be resolved -> no,
not really

splot.species <- read.csv(paste(path.sPlot,
"sPlot_14_4_2015_species.csv", sep = ""), sep = "\t")
gc()

dim(splot.species)
length(unique(splot.species$PlotObservationID))
# 24.241.941       11

# old
# 24.235.008
summary(splot.species)
str(splot.species)

colnames(splot.species)
length(unique(splot.species$Turboveg2.concept))
# 93917
length(unique(splot.species$Matched.concept))
# 87424

splot.species$Turboveg2.concept <-
as.character(splot.species$Turboveg2.concept)
splot.species$Matched.concept<-
as.character(splot.species$Matched.concept)

# read in TRY 3.0 species list
try3.species <-
read.csv("/home/oliver/Dokumente/PhD/PostPhD/IDiv/sDiv/sPlot/Analyses/Data/Species/TRY/Species/TRY30_Gapfilling2015_Species.csv")
str(try3.species)
try3.species$Species <- as.character(try3.species$Species)

# combine species lists into one unified species list:
spec.list.TRY.sPlot <-
sort(unique(c(as.character(splot.species$Matched.concept),
as.character(try3.species$Species))))
length(spec.list.TRY.sPlot)
# 122901

spec.list.TRY.sPlot.2 <- cbind(spec.list.TRY.sPlot,
spec.list.TRY.sPlot, spec.list.TRY.sPlot)
str(spec.list.TRY.sPlot.2)
dim(spec.list.TRY.sPlot.2)
spec.list.TRY.sPlot.2 <- as.data.frame(spec.list.TRY.sPlot.2)

spec.list.TRY.sPlot.2[,1] <- as.character(spec.list.TRY.sPlot.2[,1])
spec.list.TRY.sPlot.2[,2] <- as.character(spec.list.TRY.sPlot.2[,2])
spec.list.TRY.sPlot.2[,3] <- as.character(spec.list.TRY.sPlot.2[,3])

colnames(spec.list.TRY.sPlot.2) <- c("names.sPlot.TRY","names.corr.string", "sPlot.TRY")
write.csv(spec.list.TRY.sPlot.2, file = "spec.list.TRY3.sPlot2.csv")

# 2) add information on whether names come from sPlot (1), TRY (0) or
both (2)

# which species are in sPlot 2.0
spec.list.TRY.sPlot.2$sPlot.TRY[which(spec.list.TRY.sPlot.2$names.sPlot.TRY
%in% unique(splot.species$Matched.concept))] <- "S"

# which species are in TRY 3.0
spec.list.TRY.sPlot.2$sPlot.TRY[which(spec.list.TRY.sPlot.2$names.sPlot.TRY
%in% unique(try3.species$Species))] <- "T"

# which species are in sPlot 2.0 and TRY 3.0

spec.list.TRY.sPlot.2$sPlot.TRY[which(spec.list.TRY.sPlot.2$names.sPlot.TRY
%in% unique(try3.species$Species) &
spec.list.TRY.sPlot.2$names.sPlot.TRY %in%
unique(splot.species$Matched.concept))] <- "ST"

table(spec.list.TRY.sPlot.2$sPlot.TRY)

#   S    ST     T 
# 62628 24796 35477 

write.csv(spec.list.TRY.sPlot.2, file = "spec.list.TRY3.sPlot2.csv")

spec.list.TRY.sPlot.2 <- read.csv("spec.list.TRY3.sPlot2.csv")

# 3) do some rough a-priori cleaning
# also check Florian's files again on weird species names: does it
take care of:
# - voucher species (contain)
# - cf. species
# - species with strange brackets and special characters

# some code from Florian Jansen:
# check for weird.names.csv first
splot.weird.names <-
read.csv("/home/oliver/Dokumente/PhD/PostPhD/IDiv/sDiv/sPlot/Analyses/Code/splot.weird.names.csv")
str(splot.weird.names)

OriginalNames <- as.character(spec.list.TRY.sPlot.2$names.sPlot.TRY)
OriginalNames <- as.character(splot.weird.names$weird.names)

source('tax_add.r')
source('TPLck.r')
source('gbif_parse.r')
require(pbapply)
options(stringsAsFactors=FALSE)

## Name cleaning (spelling of ranks, name additions etc.)
OriginalNames <- gsub('*', '', OriginalNames, fixed=TRUE)
OriginalNames <- gsub('cf. ', '', OriginalNames, fixed=TRUE)
OriginalNames <- gsub('Cf. ', '', OriginalNames, fixed=TRUE)
OriginalNames <- gsub('[', '', OriginalNames, fixed=TRUE)
OriginalNames <- gsub(']', '', OriginalNames, fixed=TRUE)
OriginalNames <- gsub(' x ', ' ', OriginalNames, fixed=TRUE)
OriginalNames <- gsub('Ã—', '', OriginalNames, fixed=TRUE)
OriginalNames <- gsub('aff ', '', OriginalNames, fixed=TRUE)
OriginalNames <- gsub('(', '', OriginalNames, fixed=TRUE)
OriginalNames <- gsub(')', '', OriginalNames, fixed=TRUE)
OriginalNames <- gsub(' cf ', ' ', OriginalNames, fixed=TRUE)
OriginalNames <- gsub(' aff. ', ' ', OriginalNames, fixed=TRUE)
OriginalNames <- gsub('c‚e', 'ceae', OriginalNames, fixed=TRUE)
OriginalNames <- gsub('    ', ' ', OriginalNames, fixed=TRUE)
OriginalNames <- gsub('   ', ' ', OriginalNames, fixed=TRUE)
OriginalNames <- gsub('  ', ' ', OriginalNames, fixed=TRUE)
OriginalNames <- gsub('x-', '', OriginalNames, fixed=TRUE)
OriginalNames <- gsub('X-', '', OriginalNames, fixed=TRUE)
OriginalNames <- gsub('like ', '', OriginalNames, fixed=TRUE)  
OriginalNames <- gsub(',', '', OriginalNames, fixed=TRUE)  


library(stringr)
firstWordWithNumbers <- grepl('[0-9]', word(OriginalNames, 1))
numberOfWords <- sapply(gregexpr("\\W+", OriginalNames), length) + 1
OriginalNames[firstWordWithNumbers & numberOfWords > 1] <-
sapply(OriginalNames[firstWordWithNumbers & numberOfWords > 1],
function(x) substr(x, start=regexpr(pattern =' ', text=x)+1,
stop=nchar(x)))

CleanedNames <- taxname.abbr(OriginalNames)
dup <- duplicated(CleanedNames)
sum(dup)

noDup <- iconv(CleanedNames[!dup], 'UTF-8', 'UTF-8', sub='')
## Name parsing by GBif name parser
(http://www.gbif.org/developer/species#parser)
# ParsedNames <- gbif_parse(noDup[1:length(noDup)])
ParsedNames1 <- gbif_parse(noDup[1:40000])
ParsedNames2 <- gbif_parse(noDup[40001:length(noDup)])
intersect <- c("scientificName", "type",
"authorsParsed","canonicalName", "canonicalNameWithMarker",
"canonicalNameComplete","genusOrAbove","specificEpithet",
"infraSpecificEpithet", "rankMarker", "notho", "sensu", "authorship",
"infraGeneric","cultivarEpithet")
ParsedNames <- rbind(ParsedNames1[,intersect],
ParsedNames2[,intersect])
write.csv(ParsedNames, file='ParsedNames.csv')
# write.csv(ParsedNames1, file='ParsedNames.csv')


table(ParsedNames$type)
## Fuzzy name matching by GBIF name matching for not wellformed
notwellformed <- ParsedNames$type != 'WELLFORMED'

matchednames <- gbif_match(ParsedNames$scientificName[notwellformed])

ParsedNames3 <- gbif_parse(matchednames)

combined <- ParsedNames
combined[notwellformed,] <- ParsedNames3[notwellformed,]
GBIF_Names <- cbind(OriginalNames[!dup], CleanedNames[!dup], combined)
GBIF_Names <- GBIF_Names[GBIF_Names$OriginalNames[!dup] != '',]
write.csv(GBIF_Names, file='GBIF_Names.csv')
# there is a problem here, species and genus names do not match up

GBIF_Names <- read.csv('GBIF_Names.csv')
genus = as.character(GBIF_Names$genusOrAbove)
species =
as.character(GBIF_Names$specificEpithet[!is.na(GBIF_Names$specificEpithet)])
# infrasp = as.character(ParsedNames$infraSpecificEpithet) ## no
infraspecific differenciation
genus = as.character(ParsedNames$genusOrAbove)
species = as.character(ParsedNames$specificEpithet)

# here comes the TPL bit
d <- paste(genus, species)
tpl <- do.call("rbind", pblapply(d, TPLck, corr = FALSE, diffchar = 2,
max.distance = 1, infra = FALSE, version = '1.1', encoding = "UTF-8"))

table(tpl$Plant.Name.Index)

# Friday:
# test whether TNRS (and associated probabilies) can be taken instead
of all the GBIF cleaning steps above
# ! it seems that sending a "string-cleaned" to TNRS does a much
better job than doing the single GBIF cleaning steps above

# correct some species that cause TPL to crash manually:
spec.list.TRY.sPlot[which(spec.list.TRY.sPlot[,2]=="Astragalus
psoraloides"),2] <- "Astragalus gjunaicus"
spec.list.TRY.sPlot[which(spec.list.TRY.sPlot[,2]=="Hedysarum
mackenzii"),2] <- "Hedysarum dasycarpum"

# run TNRS


##
CleanedNames[which(CleanedNames=="Astragalus psoraloides")] <-
"Astragalus gjunaicus"
CleanedNames[which(CleanedNames=="Hedysarum mackenzii")] <- "Hedysarum
dasycarpum"

save(CleanedNames, file = "CleanedNames.Rdata")
write.csv(CleanedNames, file = "CleanedNames.csv")

# slice CleanedNames into chunks for TNRS:
# for 10,000 species
seq1 <- seq(from =1, to = 120001, 10000)
seq2 <- seq(from =10000, to = 130000, 10000)

# for 5000 species
seq1 <- seq(from =1, to = 120001, 5000)
seq2 <- seq(from =5000, to = 125000, 5000)

cbind(seq1,seq2)

# cbind(seq1, seq2)
library(foreach)

for(i in 1:length(seq1)) {
    write.csv(TNRS.TPL.2$TNRS.Name_submitted[seq1[i]:seq2[i]], file =
paste(paste("tnrs_submit", seq1[i], sep = "_"), "csv", sep = "."))
}

# read in TNRS tables 

library(doParallel)
# Find out how many cores are available (if you don't already know)
detectCores()
# Create cluster with desired number of cores
cl <- makeCluster(3)

# Register cluster
registerDoParallel(cl)

# Find out how many cores are being used
getDoParWorkers()

# based on all sources
setwd("/home/oliver/Downloads/")

library(data.table)
x <- foreach(i = 1:length(seq1), .combine = rbind) %dopar% {
  read.table(paste(paste("tnrs.tpl", seq1[1], sep = "."), "txt", sep =
"."))
}

library(data.table)

system.time(
    x <- foreach(i = 1:length(seq1), .combine = rbind) %dopar% {
    read.csv(paste(paste("/home/oliver/Downloads/tnrs.tpl", seq1[i],
sep = "."), "csv", sep = "."), sep = ",", stringsAsFactors = FALSE,
skip = 0, head = T)[-1, ]
}
    )

tnrs.tpl <- x

x <- read.csv(paste(paste("/home/oliver/Downloads/tnrs.tpl", seq1[24],
sep = "."), "csv", sep = "."), sep = ",", stringsAsFactors = FALSE,
skip = 0, head = T)[-1, ]
dim(x)
names(x)
x[1:10, c(2,37)]

write.csv(tnrs.tpl, file = "tnrs.tpl.csv")
save(tnrs.tpl, file = "tnrs.tpl.Rdata")

load("tnrs.tpl.Rdata")

# check whether the submitted list for all sources 


##
#################################
library(taxize)
library(Taxonstand)

load("CleanedNames.Rdata")

str(CleanedNames)

system.time(
tnrs1 <- tnrs(query = CleanedNames[1:20000], source = "iPlant_TNRS")#[
, -c(5:7)]
    )
write.csv(tnrs1[ , c(1,2,4,5)], file = "tnrs1.csv")

###################################

system.time(
tnrs2 <- tnrs(query = CleanedNames[20001:40000], source =
"iPlant_TNRS")#[ , -c(5:7)]
    )
write.csv(tnrs2[ , c(1,2,4,5)], file = "tnrs2.csv")

###################################
system.time(
    tnrs3 <- tnrs(query = CleanedNames[40001:60000], source =
"iPlant_TNRS")#[ , -c(5:7)]
    )
write.csv(tnrs3[ , c(1,2,4,5)], file = "tnrs3.csv")
            
###################################
system.time(
    tnrs4 <- tnrs(query = CleanedNames[60001:80000], source =
"iPlant_TNRS")#[ , -c(5:7)]
    )
write.csv(tnrs4[ , c(1,2,4,5)], file = "tnrs4.csv")

###################################
system.time(
    tnrs5 <- tnrs(query = CleanedNames[80001:100000], source =
"iPlant_TNRS")#[ , -c(5:7)]
    )
write.csv(tnrs5[ , c(1,2,4,5)], file = "tnrs5.csv")
    
###################################
system.time(
    tnrs6 <- tnrs(query = CleanedNames[100001:122901], source =
"iPlant_TNRS")#[ , -c(5:7)]
    )
write.csv(tnrs6[ , c(1,2,4,5)], file = "tnrs6.csv")

###################################

##
sp1 <- TPLck("Liliopsida", corr=TRUE, diffchar = 1, max.distance=1)
sp1


# what about species names that cannot be resolved by TNRS but that
can be resolved by TPL?
# (e.g. Potentilla rhenana or Potentilla ikonokovii)
# in that case (where TNRS reduces and valid or mispelled name to a
genus taxon), we need to run "CleanedNames" again against TPL

# error in tnrs2 and tnrs3 -> run in chunks of 1000

#####################################################

library(taxize)
library(Taxonstand)

load("CleanedNames.Rdata")

tnrs <- tnrs(query = CleanedNames[1:100], source = "iPlant_TNRS")[ ,
c(1,2,4,5)]

for (i in seq(from =50001, to = 60000, 1000)){
    nam <- CleanedNames[i:(i+999)]
    tnrs <- tnrs(query = nam, source = "iPlant_TNRS")[ , c(1,2,4,5)]
    write.csv(tnrs, paste(paste("tnrs.chunk", i), ".csv"))
}

######################################################

# 4) read in and combine tnrs tables (17.30-17.45)

tab <- NA
for (i in seq(from =20001, to = 59001, 1000))
{
    tab <- rbind(tab, read.csv(paste(paste("tnrs.chunk", i), ".csv")))
}

tnrs1 <- read.csv("tnrs1.csv")
tnrs4 <- read.csv("tnrs4.csv")
tnrs5 <- read.csv("tnrs5.csv")
tnrs6 <- read.csv("tnrs6.csv")

tab2 <- rbind(tnrs1, tab, tnrs4, tnrs5, tnrs6)

head(tab2)
str(tab2)
dim(tab2)

tab2$submittedname <- as.character(tab2$submittedname)
tab2$acceptedname <- as.character(tab2$acceptedname)
tab2$matchedname <- as.character(tab2$matchedname)

# 5) link cleaned names to backbone (cbind) check whether dataframes
match

length(CleanedNames)
str(CleanedNames)

CleanedNames.df <- as.data.frame(CleanedNames, stringsAsFactors=FALSE)

spec.list.TRY.sPlot.2 <- read.csv("spec.list.TRY3.sPlot2.csv")
str(spec.list.TRY.sPlot.2)

spec.list.TRY.sPlot.3 <- cbind(spec.list.TRY.sPlot.2, CleanedNames.df)
dim(spec.list.TRY.sPlot.3)
# 122901
head(spec.list.TRY.sPlot.3)

spec.list.TRY.sPlot.3 <- spec.list.TRY.sPlot.3[,c(2,4,5)]
spec.list.TRY.sPlot.3[1100:1120,]

spec.list.TRY.sPlot.3$names.sPlot.TRY <-
as.character(spec.list.TRY.sPlot.3$names.sPlot.TRY)

# 6) link TNRS names to cleaned names in backbone
# give informative colnames
colnames(tab2)[2] <- "CleanedNames"

library(dplyr)

spec.list.TRY.sPlot.TNRS <- anti_join(spec.list.TRY.sPlot.3, tab2)
dim(spec.list.TRY.sPlot.TNRS)

spec.list.TRY.sPlot.TNRS[1000:1100,c(1,3)]

# 122901 CleanedNames in the backbone
# of the 122901 submitted cleaned names 118471 were returned when
running against TNRS
# what about the 4430 non-returned species? (check which of the
submitted CleanedNames are not in the TNRS output?)

tab2$CleanedNames[which(tab2$CleanedNames %in%
spec.list.TRY.sPlot.3$CleanedNames==F)]

# why are there 600 species names in 

# also, after merging, why are there 122499 in the merged (or
inner_join) dataset (check which species are missing)

# Are all 

# Check whether all  

# 7) run "matched" TNRS names against TPL


# Monday: 
# - because TNRS does not names for all submitted, run TNRS on those
that were not matched
# - further checking and cleaning
# - add family information
#  Leontodonhispidulus
# ABIESNORDMANNIANA


# check why tnrs function cannot connect to server

############################################################
## TNRS for the non-resolved names (maybe better to turn TPL and TNRS
around)

# to do: sent in 100 species on 6 cores (later try 12 cores)

library(RCurl)
library(RJSONIO)

#noTPL.names <- paste(d, collapse=',')
noTPL.names <- paste(CleanedNames[20100:20200], collapse=',')
noTPL.names <- noTPL.names[!is.na(noTPL.names)]
#The string needs to be URL-encoded
noTPL.names <- curlEscape(noTPL.names)
#Send a request to the TNRS service
tnrs.api <- 'http://tnrs.iplantc.org/tnrsm-svc'
url <- paste(tnrs.api,'/matchNames?retrieve=best&names=', noTPL.names,
sep='')
tnrs.json <- getURL(url)
# The response needs to be converted from JSON
tnrs.results <- fromJSON(tnrs.json)

dim(tnrs.results$items)
write.csv(tnrs.results$items, file = "tnrs.test300.csv")

# The corrected names are extracted from the response
names <- sapply(tnrs.results[[1]], function(x) c(x$nameSubmitted,
x$acceptedName))

## try on 3 cores:

library(taxize)
library(Taxonstand)

load("CleanedNames.Rdata")
length(CleanedNames)

# try to run code on multiple cores
library(doParallel)
# Find out how many cores are available (if you don't already know)
detectCores()
# Create cluster with desired number of cores
cl <- makeCluster(3)

# Register cluster
registerDoParallel(cl)

# Find out how many cores are being used
getDoParWorkers()

# Use the rbind function to combine results

seq1 <- seq(from =1, to = 122901, 100)
seq2 <- seq(from =100, to = 123000, 100)

cbind(seq1, seq2)

## script partly borrowed by Florian Jansen

library(RCurl)
library(RJSONIO)

tnrs.api <- 'http://tnrs.iplantc.org/tnrsm-svc'
url <- paste(tnrs.api,'/matchNames?retrieve=best&names=', names,
sep='')
tnrs.json <- getURL(url)

x <- foreach(i = 3:4, .combine = rbind) %dopar% { 
  require(RCurl)
  require(RJSONIO)                                         
  names <- paste(CleanedNames[seq1[i]:seq2[i]], collapse=',')
  names <- RCurl::curlEscape(names)
  tnrs.api <- 'http://tnrs.iplantc.org/tnrsm-svc'
  url <- paste(tnrs.api,'/matchNames?retrieve=best&names=', names,
sep='')
  tnrs.json <- RCurl::getURL(url)
  tnrs.results <- jsonlite::fromJSON(tnrs.json)
  tnrs.results <- as.data.frame(tnrs.results$items[,c(2,4)])
  #return(as.data.frame(tnrs.results$items[,c(2,4)])) 
}

tnrs <- tnrs(query = CleanedNames[1:10], source = "iPlant_TNRS")[ ,
c(1,2,4,5)]


###  proper taxonomic backbone (final steps):
# TNRS crashed, check again 2pm
# 1) generate new cleaned list, one with and one without number as
first word

# make sure that if the first word contains a number, append this word
in []

# check whether strings got messed up in Jürgen's corrected names
file:
weird.correct <- read.csv("weird.names_JD.csv")
weird.correct[1250:1253,]

OriginalNames[OriginalNames=="[ms644 Gentianac‚e schwach rosa]"]

OriginalNames[76578]

#OriginalNames.small <- OriginalNames[c(3:6, 100:105, 76484:76490)]

library(stringr)

# identify the orginal names that contain a number in their first
word:
firstWordWithNumbers <- grepl('[0-9]', word(OriginalNames, 1))
# count the number of words:
numberOfWords <- sapply(gregexpr("\\W+", OriginalNames), length) + 1
# if first word has numbers put it in [] after the full names
OriginalNames[firstWordWithNumbers & numberOfWords > 1] <-
paste(OriginalNames[firstWordWithNumbers & numberOfWords > 1],  " [",
word(OriginalNames[firstWordWithNumbers & numberOfWords > 1], 1), "]",
sep = "")

# for original names that have a number in their first word and which
word count exceeds 1, only keep stuff that comes after that number:
OriginalNames[firstWordWithNumbers & numberOfWords > 1] <-
sapply(OriginalNames[firstWordWithNumbers & numberOfWords > 1],
function(x) substr(x, start=regexpr(pattern =' ', text=x)+1,
stop=nchar(x)))

CleanedNames <- taxname.abbr(OriginalNames)
dup <- duplicated(CleanedNames)
sum(dup)

# rename some species that caused problems with TPL earlier
CleanedNames[which(CleanedNames=="Astragalus psoraloides")] <-
"Astragalus gjunaicus"
CleanedNames[which(CleanedNames=="Hedysarum mackenzii")] <- "Hedysarum
dasycarpum"

save(CleanedNames, file = "CleanedNames.Rdata")
write.csv(CleanedNames, file = "CleanedNames.csv")

# 2) substitute some of Jürgen's corrected names
# ! correct some messed up strings (encoding issue) from Jürgen's csv
import manually in excel
# Thursday evening: 
# 1) match new cleaned list to original list -> save everything as
Rdata; 
CleanedNames.df <- as.data.frame(CleanedNames, stringsAsFactors=FALSE)

spec.list.TRY.sPlot.3 <- cbind(spec.list.TRY.sPlot.2[,c(1,2,4)],
CleanedNames.df, CleanedNames.df)
dim(spec.list.TRY.sPlot.3)
# 122901
head(spec.list.TRY.sPlot.3)
colnames(spec.list.TRY.sPlot.3) <-
c("index","original.names.sPlot.TRY","sPlot.TRY","CleanedNames","CleanedNames.Juergen")

Tax_Back_sPlot2_TRY3 <- spec.list.TRY.sPlot.3

save(Tax_Back_sPlot2_TRY3, file = "Tax_Back_sPlot2_TRY3.Rdata")
load("Tax_Back_sPlot2_TRY3.Rdata")

str(Tax_Back_sPlot2_TRY3)

# 2) substitute some cleaned names with Jürgens corrected names 
weird.JD <- read.csv("weird.names_JD_string_correct.csv")
str(weird.JD)
head(weird.JD)
# 4093 names

sum(weird.JD$weird.names %in%
Tax_Back_sPlot2_TRY3$original.names.sPlot.TRY)
# all 4093 names present in TB

# check 
write.csv(Tax_Back_sPlot2_TRY3, file = "Tax_Back_sPlot2_TRY3.csv")

index <- match(weird.JD$weird.names,
Tax_Back_sPlot2_TRY3$original.names.sPlot.TRY)

# use syntax similar to that on for matching


# splot.species <-
splot.species[-which(splot.species$PlotObservationID==index2a[1]),]  


Tax_Back_sPlot2_TRY3$CleanedNames.Juergen[index] <-
weird.JD$Name.corrected

# 3) run cleaned names against TRNS (use six cores max), save chunks
as csv-files to see where there are misspelled names


### do some more cleaning on "CleanedNames.Juergen"


CleanedNames.Juergen <- Tax_Back_sPlot2_TRY3$CleanedNames.Juergen


CleanedNames.Juergen <- gsub('*', '', CleanedNames.Juergen,
fixed=TRUE)
CleanedNames.Juergen <- gsub('cf. ', '', CleanedNames.Juergen,
fixed=TRUE)
CleanedNames.Juergen <- gsub('Cf. ', '', CleanedNames.Juergen,
fixed=TRUE)
#CleanedNames.Juergen <- gsub('[', '', CleanedNames.Juergen,
fixed=TRUE)
#CleanedNames.Juergen <- gsub(']', '', CleanedNames.Juergen,
fixed=TRUE)
CleanedNames.Juergen <- gsub(' x ', ' ', CleanedNames.Juergen,
fixed=TRUE)
CleanedNames.Juergen <- gsub('Ã—', '', CleanedNames.Juergen,
fixed=TRUE)
CleanedNames.Juergen <- gsub('aff ', '', CleanedNames.Juergen,
fixed=TRUE)
CleanedNames.Juergen <- gsub('(', '', CleanedNames.Juergen,
fixed=TRUE)
CleanedNames.Juergen <- gsub(')', '', CleanedNames.Juergen,
fixed=TRUE)
CleanedNames.Juergen <- gsub(' cf ', ' ', CleanedNames.Juergen,
fixed=TRUE)
CleanedNames.Juergen <- gsub(' aff. ', ' ', CleanedNames.Juergen,
fixed=TRUE)
CleanedNames.Juergen <- gsub('c‚e', 'ceae', CleanedNames.Juergen,
fixed=TRUE)
CleanedNames.Juergen <- gsub('    ', ' ', CleanedNames.Juergen,
fixed=TRUE)
CleanedNames.Juergen <- gsub('   ', ' ', CleanedNames.Juergen,
fixed=TRUE)
CleanedNames.Juergen <- gsub('  ', ' ', CleanedNames.Juergen,
fixed=TRUE)
CleanedNames.Juergen <- gsub('x-', '', CleanedNames.Juergen,
fixed=TRUE)
CleanedNames.Juergen <- gsub('X-', '', CleanedNames.Juergen,
fixed=TRUE)
CleanedNames.Juergen <- gsub('like ', '', CleanedNames.Juergen,
fixed=TRUE)  
CleanedNames.Juergen <- gsub(',', '', CleanedNames.Juergen,
fixed=TRUE)  
CleanedNames.Juergen <- gsub(',', '', CleanedNames.Juergen,
fixed=TRUE)  
CleanedNames.Juergen <- gsub('=', ' ', CleanedNames.Juergen,
fixed=TRUE)
CleanedNames.Juergen <- gsub('   ', '  ', CleanedNames.Juergen,
fixed=TRUE)
CleanedNames.Juergen <- gsub('  ', ' ', CleanedNames.Juergen,
fixed=TRUE)

write.csv(CleanedNames.Juergen, file = "CleanedNames.Juergen.csv")

Tax_Back_sPlot2_TRY3$CleanedNames.Juergen[Tax_Back_sPlot2_TRY3$CleanedNames.Juergen
== "Agrostis x mercieri"]

CleanedNames[CleanedNames == "Agrostis x mercieri"]

Tax_Back_sPlot2_TRY3$CleanedNames.Juergen <- CleanedNames.Juergen

save(Tax_Back_sPlot2_TRY3, file = "Tax_Back_sPlot2_TRY3.Rdata")

# slice CleanedNames into chunks for TNRS:
# 
seq1 <- seq(from =1, to = 120001, 10000)
seq2 <- seq(from =10000, to = 130000, 10000)

# cbind(seq1, seq2)
library(foreach)

for(i in 1:length(seq1)) {
    write.csv(Tax_Back_sPlot2_TRY3$CleanedNames.Juergen[seq1[i]:seq2[i]],
file = paste(paste("tnrs_submit", seq1[i], sep = "_"), "csv", sep =
"."))
}


# identify species that are not matching (or have low prob. and are
not Spermatophyta sp.)
# load 10000 species test data


tnrs.test <-
read.csv("/home/oliver/Dokumente/PhD/PostPhD/IDiv/sDiv/sPlot/Analyses/Code/tnrs_retrieve_70001.csv")
dim(tnrs.test)

tnrs.test[1:5, ]
str(tnrs.test)

# 1) read in TNRS tables:
x <- foreach(i = 1:length(seq1), .combine = rbind) %dopar% {
  taxize::tnrs(query = CleanedNames[seq1[i]:seq2[i]], source =
"iPlant_TNRS")
}



library(doParallel)
# Find out how many cores are available (if you don't already know)
detectCores()
# Create cluster with desired number of cores
cl <- makeCluster(2)

# Register cluster
registerDoParallel(cl)

# Find out how many cores are being used
getDoParWorkers()

# Use the rbind function to combine results

seq1 <- seq(from =1, to = 122901, 10000)

library(foreach)

tnrs.all <- NA

for(i in seq1) {
  tnrs.all <- rbind(tnrs.all,
read.csv(paste(paste("/home/oliver/Dokumente/PhD/PostPhD/IDiv/sDiv/sPlot/Analyses/Code/tnrs.retrieve",
i, sep = "."), "csv", sep = "."), stringsAsFactors=F))
}

TNRS.all <- tnrs.all[-1,]
dim(TNRS.all)
str(TNRS.all)
colnames(TNRS.all)

TNRS.all[1:10,36:37]


write.csv(TNRS.all[,-c(7,9,10,24,35:37)], file = "TNRS.all.csv")

# 2) merge with original names

load("Tax_Back_sPlot2_TRY3.Rdata")
names(Tax_Back_sPlot2_TRY3)

TNRS.all.2 <- cbind(Tax_Back_sPlot2_TRY3[,2], TNRS.all)
dim(TNRS.all.2)
names(TNRS.all.2)[1] <- "original.names.sPlot.TRY"
TNRS.all.2[1000:1100, c(1,5)]
TNRS.all.2[,1] <- as.character(TNRS.all.2[,1])

TNRS.all.2$Name_matched[1:100]

# select non-matched species:
library(stringr)
word("Spermatophyta sp. [Barleria lanceolata]", 1)

nonmatch <- TNRS.all.2$Name_submitted[which(TNRS.all.2$Name_matched ==
"No suitable matches found." & word(TNRS.all.2$Name_submitted, 1) !=
"Spermatophyta")]

length(nonmatch)

write.csv(nonmatch, file = "nonmatch.csv") # resolve this list again
in TNRS and merge it with TNRS.all (~50 more species resolved)

nonmatch <- read.csv("nonmatch.csv", stringsAsFactors=F)
# match with TNRS.all 
TNRS.all[which(TNRS.all$Name_matched == "No suitable matches found." &
word(TNRS.all$Name_submitted, 1) != "Spermatophyta") , ] <- nonmatch

TNRS.all.2[10:20, c(1:5)]

save(TNRS.all.2, file = "TNRS.all.2.Rdata")
write.csv(TNRS.all.2, file = "TNRS.all.2.csv")

# 3) run names matched against TPL
# to do Saturday: write script for server: multicore, 1000 species
chunks, write chunks

# 4) resolve more species with gnr (taxize)

# 5) for poorly resolved TNRS species, run TPL on "submitted names"



library(Taxonstand)

TPL.test <- TPL(TNRS.all.2$Name_matched[100:200], genus = NULL,
species = NULL, infrasp = NULL, infra = T, abbrev = TRUE, corr = TRUE,
diffchar = 2, max.distance = 1, version = "1.1", file = "")

TPL.test[,c(1,2,6,8,10,12,16)]

colnames(TPL.test)

list1 <- c(1,2,3,4,5,)
list2 <- c(1,2,3,3,4,5)

identical(list1,list2)
all.equal(list1,list2)

# combine TNRS and TPL names check whether submitted names match
setwd("/home/oliver/Dokumente/PhD/PostPhD/IDiv/sDiv/sPlot/Analyses/Code/")
load("TNRS.all.2.Rdata")
load("TPL.all.Rdata")

str(TNRS.all.2)
str(TPL.all)

TNRS.all.3 <-
TNRS.all.2[,c(1,3,4,5,6,7,12,13,14,15,16,17,18,26,27,28,30,32,33,35,36)]
colnames(TNRS.all.3)[2:21] <- paste("TNRS",colnames(TNRS.all.3)[2:21],
sep = ".")

TPL.all.2 <- TPL.all[,c(1,2,3,4,6,8,9,10,12,13,16)]
colnames(TPL.all.2) <- paste("TPL",colnames(TPL.all.2), sep = ".")

# combine the two lists
TNRS.TPL <- cbind(Tax_Back_sPlot2_TRY3[,c(1,3)], TNRS.all.3,
TPL.all.2)
names(TNRS.TPL)

save(TNRS.TPL, file = "TNRS.TPL.Rdata")
write.csv(TNRS.TPL, file = "TNRS.TPL.csv")
load("TNRS.TPL.Rdata")

str(TNRS.TPL)
sum(TNRS.TPL$TPL.Plant.Name.Index==F)
# 21993 names do not have a plant index

#### To do
names(TNRS.TPL)

# select uncertain
TNRS.TPL.uncertain <- TNRS.TPL[which(TNRS.TPL$TNRS.Overall_score<0.98
& TNRS.TPL$TNRS.Genus_score<0.8&
TNRS.TPL$TNRS.Specific_epithet_score!=1),]
dim(TNRS.TPL.uncertain)

save(TNRS.TPL.uncertain, file = "TNRS.TPL.uncertain.Rdata")
write.csv(TNRS.TPL.uncertain, file = "TNRS.TPL.uncertain.csv")

TNRS.TPL.uncertain <- read.csv("TNRS.TPL.uncertain.csv")
head(TNRS.TPL.uncertain)
TNRS.TPL.uncertain[10:20,1:5]

# exclude word that start with "Spermatophyta"
firstWordSperm <- grepl('Spermatophyta',
word(TNRS.TPL.uncertain$TNRS.Name_submitted, 1))
sum(firstWordSperm)
TNRS.TPL.uncertain.2 <- TNRS.TPL.uncertain[firstWordSperm,]
TNRS.TPL.uncertain.3 <- TNRS.TPL.uncertain[firstWordSperm==F,]
write.csv(TNRS.TPL.uncertain.2, file = "TNRS.TPL.uncertain.2.csv")
write.csv(TNRS.TPL.uncertain.3, file = "TNRS.TPL.uncertain.3.csv")

TNRS.TPL.uncertain.3 <- read.csv("TNRS.TPL.uncertain.3.csv")

save(TNRS.TPL.uncertain.3, file = "TNRS.TPL.uncertain.3.Rdata")

# run against TPL (13.00 - 13.30) (on cluster)
load("TNRS.TPL.Rdata")
load("uncertain.655.TPL.Rdata")
load("TNRS.TPL.uncertain.3.Rdata")
uncertain.655.TPL <- x
str(uncertain.655.TPL)
str(TNRS.TPL.uncertain.3)

uncertain.655.TPL.index <- cbind(TNRS.TPL.uncertain.3[,3:5],
uncertain.655.TPL)

# merge uncertain.list with TNRS.TPL list
TNRS.TPL.2 <- TNRS.TPL

# continue here !!!!! check whether same columns are selected
TNRS.TPL.2[uncertain.655.TPL.index$index, c(1,2,3, 24,25,26,27,28:34)]
<- uncertain.655.TPL.index[,-c(8,10,14,17,18,20)]
str(TNRS.TPL.2)
names(TNRS.TPL.2)
head(TNRS.TPL.2)
save(TNRS.TPL.2, file = "TNRS.TPL.2.Rdata")

write.csv(TNRS.TPL.2, file = "TNRS.TPL.2.csv")


str(uncertain.655.TPL.index)
'data.frame':	655 obs. of  20 variables:
 $ index                   : int  55 129 1526 1527 1543 1838 3542 4849
4854 4855 ...
 $ sPlot.TRY               : Factor w/ 3 levels "S","ST","T": 3 3 3 3
3 3 1 1 1 1 ...
 $ original.names.sPlot.TRY: Factor w/ 655 levels "ABDILOBARANA
sp",..: 1 2 4 5 6 7 8 10 11 12 ...
 $ Genus                   : chr  "ABDILOBARANA" "ABIES"
"ACARIQUARANA" "ACARIQUARA" ...
 $ Species                 : chr  NA "nordmanniana" NA NA ...
 $ Abbrev                  : chr  NA NA NA NA ...
 $ Infraspecific           : chr  "" "" "" "" ...
 $ ID                      : chr  "" "kew-2609993" "" "" ...
 $ Plant.Name.Index        : logi  FALSE TRUE FALSE FALSE FALSE FALSE
...
 $ TPL_version             : chr  "1.1" "1.1" "1.1" "1.1" ...
 $ Taxonomic.status        : chr  "" "Accepted" "" "" ...
 $ Family                  : chr  "" "Pinaceae" "" "" ...
 $ New.Genus               : chr  "ABDILOBARANA" "Abies"
"ACARIQUARANA" "ACARIQUARA" ...
 $ New.Hybrid.marker       : chr  "" "" "" "" ...
 $ New.Species             : chr  NA "nordmanniana" NA NA ...
 $ New.Infraspecific       : chr  "" "" "" "" ...
 $ Authority               : chr  "" "(Steven) Spach" "" "" ...
 $ New.ID                  : chr  "" "kew-2609993" "" "" ...
 $ Typo                    : logi  FALSE FALSE FALSE FALSE FALSE FALSE
...
 $ WFormat                 : logi  FALSE FALSE FALSE FALSE FALSE FALSE
...

# convert factors into characters:
uncertain.655.TPL.index[,2] <-
as.character(uncertain.655.TPL.index[,2])
uncertain.655.TPL.index[,3] <-
as.character(uncertain.655.TPL.index[,3])


# which "TPL.Plant.Name.Index" == FALSE
TNRS.TPL.index.FALSE <-
TNRS.TPL.2[which(TNRS.TPL.2$TPL.Plant.Name.Index==FALSE),]
str(TNRS.TPL.index.FALSE)
save(TNRS.TPL.index.FALSE, file = "TNRS.TPL.index.FALSE.Rdata")
write.csv(TNRS.TPL.index.FALSE, file = "TNRS.TPL.index.FALSE.csv")

# run non-matched names against "gnr_resolve"
load("TNRS.TPL.index.FALSE.Rdata")
str(TNRS.TPL.index.FALSE)

# Problem: some species that have no TPL.ID cannot be resolved with
"gnr.resolve":
# e.g. Antylis barba-jovis .. -> in that case take the matched name
from TNRS (if name score is >0.9)
# or species names is excluded, and just the genus name remains: e.g.
Archangelica tympanodes
# -> in that case keep the full matched name from TNRS if probability
is high
# Arcypteris
# Baikaea insignis
# Baphia keckii
# Benstonea monticola

# species name is pruned to genus 
# Bombacopsis flaviflora -> Bombacopsis (according to TNRS: Pachira)
# -> in this case take accepted name from TNRS

# there are still some cutoff names:
# Apium graveo subsp. butronensis

# make sure not assign family and higher-order information to genus
after TPL scrubbing

# assign "Spermatophyta" MOST non-assigned species, BUT manually check
for liliopsida, fungi, lichen, moss, pteridophyta, dicots ...

# extra columns for classification:

# extra column: level taxonomic information (species, genus, family
... order etc)


##  some testing strange names:
sp1 <- TPLck("Jutai acu", corr=TRUE, diffchar = 2, max.distance=2)
sp1

sp1 <- TPL(missing.2, corr=TRUE, diffchar = 2, max.distance=2)
sp1

missing.2 <- gsub("_", " ", missing)


library(taxize)
library(foreach)
library(doParallel)

detectCores()
cl <- makeCluster(3)
registerDoParallel(cl)
getDoParWorkers()

spec <- c("Poa annua","Verbena","Chenopodioideae","adsfa","Dacryodes
1","Cyperales","Davenportia davenportia")

spec <- TNRS.TPL.index.FALSE$TNRS.Name_submitted

# gnr_resolve changes order of plant names in a submitted list ...
therefore needs to ran in a foreach-loop
# (test run time for subset of 100 species, on 12 cores)

system.time(
    x <- foreach(i = 4350:4355, .combine = rbind) %dopar% {
        taxize::gnr_resolve(names = spec[i], resolve_once = TRUE,
highestscore = TRUE, stripauthority = TRUE, best_match_only = F,
data_source_ids = c(1,2,3,4,5,9,10,12,13,15,16,20,28,31),
preferred_data_sources =
c(1,2,3,4,5,9,10,12,13,15,16,20,28,31))$results[1,]
    }
    )
x

write.csv(sources, file = "sources.csv")

taxize::gnr_resolve(names = "Hepatophyta", resolve_once = T,
highestscore = T, stripauthority = TRUE, best_match_only = F,
data_source_ids =
c(1,2,3,4,5,6,7,9,10,11,13,15,16,20,28,31,108,147,150,165,167,176),
preferred_data_sources = c(1,2,3,4,5,9,10,12,13,15,16,20,28,31))

spec[1002]: "Anonaceae sp1 UNA1"
spec[1018]: "Anthocephalus"

gnr_resolve(names = "Jutai acu")

taxize::gnr_resolve(names = "Hypnales Slaapmossen - Feather mosses |
Hypnales Slaa", resolve_once = T, highestscore = T, stripauthority =
TRUE, best_match_only = T)

lookup_table("Trentepohlia", missing_action = "NA")


temp <- gnr_resolve(names = "Rauwolfia", resolve_once = TRUE,
highestscore = TRUE, best_match_only = TRUE)$results[1,]
temp$results

# read in gnr.resolve.list (has been generated on RStudio-Server)
# create "matched_name3" column

FALSE.gnr <- read.csv("TNRS.TPL.index.FALSE.gnr.csv")
str(FALSE.gnr)

FALSE.gnr$matched_name2 <- as.character(FALSE.gnr$matched_name2)
FALSE.gnr$submitted_name <- as.character(FALSE.gnr$submitted_name)

FALSE.gnr$matched_name3 <- FALSE.gnr$matched_name2

FALSE.gnr$matched_name3[which(is.na(FALSE.gnr$score))] <-
FALSE.gnr$submitted_name[which(is.na(FALSE.gnr$score))]

# substitute "one-word" names with the full names
library(stringr)
numberOfWords <- str_count(FALSE.gnr$matched_name2, "\\S+")
str(numberOfWords)

FALSE.gnr$matched_name3[which(numberOfWords<2)] <-
FALSE.gnr$submitted_name[which(numberOfWords<2)]

# re-run "matched_name3" against TPL
save(FALSE.gnr, file = "FALSE.gnr.Rdata")
     
# merge FALSE.gnr.TPL with 
load("FALSE.gnr.TPL.Rdata")
load("FALSE.gnr.Rdata")
str(FALSE.gnr)
str(FALSE.gnr.TPL)

# continue here
FALSE.gnr.TPL.ID <- cbind(FALSE.gnr[,c(2,3)], FALSE.gnr.TPL)
head(FALSE.gnr.TPL.ID)

FALSE.gnr.TPL.ID[,2] <- as.character(FALSE.gnr.TPL.ID[,2])

# continue here
TNRS.TPL.2[FALSE.gnr.TPL.ID$index, c(1,2, 24,25,26,27,28:34)] <-
FALSE.gnr.TPL.ID[,c(1:6,8,10,11,12,14,15,18)]

str(FALSE.gnr.TPL.ID[,-c(8,10,14,17,18,20)])
names(FALSE.gnr.TPL.ID[,c(1:6,8,10,11,12,14,15,18)])
str(TNRS.TPL.2[FALSE.gnr.TPL.ID$index, c(1,2, 24,25,26,27,28:34)])
names(TNRS.TPL.2[FALSE.gnr.TPL.ID$index, c(1,2, 24,25,26,27,28:34)])

save(TNRS.TPL.2, file = "TNRS.TPL.2.Rdata")
load("TNRS.TPL.2.Rdata")
write.csv(TNRS.TPL.2, file = "TNRS.TPL.2.csv")
names(TNRS.TPL.2)

sum(TNRS.TPL.2$TPL.Plant.Name.Index!=T)
sum(TNRS.TPL.2$TPL.Plant.Name.Index==T)

# which TPL.index==FALSE, TNRS.accepted 
TNRS.accept.TPL.index.false <-
TNRS.TPL.2[which(TNRS.TPL.2$TPL.Plant.Name.Index==FALSE &
TNRS.TPL.2$TNRS.Taxonomic_status=="Accepted"),]
dim(TNRS.accept.TPL.index.false)
write.csv(TNRS.accept.TPL.index.false, file =
"TNRS.accept.TPL.index.false.csv")


# which typo=TRUE and number of strings <6:
dim(TNRS.TPL.2)
sum(TNRS.TPL.2$TPL.Typo)
# 1259

# write script for classification (for genus or higher order
information)
out <- classification(c("Rauwolfia"), return_id=FALSE, db =
c("itis"))
cbind(out)


spec.2 <- x$matched_name2

x <- foreach(i = 1:length(spec.2), .combine = dplyr::bind_rows)
%dopar% {
    as.data.frame(cbind(classification(spec.2[i], return_id=FALSE, db
= c("itis"))))
}

a <- cbind(classification(spec.2[1], return_id=FALSE, db = c("itis")))
b <- cbind(classification(spec.2[2], return_id=FALSE, db = c("itis")))
c <- as.data.frame(cbind(classification(spec.2[7], return_id=FALSE, db
= c("itis"))))
d <- as.data.frame(cbind(classification(spec.2[4], return_id=FALSE, db
= c("itis"))))

library(dplyr)
bind_rows(a,b,c)


#######################
### classfication #
#######################

 (out <- get_ids(names=c("Laricifomes officinalis"), db =
c("itis","ncbi")))
     (cl <- classification(out))
     rbind(cl)
     ## cbind with so many names results in some messy data
     cbind(cl)
     ## so you can turn off return_id
     cbind(classification(out, return_id=FALSE))

     write.csv(cbind( classification(out, return_id=FALSE)), file =
"class.csv")
########

library(stringr)

w <- data.frame(c("a;b","a;b"))
w[,1] <- as.character(w[,1])


new <- apply(w, 1, FUN=function(x){cbind(unlist(strsplit(x,";")))})


names <- paste("Polygonum longisetum", collapse=',')
  names <- RCurl::curlEscape(names)
  tnrs.api <- 'http://tnrs.iplantc.org/tnrsm-svc'
  url <- paste(tnrs.api,'/matchNames?retrieve=best&names=', names,
sep='')
  tnrs.json <- RCurl::getURL(url)
  tnrs.results <- jsonlite::fromJSON(tnrs.json)
  tnrs.results

Tax_Back_sPlot2_TRY3$CleanedNames.Juergen[Tax_Back_sPlot2_TRY3$CleanedNames.Juergen
== "Spinus pinus"]

library(TaxonLookup)
lookup_table(c("Rauwolfia"), missing_action = "NA")

synonyms("Rauwolfia", db=c("itis"))

tnrs(query = "Verbena urticafolium", source = "NCBI,MSW3,iPlant_TNRS",
code = "ICN,ICNB,ICBN,ICNCP")

######################################################
######################################################
## name resolution using new TNRS (September 2015): ##
######################################################
######################################################

# check whether submitted names match with cleaned names:

TNRS.TPL.2$TNRS.Name_submitted[TNRS.TPL.2$TNRS.Name_submitted %in%
tnrs.trop$Name_submitted == F]
# all match instead of three species:
# [1] "Antimima sp. [kahnf\"\"rmig]"                        
# [2] "Spermatophyta sp. [Geophyt sternf\"\"rmig]"          
# [3] "Spermatophyta sp. [Strauch \"\"Oraniquelocarpus\"\"]"

which(TNRS.TPL.2$TNRS.Name_submitted %in% tnrs.trop$Name_submitted ==
F)
TNRS.TPL.2$TNRS.Name_submitted[c(8349 , 51560, 110472)]
tnrs.trop$Name_submitted[c(8349 , 51560, 110472)]

write.csv(table(tnrs.tpl$Taxonomic_status), file =
"tab_tax.stat_tnrs.tpl.csv")
write.csv(table(tnrs.all$Taxonomic_status), file =
"tab_tax.stat_tnrs.all.csv")
write.csv(table(tnrs.trop$Taxonomic_status), file =
"tab_tax.stat_tnrs.trop.csv")

# stats for "name_matched_rank"
write.csv(table(tnrs.tpl$Name_matched_rank), file =
"tab_name.rank_tnrs.tpl.csv")
write.csv(table(tnrs.all$Name_matched_rank), file =
"tab_name.rank_tnrs.all.csv")
write.csv(table(tnrs.trop$Name_matched_rank), file =
"tab_name.rank_tnrs.trop.csv")

# start consolidating:
# 1. inspect in the excel table:
# sort according to: Name_matched_rank (==Family), Taxonomic_status
(==Accepted, Synomyn), Family_score (>0.9)
# create "index.family"
# 13.40-14.00

# assign index to first column:
tnrs.tpl$Name_number <- 1:length(tnrs.tpl$Name_number)

index.family <- tnrs.tpl[which(tnrs.tpl$Name_matched_rank == "family"
& tnrs.tpl$Taxonomic_status == "Accepted" & tnrs.tpl$Family_score >
0.89), 1]
length(index.family)

# 2. repeat selection for Name_matched_rank "forma" "genus"
"infraspecies" ... change selection "score", e.g. lower (strong)
threshold for species, higher (or no) threshold for infraspec.,
variety, ... (identify threshold by looking at the excel-table)
# create respective index
# 
# 14.00-15.00
index.forma <- tnrs.tpl[which(tnrs.tpl$Name_matched_rank == "forma" &
(tnrs.tpl$Taxonomic_status == "Accepted" | tnrs.tpl$Taxonomic_status
== "Synonym") & tnrs.tpl$Specific_epithet_score > 0.80), 1]
length(index.forma)

index.genus <- tnrs.tpl[which(tnrs.tpl$Name_matched_rank == "genus" &
(tnrs.tpl$Taxonomic_status == "Accepted" | tnrs.tpl$Taxonomic_status
== "Synonym") & tnrs.tpl$Genus_score > 0.89 & tnrs.tpl$Name_score >
0.5), 1]
length(index.genus)

# Genus: Problem: the following stuff is cut down to genus-level
# Andropogon sp. [capillipes + glaucopsis + glomeratus]
# Antennaria angustata/glabrata
# Aragoa perez.arbelaeziana
# Capsella bursa.pastoris
# !! possible solution: removing ".", "/", "[]" (! do this after index
based on all sources is created)

index.infraspec <- tnrs.tpl[which(tnrs.tpl$Name_matched_rank ==
"infraspecies"), 1]
length(index.infraspec)


index.species1 <- tnrs.tpl[which(tnrs.tpl$Name_matched_rank ==
"species" & (tnrs.tpl$Taxonomic_status == "Accepted" |
tnrs.tpl$Taxonomic_status == "Synonym") & tnrs.tpl$Genus_score > 0.78
& tnrs.tpl$Name_score > 0.93), 1]
length(index.species1)

index.species2 <- tnrs.tpl[which(tnrs.tpl$Name_matched_rank ==
"species" & (tnrs.tpl$Taxonomic_status == "Accepted" |
tnrs.tpl$Taxonomic_status == "Synonym") & tnrs.tpl$Genus_score > 0.89
& tnrs.tpl$Name_score > 0.49 & tnrs.tpl$Specific_epithet_score > 0.6),
1]
length(index.species2)

index.species <- unique(c(index.species1, index.species2))
length(index.species)

index.subspec <- tnrs.tpl[which(tnrs.tpl$Name_matched_rank ==
"subspecies" & (tnrs.tpl$Taxonomic_status == "Accepted" |
tnrs.tpl$Taxonomic_status == "Synonym") & (tnrs.tpl$Genus_score > 0.6
| tnrs.tpl$Specific_epithet_score > 0.67)), 1]
length(index.subspec)

index.variety <- tnrs.tpl[which(tnrs.tpl$Name_matched_rank ==
"variety" & (tnrs.tpl$Taxonomic_status == "Accepted" |
tnrs.tpl$Taxonomic_status == "Synonym") & (tnrs.tpl$Genus_score > 0.67
| tnrs.tpl$Specific_epithet_score > 0.67)), 1]
length(index.variety)

# additional step: identifying "non-matched" species that are
spermatophyta
index.spermatophyt <- tnrs.tpl[which(tnrs.tpl$Name_matched == "No
suitable matches found." & word(tnrs.tpl$Name_submitted, 1) ==
"Spermatophyta"), 1]
length(index.spermatophyt)

# !! later on: resolve 


# 3. identify those species that do not fulfill the search criteria
# 15.00-15.15
index.tpl <- c(index.family, index.forma, index.genus,
index.infraspec, index.species, index.subspec, index.variety,
index.spermatophyt)
length((index.tpl))

tnrs.tpl.certain <- tnrs.tpl[index.tpl,]
dim(tnrs.tpl.certain)
save(tnrs.tpl.certain, file = "tnrs.tpl.certain.Rdata")
write.csv(tnrs.tpl.certain, file = "tnrs.tpl.certain.csv")

tnrs.tpl.uncertain <- tnrs.tpl[tnrs.tpl$Name_number %in% index.tpl ==
F, ]
dim(tnrs.tpl.uncertain)
save(tnrs.tpl.uncertain, file = "tnrs.tpl.uncertain.Rdata")
write.csv(tnrs.tpl.uncertain, file = "tnrs.tpl.uncertain.csv")


# 4. take table from 3. repeat steps 1.-3. for "tnrs.all" "and
tnrs.trop"
# 15.15-17.00
# tpl.all:

str(tnrs.all) 
tnrs.all$Name_number <- 1:length(tnrs.all$Name_number)
# reduce to the uncertain species from tnrs.tpl
tnrs.all.small <- tnrs.all[tnrs.all$Name_number %in% index.tpl == F, ]
str(tnrs.all.small)

save(tnrs.all.small, file = "tnrs.all.small.Rdata")
write.csv(tnrs.all.small, file = "tnrs.all.small.csv")

index.family <- tnrs.all.small[which(tnrs.all.small$Name_matched_rank
== "family" & (tnrs.all.small$Taxonomic_status == "Accepted"|
tnrs.all.small$Taxonomic_status == "Synonym") &
tnrs.all.small$Family_score > 0.88), 1]
length(index.family)

index.forma <- tnrs.all.small[which(tnrs.all.small$Name_matched_rank
== "forma" & (tnrs.all.small$Taxonomic_status == "Accepted" |
tnrs.all.small$Taxonomic_status == "Synonym")), 1]
length(index.forma)
##

index.genus <- tnrs.all.small[which(tnrs.all.small$Name_matched_rank
== "genus" & (tnrs.all.small$Taxonomic_status == "Accepted" |
tnrs.all.small$Taxonomic_status == "Synonym") &
tnrs.all.small$Genus_score > 0.88 & tnrs.all.small$Name_score > 0.5),
1]
length(index.genus)

# continue here:
index.species1 <-
tnrs.all.small[which(tnrs.all.small$Name_matched_rank == "species" &
(tnrs.all.small$Taxonomic_status == "Accepted" |
tnrs.all.small$Taxonomic_status == "Synonym") &
tnrs.all.small$Genus_score > 0.88 & tnrs.all.small$Name_score > 0.9),
1]
length(index.species1)

index.species2 <-
tnrs.all.small[which(tnrs.all.small$Name_matched_rank == "species" &
(tnrs.all.small$Taxonomic_status == "Accepted" |
tnrs.all.small$Taxonomic_status == "Synonym") &
tnrs.all.small$Genus_score > 0.88 & tnrs.all.small$Name_score > 0.49),
1]
length(index.species2)

index.species <- unique(c(index.species1, index.species2))
length(index.species)

index.subspec <- tnrs.all.small[which(tnrs.all.small$Name_matched_rank
== "subspecies" & (tnrs.all.small$Taxonomic_status == "Accepted" |
tnrs.all.small$Taxonomic_status == "Synonym")), 1]
length(index.subspec)

index.subvariety <-
tnrs.all.small[which(tnrs.all.small$Name_matched_rank == "subvariety"
& (tnrs.all.small$Taxonomic_status == "Accepted" |
tnrs.all.small$Taxonomic_status == "Synonym")), 1]
length(index.subvariety)

index.variety <- tnrs.all.small[which(tnrs.all.small$Name_matched_rank
== "variety" & (tnrs.all.small$Taxonomic_status == "Accepted" |
tnrs.all.small$Taxonomic_status == "Synonym") &
tnrs.all.small$Genus_score > 0.75 ), 1]
length(index.variety)

##
index.all <- c(index.family, index.forma, index.genus, index.species,
index.subspec, index.variety, index.subvariety)
length((index.all))

##
tnrs.all.small.certain <- tnrs.all.small[tnrs.all.small$Name_number
%in% index.all == T,]
dim(tnrs.all.small.certain)
save(tnrs.all.small.certain, file = "tnrs.all.small.certain.Rdata")
write.csv(tnrs.all.small.certain, file = "tnrs.all.small.certain.csv")

tnrs.all.small.uncertain <- tnrs.all.small[tnrs.all.small$Name_number
%in% index.all == F, ]
dim(tnrs.all.small.uncertain)
save(tnrs.all.small.uncertain, file =
"tnrs.all.small.uncertain.Rdata")
write.csv(tnrs.all.small.uncertain, file =
"tnrs.all.small.uncertain.csv")

##############
# tnrs.trop:
str(tnrs.trop)
tnrs.trop$Name_number <- 1:length(tnrs.trop$Name_number)
# reduce to the uncertain species from tnrs.tpl
tnrs.trop.small <- tnrs.trop[tnrs.all.small.uncertain$Name_number, ]
str(tnrs.trop.small)

save(tnrs.trop.small, file = "tnrs.trop.small.Rdata")
write.csv(tnrs.trop.small, file = "tnrs.trop.small.csv")

###
index.family <-
tnrs.trop.small[which(tnrs.trop.small$Name_matched_rank == "family" &
(tnrs.trop.small$Taxonomic_status == "Accepted"|
tnrs.trop.small$Taxonomic_status == "Synonym")), 1]
length(index.family)

index.forma <- tnrs.trop.small[which(tnrs.trop.small$Name_matched_rank
== "forma" & (tnrs.trop.small$Taxonomic_status == "Accepted" |
tnrs.trop.small$Taxonomic_status == "Synonym")), 1]
length(index.forma)

index.genus <- tnrs.trop.small[which(tnrs.trop.small$Name_matched_rank
== "genus" & (tnrs.trop.small$Taxonomic_status == "Accepted" |
tnrs.trop.small$Taxonomic_status == "Synonym") &
tnrs.trop.small$Genus_score > 0.83 & tnrs.trop.small$Name_score >
0.5), 1]
length(index.genus)

# continue here:
index.species1 <-
tnrs.trop.small[which(tnrs.trop.small$Name_matched_rank == "species" &
(tnrs.trop.small$Taxonomic_status == "Accepted" |
tnrs.trop.small$Taxonomic_status == "Synonym") &
tnrs.trop.small$Genus_score > 0.88 & tnrs.trop.small$Name_score >
0.9), 1]
length(index.species1)

index.species1 <-
tnrs.trop.small[which(tnrs.trop.small$Name_matched_rank == "species" &
(tnrs.trop.small$Taxonomic_status == "Accepted" |
tnrs.trop.small$Taxonomic_status == "Synonym") &
tnrs.trop.small$Genus_score > 0.78 & tnrs.trop.small$Name_score >
0.94), 1]
length(index.species1)

index.species3 <-
tnrs.trop.small[which(tnrs.trop.small$Name_matched_rank == "species" &
(tnrs.trop.small$Taxonomic_status == "Accepted" |
tnrs.trop.small$Taxonomic_status == "Synonym") &
tnrs.trop.small$Genus_score > 0.88 & tnrs.trop.small$Name_score >
0.49), 1]
length(index.species3)

index.species <- unique(c(index.species1, index.species2,
index.species3))
length(index.species)


index.subspec <-
tnrs.trop.small[which(tnrs.trop.small$Name_matched_rank ==
"subspecies" & (tnrs.trop.small$Taxonomic_status == "Accepted" |
tnrs.trop.small$Taxonomic_status == "Synonym")), 1]
length(index.subspec)

index.variety <-
tnrs.trop.small[which(tnrs.trop.small$Name_matched_rank == "variety" &
(tnrs.trop.small$Taxonomic_status == "Accepted" |
tnrs.trop.small$Taxonomic_status == "Synonym")), 1]
length(index.variety)

index.trop <- c(index.family, index.forma, index.genus, index.species,
index.subspec, index.variety)
length((index.trop))

##
tnrs.trop.small.certain <- tnrs.trop.small[tnrs.trop.small$Name_number
%in% index.trop == T,]
dim(tnrs.trop.small.certain)
save(tnrs.trop.small.certain, file = "tnrs.trop.small.certain.Rdata")
write.csv(tnrs.trop.small.certain, file =
"tnrs.trop.small.certain.csv")

tnrs.trop.small.uncertain <-
tnrs.trop.small[tnrs.trop.small$Name_number %in% index.trop == F, ]
dim(tnrs.trop.small.uncertain)
save(tnrs.trop.small.uncertain, file =
"tnrs.trop.small.uncertain.Rdata")
write.csv(tnrs.trop.small.uncertain, file =
"tnrs.trop.small.uncertain.csv")

### run against NCBI
write.csv(tnrs.trop.small.uncertain$Name_submitted[1:5000], file =
"trop.uncert.1.csv")
write.csv(tnrs.trop.small.uncertain$Name_submitted[5001:9641], file =
"trop.uncert.5001.csv")


# 5. identify unresolved species (excluding "Spermatophyta...") from
1.-4. (which were not indexed according to my procedure above) and run
against TPL again (using six sources BUT take NCBI first)

# 
tnrs.ncbi.1 <-
read.csv("/home/oliver/Downloads/tnrs.trop.uncert.1.csv",
stringsAsFactors = FALSE)[-1,]
tnrs.ncbi.2 <-
read.csv("/home/oliver/Downloads/tnrs.trop.uncert.5001.csv",
stringsAsFactors = FALSE)[-1,]

tnrs.ncbi <- rbind(tnrs.ncbi.1, tnrs.ncbi.2) 
str(tnrs.ncbi)
range(tnrs.trop.small.uncertain$Name_number)
# give index:
tnrs.ncbi$Name_number <- tnrs.trop.small.uncertain$Name_number
range(tnrs.ncbi$Name_number)

save(tnrs.ncbi, file = "tnrs.ncbi.Rdata")
write.csv(tnrs.ncbi, file = "tnrs.ncbi.csv")

# for tnrs.ncbi, identify certain and uncertain species:
index.family <- tnrs.ncbi[which(tnrs.ncbi$Name_matched_rank ==
"family" & (tnrs.ncbi$Taxonomic_status == "Accepted"|
tnrs.ncbi$Taxonomic_status == "Synonym") & tnrs.ncbi$Family_score >
0.85), 1]
length(index.family)

index.genus.1 <- tnrs.ncbi[which(tnrs.ncbi$Name_matched_rank ==
"genus" & (tnrs.ncbi$Taxonomic_status == "Accepted" |
tnrs.ncbi$Taxonomic_status == "Synonym") & tnrs.ncbi$Genus_score >
0.89 & tnrs.ncbi$Name_score > 0.49), 1]
length(index.genus.1)

index.genus.2 <- tnrs.ncbi[which(tnrs.ncbi$Name_matched_rank ==
"genus" & (tnrs.ncbi$Taxonomic_status == "Accepted" |
tnrs.ncbi$Taxonomic_status == "Synonym") & tnrs.ncbi$Genus_score >
0.99 & tnrs.ncbi$Name_score > 0.2), 1]
length(index.genus.2)

index.genus.3 <- tnrs.ncbi[which(tnrs.ncbi$Name_matched_rank ==
"genus" & tnrs.ncbi$Taxonomic_status == "No opinion" &
tnrs.ncbi$Genus_score > 0.88 & tnrs.ncbi$Name_score > 0.49), 1]
length(index.genus.3)

index.genus <- unique(c(index.genus.1, index.genus.2, index.genus.3))
length(index.genus)

###
index.species.1 <- tnrs.ncbi[which(tnrs.ncbi$Name_matched_rank ==
"species" & (tnrs.ncbi$Taxonomic_status == "Accepted" |
tnrs.ncbi$Taxonomic_status == "Synonym") & tnrs.ncbi$Name_score >
0.94), 1]
length(index.species.1)

index.species.2 <- tnrs.ncbi[which(tnrs.ncbi$Name_matched_rank ==
"species" & (tnrs.ncbi$Taxonomic_status == "Accepted" |
tnrs.ncbi$Taxonomic_status == "Synonym") & tnrs.ncbi$Genus_score >
0.81 & tnrs.ncbi$Name_score > 0.51), 1]
length(index.species.2)

index.species.3 <- tnrs.ncbi[which(tnrs.ncbi$Name_matched_rank ==
"species" & tnrs.ncbi$Taxonomic_status == "No opinion"  &
tnrs.ncbi$Genus_score > 0.7 & tnrs.ncbi$Specific_epithet_score >
0.75), 1]
length(index.species.3)

index.species <- unique(c(index.species.1, index.species.2,
index.species.3))
length(index.species)

index.var <- tnrs.ncbi[which((tnrs.ncbi$Name_matched_rank ==
"subspecies" | tnrs.ncbi$Name_matched_rank == "unknown" |
tnrs.ncbi$Name_matched_rank == "variety") &
(tnrs.ncbi$Taxonomic_status == "Accepted" | tnrs.ncbi$Taxonomic_status
== "No opinion" | tnrs.ncbi$Taxonomic_status == "Synonym")), 1]
length(index.var)

index.ncbi <- c(index.family, index.genus, index.species, index.var)
length((index.ncbi))

# identify certain and uncertain species:
tnrs.ncbi.certain <- tnrs.ncbi[tnrs.ncbi$Name_number %in% index.ncbi
== T,]
dim(tnrs.ncbi.certain)
save(tnrs.ncbi.certain, file = "tnrs.ncbi.certain.Rdata") 
write.csv(tnrs.ncbi.certain, file = "tnrs.ncbi.certain.csv")

tnrs.ncbi.uncertain <- tnrs.ncbi[tnrs.ncbi$Name_number %in% index.ncbi
== F, ]
dim(tnrs.ncbi.uncertain)
save(tnrs.ncbi.uncertain, file = "tnrs.ncbi.uncertain.Rdata")
write.csv(tnrs.ncbi.uncertain, file = "tnrs.ncbi.uncertain.csv")

# in "ncbi uncertain":
# ... that are 

# identify species in "ncbi certain":
# ... that are potentially proper species that are pruned down to
genus level and run them against TPL

# continue here: send corrected list to Jürgen:
# continue checking "uncertain" that were not sent to Jürgen

# for Jürgens list 
# Pleuranthod lindenii
# Microsorium diversifolium <- take first five or seven letters
letters: Micro* diver*
# 
TPL("Hypoc* achyr*", corr=T, diffchar = 9, max.distance = 9)

# 

# 
# select "Accepted_name" for "no opinion", "invalid", "illegitimate"



-> run against TPL (using TNRS) (+ the five other sources)
# run again taxonstand::TPL
tpl.upload <- read.csv("TPLupload.csv", stringsAsFactors = F, head =
F)
str(tpl.upload)

tpl.test <- TPL(tpl.upload[,1], corr = F)
write.csv(tpl.test, file = "tpl.test.csv")

# saturday: check send condensed list to jürgens
for.juergen.corr <-
read.csv("/home/oliver/Downloads/tnrs.ncbi.uncertain.corrected.csv")
dim(for.juergen.corr)

for.juergen <-
read.csv("/home/oliver/Dokumente/PhD/PostPhD/IDiv/sDiv/sPlot/Analyses/Unresolved_sPlot2.0_TRY3.0.csv")

index <- match(for.juergen$Name_number, for.juergen.corr$Name_number)

for.juergen.2 <- cbind(for.juergen,
as.data.frame(for.juergen.corr[index, 7]))



colnames(for.juergen.2)[4] <- "corrected"


write.csv(for.juergen.2, file = "for.juergen.2.csv")

# 6. identify non-matched and uncertain species list based on scores


# sunday:
# 7. run through list in 6 and correct some obvious misspellings (e.g.
ABIESNORD., ..xboris.. etc. spec1 ...) + resolve some names according
to 2.
#  ))

# first, select non-jürgen, corrected and correct species in
"tnrs.ncbi.uncertain.corrected.csv"
ncbi.uncertain.corr <-
read.csv("/home/oliver/Downloads/tnrs.ncbi.uncertain.corrected.csv")
# str(ncbi.uncertain.corr)
# 
# select 679 species for jürgen and the species that i corrected
manually
index.juergen.corrected <-
ncbi.uncertain.corr[which((ncbi.uncertain.corr$for_Jürgen == "x" 
    | ncbi.uncertain.corr$corrected != "")), 2] 
length(index.juergen.corrected)


# further select some correct species within genus
index.correct.genus <-
ncbi.uncertain.corr[which((ncbi.uncertain.corr$Name_matched_rank ==
"genus"
    & ncbi.uncertain.corr$Taxonomic_status == "Accepted"
    & ncbi.uncertain.corr$Overall_score > 0.6)), 2] 
length(index.correct.genus)

#####
# further select some correct species within species
index.correct.species <-
ncbi.uncertain.corr[which((ncbi.uncertain.corr$Name_matched_rank ==
"species"
    & ncbi.uncertain.corr$Taxonomic_status == "Accepted"
    & ncbi.uncertain.corr$Overall_score > 0.89)), 2] 
length(index.correct.species)

index.ncbi <- unique(c(index.juergen.corrected, index.correct.genus,
index.correct.species))
length(index.ncbi)


# identify certain and uncertain species:
ncbi.uncertain.corr.certain <-
ncbi.uncertain.corr[ncbi.uncertain.corr$Name_number %in% index.ncbi ==
T,]
dim(ncbi.uncertain.corr.certain)
save(ncbi.uncertain.corr.certain, file =
"ncbi.uncertain.corr.certain.Rdata") 
write.csv(ncbi.uncertain.corr.certain, file =
"ncbi.uncertain.corr.certain.csv")

ncbi.uncertain.corr.uncertain <-
ncbi.uncertain.corr[ncbi.uncertain.corr$Name_number %in% index.ncbi ==
F, ]
dim(ncbi.uncertain.corr.uncertain)
save(ncbi.uncertain.corr.uncertain, file =
"ncbi.uncertain.corr.uncertain.Rdata")
write.csv(ncbi.uncertain.corr.uncertain, file =
"ncbi.uncertain.corr.uncertain.csv")

# use TPL to resolve names in "ncbi.uncertain.corr.uncertain"

ncbi.uncertain <-
as.character(ncbi.uncertain.corr.uncertain$Name_submitted)

# 1) run raw list
tpl.ncbi.1 <- TPL(ncbi.uncertain, corr=T, diffchar = 9, max.distance =
9)
tpl.ncbi.1 <- gsub("[", "", tpl.ncbi.1)
tpl.ncbi.1 <- gsub("]", "", tpl.ncbi.1)
tpl.ncbi.1 <- gsub("|", "", tpl.ncbi.1)
tpl.ncbi.1 <- gsub("?", "", tpl.ncbi.1)

write.csv(tpl.ncbi.1, file = "tpl.ncbi.1.csv")

# 2) extent by "*"
ncbi.uncertain.2 <- paste(gsub(" ", "* ", ncbi.uncertain), "*", sep =
"")

tpl.ncbi.2 <- TPL(ncbi.uncertain.2, corr=T, diffchar = 9, max.distance
= 9)
write.csv(tpl.ncbi.2, file = "tpl.ncbi.2.csv")

# 3) cut to first 5 letter and extent by "*"

simpleCap3 <- function(x) {
  s <- strsplit(x, " ")[[1]]
  paste(paste(substring(s, 1,1), substring(s, 2,3), sep="",
collapse="* "), "*", sep = "")
}

simpleCap5 <- function(x) {
  s <- strsplit(x, " ")[[1]]
  paste(paste(substring(s, 1,1), substring(s, 2,5), sep="",
collapse="* "), "*", sep = "")
}

simpleCap7 <- function(x) {
  s <- strsplit(x, " ")[[1]]
  paste(paste(substring(s, 1,1), substring(s, 2,7), sep="",
collapse="* "), "*", sep = "")
}


ncbi.uncertain.3 <- sapply(ncbi.uncertain, simpleCap3)
ncbi.uncertain.3 <- gsub("[", "", ncbi.uncertain.3, fixed = T)
ncbi.uncertain.3 <- gsub("]", "", ncbi.uncertain.3, fixed = T)
ncbi.uncertain.3 <- gsub("|", "", ncbi.uncertain.3, fixed = T)
ncbi.uncertain.3 <- gsub("?", "", ncbi.uncertain.3, fixed = T)
ncbi.uncertain.3 <- gsub("+", "", ncbi.uncertain.3, fixed = T)
ncbi.uncertain.3 <- gsub(".", "", ncbi.uncertain.3, fixed = T)
ncbi.uncertain.3 <- gsub("<", "", ncbi.uncertain.3, fixed = T)
ncbi.uncertain.3 <- gsub("/", "", ncbi.uncertain.3, fixed = T)
str(ncbi.uncertain.3)

tpl.ncbi.3 <- TPL(ncbi.uncertain.3, corr=T, diffchar = 9, max.distance
= 9)
write.csv(tpl.ncbi.3, file = "tpl.ncbi.3.csv")

tpl.ncbi.5 <- TPL(ncbi.uncertain.5, corr=T, diffchar = 9, max.distance
= 9)
write.csv(tpl.ncbi.5, file = "tpl.ncbi.5.csv")

tpl.ncbi.7 <- TPL(ncbi.uncertain.7, corr=T, diffchar = 9, max.distance
= 9)
write.csv(tpl.ncbi.7, file = "tpl.ncbi.7.csv")

#  put tpl.ncbi tables together:

tpl.ncbi <- cbind(tpl.ncbi.1[,c(1,2,6,8,10,12)],
tpl.ncbi.2[,c(6,8,10,12)], tpl.ncbi.3[,c(6,8,10,12)],
tpl.ncbi.5[,c(6,8,10,12)], tpl.ncbi.7[,c(6,8,10,12)])

rownames(tpl.ncbi) <- rownames(tpl.ncbi.7)

tpl.ncbi <- cbind(ncbi.uncertain.corr.uncertain[,1:2], tpl.ncbi)
str(tpl.ncbi)
tpl.ncbi <- tpl.ncbi[,-1]

write.csv(tpl.ncbi, file = "tpl.ncbi.csv")

# load tpl.ncbi
tpl.ncbi.2 <- read.csv("tpl.ncbi.csv")
str(tpl.ncbi.2)
names(tpl.ncbi.2)
# select corrected species
tpl.ncbi.2$name.correct <- paste(tpl.ncbi.2$Genus.correct,
tpl.ncbi.2$Species.correct)
index.corr <- tpl.ncbi.2[which(tpl.ncbi.2$name.correct != " "), 2] 

# which rows in ncbi.uncertain correspond to index.corr?

ncbi.uncertain.corr.uncertain.2 <- join(ncbi.uncertain.corr.uncertain,
tpl.ncbi.2[,c(1,2,6,26:29)], by = "Name_number")


str(ncbi.uncertain.corr.uncertain.2)
names(ncbi.uncertain.corr.uncertain.2)

write.csv(ncbi.uncertain.corr.uncertain.2, file =
"ncbi.uncertain.corr.uncertain.2.csv")

# if names were not corrected put "Taxonomic.status"
ncbi.uncertain.corr.uncertain.2$Status.correct[ncbi.uncertain.corr.uncertain.2$Status.correct==""]
<-
ncbi.uncertain.corr.uncertain.2$Taxonomic.status[ncbi.uncertain.corr.uncertain.2$Status.correct==""] 

summary(ncbi.uncertain.corr.uncertain.2$Status.correct)
str(ncbi.uncertain.corr.uncertain.2$Status.correct)

# assign "No suitable matches found." to the remaining species:
ncbi.uncertain.corr.uncertain.2$Status.correct <-
as.character(ncbi.uncertain.corr.uncertain.2$Status.correct)
ncbi.uncertain.corr.uncertain.2$Status.correct[is.na(ncbi.uncertain.corr.uncertain.2$Status.correct)]
<- "No suitable matches found."

# add uncorrected names in "X" to "name.correct"
ncbi.uncertain.corr.uncertain.2$name.correct[ncbi.uncertain.corr.uncertain.2$Genus.correct==""]
<-
as.character(ncbi.uncertain.corr.uncertain.2[,41])[ncbi.uncertain.corr.uncertain.2$Genus.correct==""]

# add "No suitable matches found." to remaining species in
"name.correct" according to "Status.correct"
ncbi.uncertain.corr.uncertain.2$name.correct[ncbi.uncertain.corr.uncertain.2$Status.correct=="No
suitable matches found."] <- "No suitable matches found."

write.csv(ncbi.uncertain.corr.uncertain.2, file =
"ncbi.uncertain.corr.uncertain.2.csv")

## done!! take "ncbi.uncertain.corr.uncertain.2" for merging with the
other data sets

# check ncbi.certain:
# a) create extra column (species.correct) and add species in
"Jürgen.corrected (679) to "certain", status=accepted for resolved
species, status="No suitable matches found." for the remaining
non.resolved species

juergen.correct <-
read.csv("/home/oliver/Dokumente/PhD/PostPhD/IDiv/sDiv/sPlot/Analyses/Unresolved_sPlot2.0_TRY3.0_2_JD.csv",
stringsAsFactors=FALSE)

# fill non-correctable species with "No suitable matches found."
juergen.correct$Taxon[juergen.correct$Taxon==""] <- "No suitable
matches found."

str(juergen.correct)

str(ncbi.uncertain.corr.certain)

# join the two 
ncbi.certain.juergen.corr <- join(ncbi.uncertain.corr.certain,
juergen.correct[,c(2,3,8)], by = "Name_number")
str(ncbi.certain.juergen.corr)
write.csv(ncbi.certain.juergen.corr, file =
"ncbi.certain.juergen.corr.csv")


ncbi.certain.juergen.corr.2 <-
read.csv("ncbi.certain.juergen.corr.csv", stringsAsFactors=FALSE)
str(ncbi.certain.juergen.corr.2)

# add some more corrected species to "name.correct"
ncbi.certain.juergen.corr.2$name.correct[is.na(ncbi.certain.juergen.corr.2$name.correct)]
<-
ncbi.certain.juergen.corr.2$corrected[is.na(ncbi.certain.juergen.corr.2$name.correct)]

write.csv(ncbi.certain.juergen.corr.2, file =
"ncbi.certain.juergen.corr.2.csv")

# fill remaining missing names in "name.correct", because they were
correctly resolved
ncbi.certain.juergen.corr.2$name.correct[ncbi.certain.juergen.corr.2$name.correct==""]
<-
ncbi.certain.juergen.corr.2$Name_matched[ncbi.certain.juergen.corr.2$name.correct==""]

# yay, the "ncbi.certain.juergen.corr.2" species are finished!!! now
merge it with "ncbi.uncertain.corr.uncertain.2" (gives ~1400 species)
!! add tag "manual matching" (means the scores from TNRS matching are
useless here, but nevertheless keep them)

# .. and check other earlier tpl.ncbi.certain data for species that
have been reduced to genus levels  (? is this the case in the
tropicos, tpl data sets as well?)

# continue here:
# i) make the following two consistent:
# ncbi.certain.juergen.corr.2
# ncbi.uncertain.corr.uncertain.2

ncbi.certain.juergen.corr.3 <-
read.csv("ncbi.certain.juergen.corr.3.csv", stringsAsFactors=FALSE)
str(ncbi.certain.juergen.corr.3)

ncbi.uncertain.corr.uncertain.3 <-
read.csv("ncbi.uncertain.corr.uncertain.3.csv",
stringsAsFactors=FALSE)
str(ncbi.uncertain.corr.uncertain.3)

## add status==Accepted for "ncbi.certain.juergen.corr.3": "No
suitable matches found." or "Accepted"
ncbi.certain.juergen.corr.3$Status.correct[ncbi.certain.juergen.corr.3$name.correct
== "No suitable matches found."] <- "No suitable matches found."

ncbi.certain.juergen.corr.3$Status.correct[is.na(ncbi.certain.juergen.corr.3$Status.correct)]
<- "Accepted"
write.csv(ncbi.certain.juergen.corr.3, file =
"ncbi.certain.juergen.corr.3.csv")

# add manual matching == x
ncbi.certain.juergen.corr.3$Manual.matching <- "x"
ncbi.uncertain.corr.uncertain.3$Manual.matching <- "x"
write.csv(ncbi.certain.juergen.corr.3, file =
"ncbi.certain.juergen.corr.3.csv")
write.csv(ncbi.uncertain.corr.uncertain.3, file =
"ncbi.uncertain.corr.uncertain.3.csv")

# combine the two data sets:
names(ncbi.certain.juergen.corr.3)
names(ncbi.uncertain.corr.uncertain.3)

ncbi.certain.juergen.corr.3 <- 
ncbi.certain.juergen.corr.3[,-c(1,2,3)]
ncbi.uncertain.corr.uncertain.3 <-
ncbi.uncertain.corr.uncertain.3[,-c(1,2)]

match(names(ncbi.uncertain.corr.uncertain.3),
names(ncbi.certain.juergen.corr.3))

ncbi.uncertain.comb <- rbind(ncbi.uncertain.corr.uncertain.3,
ncbi.certain.juergen.corr.3)
dim(ncbi.uncertain.comb)
write.csv(ncbi.uncertain.comb, file = "ncbi.uncertain.comb.csv")

## read in "tnrs.ncbi.certain"
tnrs.ncbi.certain <-
read.csv("/home/oliver/Downloads/tnrs.ncbi.certain.csv",
stringsAsFactors=FALSE)
str(tnrs.ncbi.certain)

# to resolve names where species were reduced to genus-level, identify
"Name_submitted" where "Overall_score" == 0.5

index0.5 <- tnrs.ncbi.certain[which(tnrs.ncbi.certain$Overall_score ==
0.5), 2]

tpl0.5 <-
tnrs.ncbi.certain$Name_submitted[tnrs.ncbi.certain$Overall_score ==
0.5]

names(tpl0.5) <- index0.5

str(tpl0.5)
length(tpl0.5)
tpl0.5[1:100]

save(tpl0.5, file = "tpl0.5.Rdata")

tpl0.5 <- gsub("[", "", tpl0.5, fixed = T)
tpl0.5 <- gsub("]", "", tpl0.5, fixed = T)
tpl0.5 <- gsub("|", "", tpl0.5, fixed = T)
tpl0.5 <- gsub("?", "", tpl0.5, fixed = T)
tpl0.5 <- gsub("+", "", tpl0.5, fixed = T)
tpl0.5 <- gsub(".", "", tpl0.5, fixed = T)
tpl0.5 <- gsub("<", "", tpl0.5, fixed = T)
tpl0.5 <- gsub("/", "", tpl0.5, fixed = T)

TPL("Antiaropsis tox*", corr=T, diffchar = 2, max.distance = 1)

# 1)
system.time(
tpl0.5.res <- TPL(tpl0.5, corr=T, diffchar = 2, max.distance = 1)
)
write.csv(tpl0.5.res, file = "tpl0.5.res.csv")


# 2)
tpl0.5.2 <- paste(gsub(" ", "* ", tpl0.5), "*", sep = "")
tpl0.5.2.res <- TPL(tpl0.5.2, corr=T, diffchar = 2, max.distance = 1)
write.csv(tpl0.5.2.res, file = "tpl0.5.2.res.csv")


## run the following on the server
# 3)
tpl0.5.5 <- sapply(tpl0.5, simpleCap5)
tpl0.5.5.res <- TPL(tpl0.5.5, corr=T, diffchar = 2, max.distance = 1)
write.csv(tpl0.5.5.res, file = "tpl0.5.5.res.csv")

# 4)
tpl0.5.7 <- sapply(tpl0.5, simpleCap7)
tpl0.5.7.res <- TPL(tpl0.5.7, corr=T, diffchar = 2, max.distance = 1)
write.csv(tpl0.5.7.res, file = "tpl0.5.7.res.csv")

tpl0.5.res <- read.csv("tpl0.5.res.csv", stringsAsFactors=FALSE)
tpl0.5.2.res <- read.csv("tpl0.5.2.res.csv", stringsAsFactors=FALSE)
tpl0.5.5.res <- read.csv("tpl0.5.5.res.csv", stringsAsFactors=FALSE)
tpl0.5.7.res <- read.csv("tpl0.5.7.res.csv", stringsAsFactors=FALSE)

tpl.res.comb <- cbind(tpl0.5.res[,c(1,2,3,7,9,11,13)],
tpl0.5.2.res[,c(7,9,11,13)], tpl0.5.5.res[,c(7,9,11,13)],
tpl0.5.7.res[,c(7,9,11,13)])
                                                                                   
head(tpl.res.comb)
write.csv(tpl.res.comb, file = "tpl.res.comb.csv")

tpl.res.comb <- read.csv("tpl.res.comb.csv", stringsAsFactors=FALSE)

# combine species.correct and genus.correct
tpl.res.comb <- read.csv("tpl.res.comb.csv", stringsAsFactors=FALSE)
str(tpl.res.comb)
names(tpl.res.comb)
tpl.res.comb$name.correct <- paste(tpl.res.comb$Genus.correct,
tpl.res.comb$Species.correct)

tpl.res.comb.2 <- tpl.res.comb

# join "tnrs.ncbi.certain" and "tpl.res.comb.2"
names(tpl.res.comb.2)
names(tpl.res.comb.2)[2] <- "Name_number"

names(tnrs.ncbi.certain)

# continue here: get match correct
tnrs.ncbi.certain.0.5 <- join(tnrs.ncbi.certain[match(index0.5,
tnrs.ncbi.certain$Name_number),], tpl.res.comb.2[,c(3,23:26)], by =
"Name_number")

write.csv(tnrs.ncbi.certain.0.5, file = "tnrs.ncbi.certain.0.5.csv")

# fill in extra columns in "tnrs.ncbi.certain.0.5"
tnrs.ncbi.certain.0.5 <- read.csv("tnrs.ncbi.certain.0.5.csv",
stringsAsFactors=FALSE)
str(tnrs.ncbi.certain.0.5)
names(tnrs.ncbi.certain.0.5)
str(tnrs.ncbi.certain.0.5$Genus.correct)

# fill "Manual.matching"
tnrs.ncbi.certain.0.5$Manual.matching[tnrs.ncbi.certain.0.5$Genus.correct
!= ""] <- "x"

# fill "Status.correct"
tnrs.ncbi.certain.0.5$Status.correct[tnrs.ncbi.certain.0.5$Status.correct
== ""] <-
tnrs.ncbi.certain.0.5$Taxonomic_status[tnrs.ncbi.certain.0.5$Status.correct
== ""]

# fill "name.correct"
tnrs.ncbi.certain.0.5$name.correct[tnrs.ncbi.certain.0.5$name.correct
== " "] <-
tnrs.ncbi.certain.0.5$Name_matched[tnrs.ncbi.certain.0.5$name.correct
== " "]

write.csv(tnrs.ncbi.certain.0.5, file = "tnrs.ncbi.certain.0.5.csv")

# combine "tnrs.ncbi.certain.0.5" with the remaining
"tnrs.ncbi.certain"
str(tnrs.ncbi.certain.0.5)
names(tnrs.ncbi.certain.0.5)

cert.0.5 <- tnrs.ncbi.certain[tnrs.ncbi.certain$Overall_score == 0.5,]
dim(cert.0.5)
str(cert.0.5)

cert.non.0.5 <- tnrs.ncbi.certain[tnrs.ncbi.certain$Overall_score !=
0.5,]
dim(cert.non.0.5)
str(cert.non.0.5)
names(cert.non.0.5)

# add three more cols to "cert.non.0.5"
cert.non.0.5$Manual.matching <- NA
cert.non.0.5$Status.correct <- NA
cert.non.0.5$name.correct <- NA

tnrs.ncbi.certain.comb <- rbind(tnrs.ncbi.certain.0.5[,c(3:41,44)],
cert.non.0.5[,c(2:41)])
dim(tnrs.ncbi.certain.comb)
write.csv(tnrs.ncbi.certain.comb, file = "tnrs.ncbi.certain.comb.csv")

## yay, now merge the big data sets
# 1) TPL.small.certain
load("tnrs.tpl.certain.Rdata")
dim(tnrs.tpl.certain)

# 2) all.small.certain
load("tnrs.all.small.certain.Rdata")
dim(tnrs.all.small.certain)

# 3) trop.small.certain
load("tnrs.trop.small.certain.Rdata")
dim(tnrs.trop.small.certain)

# combine the certain data sets
tnrs.tpl.all.trop.certain <- rbind(tnrs.tpl.certain,
tnrs.all.small.certain, tnrs.trop.small.certain)
dim(tnrs.tpl.all.trop.certain)

# and add the four additional cols
names(tnrs.tpl.all.trop.certain)

tnrs.tpl.all.trop.certain$Manual.matching <- NA
tnrs.tpl.all.trop.certain$Status.correct <- NA
tnrs.tpl.all.trop.certain$name.correct <- NA
tnrs.tpl.all.trop.certain$rank.correct <- NA

# 4) pick the respective "ncbi" data sets
# for the 8177 certain species
names(tnrs.ncbi.certain.comb)
tnrs.ncbi.certain.comb$rank.correct <- NA
# combine the two lists
tnrs.tpl.all.trop.certain.2 <- rbind(tnrs.tpl.all.trop.certain,
tnrs.ncbi.certain.comb)
dim(tnrs.tpl.all.trop.certain.2)
names(tnrs.tpl.all.trop.certain.2)

# now, take the combined uncertain species (Jürgens and the other)
names(ncbi.uncertain.comb)
# exclude columns "Jürgen" and "corrected"
ncbi.uncertain.comb.2 <- ncbi.uncertain.comb[,-c(5,6)]
names(ncbi.uncertain.comb.2)
ncbi.uncertain.comb.2$rank.correct <- NA

# combine them
tnrs.tpl.all.trop.tnrs.certain <- rbind(tnrs.tpl.all.trop.certain.2,
ncbi.uncertain.comb.2)
write.csv(tnrs.tpl.all.trop.tnrs.certain, file =
"tnrs.tpl.all.trop.tnrs.certain.csv")
save(tnrs.tpl.all.trop.tnrs.certain, file =
"tnrs.tpl.all.trop.tnrs.certain.Rdata")

tnrs.tpl.all.trop.tnrs.certain$name.correct[which(tnrs.tpl.all.trop.tnrs.certain$name.correct
== "ABIES NORDMANNIANA")] <- "Abies nordmanniana"

# FINAL cleaning:
# complement the last four columns
dim(tnrs.tpl.all.trop.tnrs.certain)
names(tnrs.tpl.all.trop.tnrs.certain)

# fill "rank.correct"
tnrs.tpl.all.trop.tnrs.certain.filled <-
tnrs.tpl.all.trop.tnrs.certain
tnrs.tpl.all.trop.tnrs.certain.filled$rank.correct <-
as.character(tnrs.tpl.all.trop.tnrs.certain.filled$rank.correct)

tnrs.tpl.all.trop.tnrs.certain.filled$rank.correct[is.na(tnrs.tpl.all.trop.tnrs.certain.filled$Manual.matching)]
<-
tnrs.tpl.all.trop.tnrs.certain.filled$Name_matched_rank[is.na(tnrs.tpl.all.trop.tnrs.certain.filled$Manual.matching)]

# fill "status.correct"
tnrs.tpl.all.trop.tnrs.certain.filled$Status.correct[is.na(tnrs.tpl.all.trop.tnrs.certain.filled$Manual.matching)]
<-
tnrs.tpl.all.trop.tnrs.certain.filled$Taxonomic_status[is.na(tnrs.tpl.all.trop.tnrs.certain.filled$Manual.matching)]

# fill "name.correct"
tnrs.tpl.all.trop.tnrs.certain.filled$name.correct[is.na(tnrs.tpl.all.trop.tnrs.certain.filled$Manual.matching)]
<-
tnrs.tpl.all.trop.tnrs.certain.filled$Accepted_name[is.na(tnrs.tpl.all.trop.tnrs.certain.filled$Manual.matching)]


# fill "name.correct" # if status.correct is 
tnrs.tpl.all.trop.tnrs.certain.filled$name.correct[which(tnrs.tpl.all.trop.tnrs.certain.filled$Status.correct
== "No opinion")] <-
tnrs.tpl.all.trop.tnrs.certain.filled$Name_matched[which(tnrs.tpl.all.trop.tnrs.certain.filled$Status.correct
== "No opinion")]

write.csv(tnrs.tpl.all.trop.tnrs.certain.filled, file =
"tnrs.tpl.all.trop.tnrs.certain.filled.csv")

# in "tnrs.tpl.all.trop.tnrs.certain.filled" resolve some species
manually on the TPL webpage


# resolve some more species that wree not resolved by tropicos:
tplupload <- read.csv("tplupload.csv", head = F)
tpl.res.67 <- TPL(as.character(tplupload[,1]), corr=T, diffchar = 9,
max.distance = 9)

write.csv(tpl.res.67, file = "tpl.res.67.csv")

# fill in names.short correct:
tnrs.tpl.all.trop.tnrs.certain.filled <-
read.csv("tnrs.tpl.all.trop.tnrs.certain.filled.csv",
stringsAsFactors=FALSE)

names(tnrs.tpl.all.trop.tnrs.certain.filled)
str(tnrs.tpl.all.trop.tnrs.certain.filled)

tnrs.tpl.all.trop.tnrs.certain.filled$name.short.correct <-
as.character(tnrs.tpl.all.trop.tnrs.certain.filled$name.short.correct)

# identify number of words in names
wordcount <- sapply(gregexpr("\\S+",
tnrs.tpl.all.trop.tnrs.certain.filled$name.correct), length)

# shorten names that have more than 1 word
tnrs.tpl.all.trop.tnrs.certain.filled$name.short.correct[wordcount>1]
<-
word(tnrs.tpl.all.trop.tnrs.certain.filled$name.correct[wordcount>1],
1, 2)

# fill in one-word names
tnrs.tpl.all.trop.tnrs.certain.filled$name.short.correct[wordcount==1]
<- tnrs.tpl.all.trop.tnrs.certain.filled$name.correct[wordcount==1]

# where is the second word an x:
length(word(tnrs.tpl.all.trop.tnrs.certain.filled$name.short.correct[wordcount>1],
2)=="x")

write.csv(tnrs.tpl.all.trop.tnrs.certain.filled, file =
"tnrs.tpl.all.trop.tnrs.certain.filled.csv")

tnrs.tpl.all.trop.tnrs.certain.filled$name.short.correct[wordcount>2][(word(tnrs.tpl.all.trop.tnrs.certain.filled$name.correct[wordcount>2],
2)=="x")] <-
word(tnrs.tpl.all.trop.tnrs.certain.filled$name.correct[wordcount>2]
,c(1,3))

# set index where wordcount is greater 2 and the second word == "x"
index <-
word(tnrs.tpl.all.trop.tnrs.certain.filled$name.correct[wordcount>2],
2) == "x"
# 7900 species with more than 2 words and where 2nd word is "x"

# remove " x " from those names
wo.x <-
paste(word(tnrs.tpl.all.trop.tnrs.certain.filled$name.correct[wordcount>2][index],
1),
word(tnrs.tpl.all.trop.tnrs.certain.filled$name.correct[wordcount>2][index],
3))

tnrs.tpl.all.trop.tnrs.certain.filled$name.short.correct[wordcount>2][index]
<- wo.x

# correct "name.short correct"
tnrs.tpl.all.trop.tnrs.certain.filled <-
read.csv("tnrs.tpl.all.trop.tnrs.certain.filled.csv",
stringsAsFactors=FALSE)
tnrs.tpl.all.trop.tnrs.certain.filled$name.short.correct[tnrs.tpl.all.trop.tnrs.certain.filled$name.correct
== "No suitable matches found."] <- NA

# fill in "rank.short.correct"
tnrs.tpl.all.trop.tnrs.certain.filled$rank.short.correct <-
tnrs.tpl.all.trop.tnrs.certain.filled$rank.correct

table(tnrs.tpl.all.trop.tnrs.certain.filled$rank.short.correct)

tnrs.tpl.all.trop.tnrs.certain.filled$rank.short.correct[tnrs.tpl.all.trop.tnrs.certain.filled$rank.correct
== "infraspecies"] <- "species"

tnrs.tpl.all.trop.tnrs.certain.filled$rank.short.correct[tnrs.tpl.all.trop.tnrs.certain.filled$rank.correct
== "subspecies"] <- "species"

tnrs.tpl.all.trop.tnrs.certain.filled$rank.short.correct[tnrs.tpl.all.trop.tnrs.certain.filled$rank.correct
== "subvariety"] <- "species"

tnrs.tpl.all.trop.tnrs.certain.filled$rank.short.correct[tnrs.tpl.all.trop.tnrs.certain.filled$rank.correct
== "variety"] <- "species"

tnrs.tpl.all.trop.tnrs.certain.filled$rank.short.correct[tnrs.tpl.all.trop.tnrs.certain.filled$rank.correct
== "forma"] <- "species"

tnrs.tpl.all.trop.tnrs.certain.filled$rank.short.correct[tnrs.tpl.all.trop.tnrs.certain.filled$rank.correct
== "unknown"] <- "family"

write.csv(tnrs.tpl.all.trop.tnrs.certain.filled, file =
"tnrs.tpl.all.trop.tnrs.certain.filled.csv")

# fix families
tnrs.tpl.all.trop.tnrs.certain.filled <-
read.csv("tnrs.tpl.all.trop.tnrs.certain.filled.csv",
stringsAsFactors=FALSE)

names(tnrs.tpl.all.trop.tnrs.certain.filled)
str(tnrs.tpl.all.trop.tnrs.certain.filled)

tnrs.tpl.all.trop.tnrs.certain.filled$family.correct <-
as.character(tnrs.tpl.all.trop.tnrs.certain.filled$family.correct)

# rank==family
tnrs.tpl.all.trop.tnrs.certain.filled$family.correct[(is.na(tnrs.tpl.all.trop.tnrs.certain.filled$Manual.matching)
& tnrs.tpl.all.trop.tnrs.certain.filled$rank.short.correct ==
"family")] <-
tnrs.tpl.all.trop.tnrs.certain.filled$name.correct[(is.na(tnrs.tpl.all.trop.tnrs.certain.filled$Manual.matching)
& tnrs.tpl.all.trop.tnrs.certain.filled$rank.short.correct ==
"family")]

# other ranks
tnrs.tpl.all.trop.tnrs.certain.filled$family.correct[(is.na(tnrs.tpl.all.trop.tnrs.certain.filled$Manual.matching))]
<-
tnrs.tpl.all.trop.tnrs.certain.filled$Name_matched_accepted_family[(is.na(tnrs.tpl.all.trop.tnrs.certain.filled$Manual.matching))]

write.csv(tnrs.tpl.all.trop.tnrs.certain.filled, file =
"tnrs.tpl.all.trop.tnrs.certain.filled.csv")

# almost done:
# link backbone with original names and splot-try code

splot.try3.code <- read.csv("spec.list.TRY3.sPlot2.csv",
stringsAsFactors=FALSE)
str(splot.try3.code)

backbone.splot.try3 <-
read.csv("tnrs.tpl.all.trop.tnrs.certain.filled.small.csv",
stringsAsFactors=FALSE)
str(backbone.splot.try3)

backbone.splot.try3 <- join(splot.try3.code, backbone.splot.try3, by =
"Name_number")
str(backbone.splot.try3)

table(backbone.splot.try3$Status.correct)

backbone.splot.try3$Status.correct[backbone.splot.try3$Status.correct
== "No opinion"] <- "Unresolved"

write.csv(backbone.splot.try3, file = "backbone.splot.try3.csv")
save(backbone.splot.try3, file = "backbone.splot.try3.Rdata")

#
table(backbone.splot.try3$sPlot.TRY)
    S    ST     T 
62628 24796 35477

#
table(backbone.splot.try3$Manual.matching)
   x 
1675 

#
table(backbone.splot.try3$Status.correct)
Accepted No suitable matches found. 
95485                       1692 
                   Synonym                 Unresolved 
                     20952                       4772 


#
length(unique(backbone.splot.try3$name.correct))-1
90696

#
length(unique(backbone.splot.try3$family.correct))-1
665

#
length(unique(backbone.splot.try3$name.short.correct))-1
86528

#
table(backbone.splot.try3$rank.short.correct)
 family   genus  higher species 
   1880   13383    1211  105818 


# rename "no opinion" -> "unresolved"

# friday morning:
# 8-9: make sure 

# from all the resolved take the accepted ones

###

# monday 7-9 a.m.:
# 8. run list from 7. against TPL (all sources)
# (use same strategy as above)

# monday 9-11 a.m.
# 9. select "No opinion" (e.g. for "subspecies" and "infraspec."

levels and run against just "mached genus" and "matched epithet"
against the TPL and later tropicos etc...)

# do some final filtering to resolve stuff like:
# Polygala lila 132782	0.76	Polygala limae

# 10. at the very end, run everything that was matched against sources
other than TPL, GCC or ILDIS against these three sources, to resolve
some of the remaining synonyms

# check stuff where "name_score" < 0.95, e.g. mistakes like:
Salix capreola -> Salix caprea # in trop.small.certain

## okay, some some of these problems still exist but just for few docents of species

###################
########## recalculate species-level trait means (and sd) based on the (raw) individual-based TRY data and the backbone for splot 2.0 and TRY 3.0 "backbone.splot.try3"
#######################"

# unfortunately, for the time being trait calculations have to be based on the 18 gap-filled traits (see Shan et al)

# load the rwo
load("TRY.2.0.all.gapfilled.ln.acc.names.Rdata")
names(TRY.2.0.all.gapfilled.ln.acc.names)
dim(TRY.2.0.all.gapfilled.ln.acc.names)
str(TRY.2.0.all.gapfilled.ln.acc.names)

length(unique(TRY.2.0.all.gapfilled.ln.acc.names$ObservationID)) #obsID for each individual trait measurement
length(unique(TRY.2.0.all.gapfilled.ln.acc.names$AccSpeciesID)) # ID for each species in TRY: 45508
length(unique(TRY.2.0.all.gapfilled.ln.acc.names$AccSpeciesName)) # full species names (non-standardized) in TRY: 45507
# "AccSpeciesName" should map onto the "names.sPlot.TRY" in "backbone.splot.try3"

# load the backbone:
load("backbone.splot.try3.Rdata")
str(backbone.splot.try3)

# rename names-column in try according the "raw" names column in the backbone
names(TRY.2.0.all.gapfilled.ln.acc.names)[3] <- "names.sPlot.TRY"

# check whether "TRY.2.0.all.gapfilled.ln.acc.names$AccSpeciesName" maps onto "backbone.splot.try3$names.sPlot.TRY"

match(unique(TRY.2.0.all.gapfilled.ln.acc.names$names.sPlot.TRY), backbone.splot.try3$names.sPlot.TRY)

sum(is.na(match(unique(TRY.2.0.all.gapfilled.ln.acc.names$names.sPlot.TRY), backbone.splot.try3$names.sPlot.TRY)))
# 233 species in TRY 2.0 (0.51% of the species in TRY2.0) do not match onto the backbone
# which names in TRY are these:
unique(TRY.2.0.all.gapfilled.ln.acc.names$names.sPlot.TRY)[is.na(match(unique(TRY.2.0.all.gapfilled.ln.acc.names$names.sPlot.TRY), backbone.splot.try3$names.sPlot.TRY))==TRUE]
# i guess those species names do not match because they been renamed in TRY 3.0. Anyway, shouldnt be a problem when we use TRY 3.0

# reduce the backbone to the few important columns:

backbone.splot.try3.small <- backbone.splot.try3[,c(2,4,27:33)]
write.csv(backbone.splot.try3.small, file = "backbone.splot.try3.small.csv")

# ... and join it with try 2.0
TRY.all.stand.2 <- dplyr::inner_join(TRY.2.0.all.gapfilled.ln.acc.names, backbone.splot.try3.small)
dim(TRY.all.stand.2)

write.csv(TRY.all.stand.2, file = "TRY.all.stand.2.csv")

TRY.stand.2.sing <- TRY.all.stand.2
str(TRY.stand.2.sing)
names(TRY.stand.2.sing)

TRY.stand.2.sing$names.sPlot.TRY <- TRY.stand.2.sing$name.short.correct
names(TRY.stand.2.sing[,c(3,10:27)])
TRY.stand.2.sing <- TRY.stand.2.sing[,c(3,10:27)]

str(TRY.stand.2.sing)
names(TRY.stand.2.sing)[1] <- "StandSpeciesName"

write.csv(TRY.stand.2.sing, file = "TRY.stand.2.sing.csv")

save(TRY.stand.2.sing, file = "TRY.stand.2.sing.Rdata")

# calculate species level trait values
library(data.table)
names(TRY.stand.2.sing)
length(unique(TRY.stand.2.sing$StandSpeciesName))
# after name matching with the new backbone for splot 2.0 and try 3.0 there are 40791 instead of 45507 names
## 

# !! please note, trait means at the genus level only includes trait information of the genus-level name (e.g. Abies sp.) BUT not the trait of names within that genus that were resolved at the species level (e.g. Abies picea)
# !!! this needs to be fixed for the final calculations with TRY 3.0

TRY.stand.2.sing$StandSpeciesName <- as.factor(TRY.stand.2.sing$StandSpeciesName)
names(TRY.stand.2.sing)[2:19] <- c("SLA", "PlantHeight", "SeedMass",
"LDMC", "StemDens", "LeafArea", "LeafN", "LeafP", "LeafNperArea",
"Leaffreshmass", "LeafNPratio", "LeafC.perdrymass", "Leaf.delta.15N",
"Stem.cond.dens", "Seed.num.rep.unit", "Wood.vessel.length",
"Seed.length", "Disp.unit.leng")

TRY.stand.2.sing.DT <- data.table(TRY.stand.2.sing[,c(1:19)])
tables()
TRY.mean.sd.2 <-  TRY.stand.2.sing.DT[, 
                               list(
                               n = length(SLA),
                               SLA.mean = mean(SLA), 
                               PlantHeight.mean = mean(PlantHeight), 
                               SeedMass.mean = mean(SeedMass),
                               LDMC.mean = mean(LDMC),
                               StemDens.mean = mean(StemDens),
                               LeafArea.mean = mean(LeafArea),
                               LeafN.mean = mean(LeafN),
                               LeafP.mean = mean(LeafP),
                               LeafNperArea.mean = mean(LeafNperArea),
                               Leaffreshmass.mean =
mean(Leaffreshmass),
                               LeafNPratio.mean = mean(LeafNPratio),
                               LeafC.perdrymass.mean =
mean(LeafC.perdrymass),
                               Leaf.delta.15N.mean =
mean(Leaf.delta.15N),
                               Stem.cond.dens.mean =
mean(Stem.cond.dens),
                               Seed.num.rep.unit.mean =
mean(Seed.num.rep.unit),
                               Wood.vessel.length.mean =
mean(Wood.vessel.length),
                               Seed.length.mean = mean(Seed.length),
                               Disp.unit.leng.mean =
mean(Disp.unit.leng),
                               
                               SLA.sd = sd(SLA), 
                               PlantHeight.sd = sd(PlantHeight), 
                               SeedMass.sd = sd(SeedMass),
                               LDMC.sd = sd(LDMC),
                               StemDens.sd = sd(StemDens),
                               LeafArea.sd = sd(LeafArea),
                               LeafN.sd = sd(LeafN),
                               LeafP.sd = sd(LeafP),
                               LeafNperArea.sd = sd(LeafNperArea),
                               Leaffreshmass.sd = sd(Leaffreshmass),
                               LeafNPratio.sd = sd(LeafNPratio),
                               LeafC.perdrymass.sd =
sd(LeafC.perdrymass),
                               Leaf.delta.15N.sd = sd(Leaf.delta.15N),
                               Stem.cond.dens.sd = sd(Stem.cond.dens),
                               Seed.num.rep.unit.sd =
sd(Seed.num.rep.unit),
                               Wood.vessel.length.sd =
sd(Wood.vessel.length),
                               Seed.length.sd = sd(Seed.length),
                               Disp.unit.leng.sd = sd(Disp.unit.leng)                                                              
                               ),
                               by=StandSpeciesName]

TRY.all.mean.sd.2 <- as.data.frame(TRY.mean.sd.2)

dim(TRY.all.mean.sd.2)

write.csv(TRY.all.mean.sd.2, file = "TRY.all.mean.sd.2.csv")
save(TRY.all.mean.sd.2, file ="TRY.all.mean.sd.2.Rdata")

names(TRY.all.mean.sd.2)

# for how many species in splot is 
splot.species.try <- splot.species.stand[which(splot.species.stand$StandSpeciesName %in% TRY.all.mean.sd$StandSpeciesName), ]

#################################################
#################################################
# new match statistics for sPlot2.0 and TRY3.0: #
#################################################
#################################################

# 1) read species lists for TRY3.0:

path <- "/home/oliver/Dokumente/PhD/PostPhD/IDiv/sDiv/sPlot/Analyses/Data/Species/TRY/Species/"
files <- list.files(path, pattern="*.csv")
for (i in 1:length(files)) assign(files[i], read.csv(file.path(path, files[i]), stringsAsFactors = FALSE))

str(TRY30_Gapfilling2015_Species.csv)
str(try3_gapfilled.csv)

match(TRY30_Gapfilling2015_Species.csv[,1], try3_gapfilled.csv[,1])
sum(TRY30_Gapfilling2015_Species.csv[,1] %in% try3_gapfilled.csv[,1])

# rename data:

gapfilled <- try3_gapfilled.csv
leafarea <- try3_leafarea.csv
nmass <- try3_nmass.csv
plantheight <- try3_plantheight.csv
seedmass <- try3_seedmass.csv
sla <- try3_sla.csv
ssd <- try3_ssd.csv

# 2) match traits to backbone:

load("backbone.splot.try3.Rdata")
backbone.splot.try3.small <- backbone.splot.try3[,c(2,4,27:33)]
str(backbone.splot.try3.small)


##########
names(ssd)[1] <- "names.sPlot.TRY"
library(dplyr)
ssd.stand <- dplyr::inner_join(ssd, backbone.splot.try3.small)
dim(ssd.stand)
#write.csv(ssd.stand, file = "ssd.stand.csv")
#########

length(unique(ssd.stand$names.sPlot.TRY))
# there are 60273 (uncorrected) unique species names in TRY 3.0 (ssd) ... 
length(unique(ssd.stand$name.short.correct))
# of which 52459 are remaining after name resolution, means 12.96% of the species names in TRY 3.0 for which ssd data are available are incorrect (Synonyms, unresolved)

# how many of these 52459 unique name in TRY 3.0 are in sPlot?

backbone.splot <- backbone.splot.try3.small[backbone.splot.try3.small$sPlot.TRY!="T", ]

length(unique(backbone.splot$name.short.correct))
# 60909 unique resolved species names in sPlot 2.0
names.splot <- unique(backbone.splot$name.short.correct)

########
names.ssd <- unique(ssd.stand$name.short.correct)
########

# how many species in splot are represented by try?:
100*(length(
    names.splot
    [which(names.splot
           %in% 
           names.ssd)])/
     length(names.splot))

# gapfilled: 44.0641 % of the species are covered by traits in TRY
# plantheight: 25.0669 %
# seedmass: 25.02257 %
# leafarea: 17.29794 %
# sla: 14.42972 %
# nmass: 11.60091 %
# ssd: 9.906582 %

# 3) match to biomes:
# to be done later

# 4) calculate stats:

# 4.1) for the most frequent species
### i) read in sPlot 2.0:
splot.species <- read.csv("/home/oliver/Dokumente/PhD/PostPhD/IDiv/sDiv/sPlot/Analyses/Data/Species/sPlot/sPlot_14_04_2015/sPlot_14_4_2015_species.csv", sep = "\t")
gc()
dim(splot.species)
# 24,241,941       11
length(unique(splot.species$PlotObservationID))
# 1,117,940 vegetation splots
# extract meaningful columns:

dim(splot.species)
class(splot.species)
str(splot.species)

splot.species.small <- splot.species[ ,c(1,3,6,9)]
str(splot.species.small)

summary(splot.species.small)
# since we wanna focuss on vascular plants we might wanna exclude Taxon.group=Alga, Lichen, Moss, Stonewort (5 % of total)
# ? what about Taxon.group=Unknown ? (3,819,280) (15% of total)
splot.species.small.unknown <- splot.species.small[splot.species.small$Taxon.group=="Unknown", ]
dim(splot.species.small.unknown)
head(splot.species.small.unknown)

names.unknown.genus <- unique(word(splot.species.small.unknown$Matched.concept,1))
names.unknown.genus <- sort(names.unknown.genus)
write.csv(names.unknown.genus, file = "names.unknown.genus.csv")


# extract "Alga, Lichen, Moss, Stonewort"
splot.species.small.alga.lichen <- splot.species.small[splot.species.small$Taxon.group=="Alga"|splot.species.small$Taxon.group=="Lichen"|splot.species.small$Taxon.group=="Moss"|splot.species.small$Taxon.group=="Stonewort", ]
dim(splot.species.small.alga.lichen)
head(splot.species.small.alga.lichen)
length(unique(splot.species.small.alga.lichen$Matched.concept))
# 2328 unique (unresolved) species names in sPlot that are "Alga, Lichen, Moss, Stonewort"
names.moss.etc. <- sort(unique(splot.species.small.alga.lichen$Matched.concept))
library(stringr)
names.moss.etc.genus <- unique(word(names.moss.etc.,1))

# !! two genera ("Acacia", "Abies") were classified as "lichen"; do not not add them to the "names.moss.etc.genus.2" list
names.moss.etc.genus.2 <- names.moss.etc.genus[names.moss.etc.genus != "Abies" & names.moss.etc.genus != "Acacia"]

write.csv(names.moss.etc.genus.2, file = "names.moss.etc.genus.2.csv")

# which species in "names.unknown.genus" are not in "names.moss.etc.genus"?


# assign resolved species names:
# merge "splot.species.small" with tax backbone
str(splot.species.small)

splot.species.small$Matched.concept <- as.character(splot.species.small$Matched.concept)

names(splot.species.small)[3] <- "names.sPlot.TRY"

#### if crashes start here:
splot.species.small
backbone.splot.small <- backbone.splot[,c(1,8)]

save(splot.species.small, file = "splot.species.small.Rdata")
save(backbone.splot.small, file = "backbone.splot.small.Rdata")
load("splot.species.small.Rdata")
load("backbone.splot.small.Rdata")

splot.corr <- dplyr::left_join(splot.species.small, backbone.splot.small)
head(splot.corr)
# in species which first word in the name (name.short.correct) is a moss, lichen etc (this should also exclude most of the mosses... in the category "unknown"):

# check the austrian species, are they really mainly bryophytes?
splot.austria.unknown <- splot.species[splot.species$Taxonomy=="Austria" & splot.species$Taxon.group=="Unknown", ] # 3014 entries
splot.austria.unknown[, c(2,3,6)] # no, there are lots of vascualar plants in the austrian databases
# !!! to do: kick out austria with status: unknown

# check for more databases with "unknown species":
splot.unknown <- splot.species[splot.species$Taxonomy!="Austria" & splot.species$Taxon.group=="Unknown", ] 
dim(splot.unknown) # 3816266 entries
splot.unknown[40000:40100, c(2,3,6)]

# databases where lots of "unknown" species are mosses etc.
# Pasl2012 (but still many unknowns are angios)
#### 

########################################
## exclude species moss, lichen etc (this should also exclude most of the mosses... in the category "unknown"):#
##########################################
library(stringr)
library(dplyr)
splot.corr <- dplyr::left_join(splot.species.small, backbone.splot.small)
tail(splot.corr)

############################
# do not run (needs ~ 26 GB RAM): extract the first word from "splot.corr$name.short.correct"
word.splot.1 <- word(splot.corr$name.short.correct,1)
############################

# for moss etc. species that in "name.short.correct"
load("word.splot.1.Rdata")
head(word.splot.1)
tail(word.splot.1)

# for moss etc. species that in "names.sPlot.TRY"
load("word.splot.2.Rdata")
head(word.splot.2)
tail(word.splot.2)

names.moss.genus <- read.csv("names.moss.etc.genus.2.csv",stringsAsFactors = F)
names.moss.genus <- c(names.moss.genus[,2], "Cladina", "Sphenolobus", "Gowardia", "Schljakovia", "Placodium","Schljakovianthus","Vulpicida", "Protopannaria", "Allocetraria", "Sarmentypnum", "Limprichtia", "Bilimbia","Lophoziopsis","Orthocaulis","Lophoziopsis","Aplodon","Schistochilopsis","Saccobasis") 
# adds some additional genera of lichen and mosses that were not covered by taxon.group = moss, etc. but were found under taxon group = "unknown"
# set index for the entries in splot that correspond to mosses etc. in "name.short.correct"

index.moss <- which(word.splot.1 %in% names.moss.genus)
str(index.moss)

## for mosses etc. in "names.sPlot.TRY"
index.moss.2 <- which(word.splot.2 %in% names.moss.genus)
str(index.moss.2)
######## combine the two indices
index.moss.3 <- unique(c(index.moss, index.moss.2))
str(index.moss.3) # 5.902073 % of the entries in splot correspond to mosses, etc. 

# 
splot.vasc <- splot.corr[-index.moss.3,]
head(splot.vasc)
splot.vasc[1:100,]
dim(splot.vasc)
length(unique(splot.vasc$name.short.correct)) # excluding the mosses, etc., there are 58114 unique (corrected) vascular plant species names in splot
save(splot.vasc, file = "splot.vasc.Rdata")
load("splot.vasc.Rdata")


splot.nonvasc <- splot.corr[index.moss.3,]
head(splot.nonvasc)
splot.nonvasc[1:100,]
dim(splot.nonvasc)
length(unique(splot.nonvasc$name.short.correct)) # there are 2819 unique (resolved) non-vascular plant species names in splot 2.0

# means 95.4% of the (corrected) species names in splot 2.0 correspond to vascular plant species, 4.6 % correspond to non-vascular plant species

#######
## redo the trait match statistics just for vascular plants:
#######
# prune backbone to vascular plants, in splot:
index <- which(backbone.splot.try3.small$names.sPlot.TRY %in% splot.vasc$names.sPlot.TRY)

backbone.splot.vasc <- backbone.splot.try3.small[index, ]
### continue here:

##########
names(plantheight)[2] <- "names.sPlot.TRY"
library(dplyr)
plantheight.stand <- dplyr::inner_join(plantheight, backbone.splot.vasc)
dim(plantheight.stand)
#write.csv(plantheight.stand, file = "plantheight.stand.csv")
#########

length(unique(plantheight.stand$names.sPlot.TRY))
# there are 60273 (uncorrected) unique species names in TRY 3.0 (plantheight) ... 
length(unique(plantheight.stand$name.short.correct))
# of which 52459 are remaining after name resolution, means 12.96% of the species names in TRY 3.0 for which plantheight data are available are incorrect (Synonyms, unresolved)

# how many of these 52459 unique name in TRY 3.0 are in sPlot?

backbone.splot <- backbone.splot.try3.small[backbone.splot.try3.small$sPlot.TRY!="T", ]

length(unique(backbone.splot.vasc$name.short.correct))
# 60909 unique resolved species names in sPlot 2.0

#################
names.splot <- unique(backbone.splot.vasc$name.short.correct)
##############

########
names.plantheight <- unique(plantheight.stand$name.short.correct)
########

# how many species in splot are represented by try?:
100*(length(
    names.splot
    [which(names.splot
           %in% 
           names.plantheight)])/
     length(names.splot))

######################################
# gapfilled: 40.22439 %
# plantheight: 22.60557 %
# seedmass: 23.88237 %
# leafarea: 15.36291 %
# sla:13.53374 %
# nmass:10.63599 %
# ssd: 9.006436 %

# surprisingly, when mosses, etc. are kicked out, the match goes down by 1-4%, probably 

###
# for each (corrected) species i) count number of occurrences (frequency) and ii)

######

# test <- sPlot.TRY.data$splot.spec.vasc[,c(7,8,11)]

test <- splot.vasc[,c(1,4,5)]
spec.group <- group_by(test, name.short.correct)
spec.agg <- summarise(spec.group, count.spec = n(), Avg_Cover_Perc = mean(Cover..))
dim(spec.agg) # for all of the 58114 corrected, unique species, frequency and dominance has been calculated
summary(spec.agg)
# checking the most frequent and the most dominant species
spec.agg[spec.agg$Avg_Cover_Perc==100,]
spec.agg[spec.agg$count.spec>90000, ]

# save the list of the most frequent and the most dominant species
spec.agg.splot2.vasc <- spec.agg
save(spec.agg.splot2.vasc, file = "spec.agg.splot2.vasc.Rdata")
load("spec.agg.splot2.vasc.Rdata")

## calculate stats for i) the most frequent and ii) most dominant species:
names(spec.agg.splot2.vasc)

fac1 <- cut(as.numeric(spec.agg.splot2.vasc$count.spec), quantile(spec.agg.splot2.vasc$count.spec,(0:3)/3),labels=c("Low","Medium","High"))

quantile(spec.agg.splot2.vasc$count.spec,(0:3)/3)
#         0% 33.33333% 66.66667%      100% 
#        1         5        32    173272  

fac2 <- cut(as.numeric(spec.agg.splot2.vasc$Avg_Cover_Perc), quantile(spec.agg.splot2.vasc$Avg_Cover_Perc,(0:3)/3),labels=c("Low","Medium","High"))

quantile(spec.agg.splot2.vasc$Avg_Cover_Perc,(0:3)/3)
#         0%   33.33333%   66.66667%        100% 
#  0.0000000   0.4697802   2.5340659 100.0000000 

spec.agg.splot2.vasc$count.fac <- fac1
spec.agg.splot2.vasc$cover.fac <- fac2

# continue here
count.high <- spec.agg.splot2.vasc[which(spec.agg.splot2.vasc[,4]=="High"),
]

cover.high <- spec.agg.splot2.vasc[which(spec.agg.splot2.vasc[,5]=="High"),
]

#####

load("backbone.splot.vasc.Rdata")

##########
names(gapfilled)[2] <- "names.sPlot.TRY"
library(dplyr)
gapfilled.stand <- dplyr::inner_join(gapfilled, backbone.splot.vasc)
dim(gapfilled.stand)
#write.csv(gapfilled.stand, file = "gapfilled.stand.csv")
#########


########
names.gapfilled <- unique(gapfilled.stand$name.short.correct)
########

####

100*(length( # how many species in splot have trait data
    cover.high$name.short.correct
    [which(cover.high$name.short.correct
           %in% 
           names.gapfilled)])/
     length(cover.high$name.short.correct)) # total number of species in splot

###############
# count.high 
###############
# gapfilled: 60.76679 %
# plantheight: 43.86721 %
# seedmass: 41.52424 %
# leafarea: 27.39883 %
# sla: 26.6923 %
# nmass: 20.31794 %
# ssd: 12.0214 %

###############
# cover.high 
###############
# gapfilled: 48.27319 %
# plantheight: 33.28171 %
# seedmass: 35.00077 %
# leafarea: 18.64643 %
# sla: 19.27624 %
# nmass: 13.87125 %
# ssd: 6.809148 %

# 5) make graphs
# type table for global trait match (+ count, cover)

match.count.cover <- read.csv("/home/oliver/Dokumente/PhD/PostPhD/IDiv/sDiv/sPlot/Analyses/Data/Species/Match.TRY.sPlot2.count.cover.csv")

rownames(match.count.cover) <- match.count.cover$X
match.count.cover <- match.count.cover[,-1]
match.count.cover <- t(match.count.cover)

Match.sPlot2.TRY3.Count.Cover <- match.count.cover

write.table(Match.sPlot2.TRY3.Count.Cover, file = "Match.sPlot2.TRY3.Count.Cover.txt")
write.csv(Match.sPlot2.TRY3.Count.Cover, file = "Match.sPlot2.TRY3.Count.Cover.csv")


#####
# produce barcharts in ggplot2

biome <- as.data.frame(Match.sPlot2.TRY3.Count.Cover)
biome <- t(biome)
biome <- as.data.frame(biome)

biome$Traits <- factor(rownames(biome), levels=c("Gap.filled", "Height", "Seed.mass", "Leaf.area", "SLA", "N.mass", "SSD"))
colnames(biome)[1:4] <- c("All", "All.vasc", "Most.Frequent.vasc", "Most.Dominant.vasc")
mdat <- melt(biome, id.vars="Traits")
head(mdat)

# postscript(file = "Trait.splot2.try3.match.cover.dominance.eps", height = 3, width = 7, paper = "special", onefile = FALSE, horizontal = FALSE, pointsize=12)
#pdf("Trait.splot2.try3.match.cover.dominance.pdf", height = 3, width = 7)
png("Trait.splot2.try3.match.cover.dominance.png", height = 200, width = 470, pointsize = 10)

ggplot(mdat, aes(variable, value, fill=Traits)) + 
  geom_bar(stat="identity", position="dodge")+
    xlab("Species") +
  ylab("Percentage")+
  ggtitle("Match sPlot 2.0 - TRY 3.0")

ggsave("Trait.splot2.try3.match.cover.dominance.bmp", plot = last_plot(), device = "bmp", path = NULL, scale = 1, width = 165, height = 78, units = c("mm"), dpi = 150, limitsize = TRUE)

ggsave("Trait.splot2.try3.match.cover.dominance.png", plot = last_plot(), device = "png", path = NULL, scale = 1, width = 165, height = 78, units = c("mm"), dpi = 300, limitsize = TRUE)

dev.off()



# to do: 
# determine the most frequent species (ask contact Stephan Hennekens)

###################################################
# script from TNRS page to resolve names from R:
library(ape)
library(rjson)	
library(RCurl) 

tnrs.api<-'http://tnrs.iplantc.org/tnrsm-svc'

#Tree topology from Ackerly, D. 2009. Conservatism and diversification of plant functional traits: Evolutionary rates versus phylogenetic signal. PNAS 106:19699--19706.

lobelioids.string<-'((((((Lobelia_kauaensis,Lobelia_villosa),Lobelia_gloria-montis),(Trematolobelia_kauaiensis,Trematolobelia_macrostachys)),((Lobelia_hypoleuca,Lobelia_yuccoides),Lobelia_niihauensis)),((Brighamia_insignis,Brighamia_rockii),(Delissea_rhytidosperma,Delissea_subcordata))),((((Cyanea_pilosa,Cyanea_acuminata),Cyanea_hirtella),(Cyanea_coriacea,Cyanea_leptostegia)),(((Clermontia_kakeana,Clermontia_parviflora),Clermontia_arborescens),Clermontia_fauriei)));'

#Transform the newick sting into an ape phylo object
tree<-read.tree(text=lobelioids.string)

#Obtain the taxa names
old.names<-tree$tip.label

#Change the underscore characters into blank spaces
old.names<-gsub('_',' ',old.names)

#Transporms the vector into a string
old.names <- TNRS.TPL.2$TNRS.Name_submitted[11000:11110]
old.names<-paste(old.names,collapse=',')
old.names
#The string needs to be URL-encoded
old.names<-curlEscape(old.names)

#Send a request to the TNRS service
url<-paste(tnrs.api,'/matchNames?retrieve=all&names=',old.names,sep='')
tnrs.json<-getURL(url) 

#The response needs to be converted from JSON
tnrs.results<-fromJSON(tnrs.json)

#The corrected names are extracted from the response
names<-sapply(tnrs.results[[1]], function(x)
c(x$nameSubmitted,x$acceptedName,x$url))
names<-as.data.frame(t(names),stringsAsFactors=FALSE)
names

#If TNRS did not return any accepted name (no match, or name is
already accepted), the submitted name is retained
names[names[,2]=="",2]<-names[names[,2]=="",1] 

#The old taxa names are replaced with the corrected taxa names
tree$tip.label<-names[,2]

plot(tree)

###################################################


## other stuff
## combinations test for Öland review

x <- foreach(i = 1:length(seq1), .combine = rbind) %dopar% {
  taxize::tnrs(query = CleanedNames[seq1[i]:seq2[i]], source =
"iPlant_TNRS")
}

library(gtools)
library(foreach)

x <- foreach(i = 1:6, .combine = sum)%dopar% {
    dim(gtools::combinations(6,i,v=c("AMF", "C", "Grazing", "N", "P",
"PlantDiv")))[1]
    }

x <- foreach(i = 1:6, .combine = list) %dopar% {
    cbind("Age", combinations(6, i ,v=c("AMF", "C", "Grazing", "N",
"P", "PlantDiv")))
}





##############################


## Phylogeny Simone
spec.simone <-
read.csv("/home/oliver/Dokumente/PhD/PostPhD/Projects/Simone/wehpo.csv",
head = F)
library(ape)
tank.tree.simone <-
read.tree("/home/oliver/Dokumente/PhD/PostPhD/Projects/Simone/tank.tree.simone.tre")

str(spec.simone) 

spec.simone[,1] <- as.character(spec.simone[,1])

spec.simone[,1] <- gsub(" ", "_", spec.simone[,1])

spec.simone[,1][which(spec.simone[,1] %in% tank.tree.simone$tip.label
== F)]


missing <- spec.simone[,1][which(spec.simone[,1] %in%
tank.tree.simone$tip.label == F)]
write.csv(missing, file = "missing.csv")
as.data.frame(missing)

# substitute some names in the tank.tree.simone to match simones list 
# simone <- tank.tree.name

tank.tree.simone$tip.label[tank.tree.simone$tip.label=="Elaeocarpus_decipiens"]
<- "Elaeocarpus_glabripetalus"
tank.tree.simone$tip.label[tank.tree.simone$tip.label=="Manglietia_fordiana"]
<- "Magnolia_yuyuanensis"
tank.tree.simone$tip.label[tank.tree.simone$tip.label=="Triadica_sebifera"]
<- "Sapium_sebiferum"
tank.tree.simone$tip.label[tank.tree.simone$tip.label=="Dalbergia_nigra"]
<- "Dalbergia_retusa"

Elaeocarpus glabripetalus <- Elaeocarpus_decipiens # done 
# continue here:
Magnolia yuyuanensis <- Manglietia_fordiana
Sapium sebiferum  <- Triadica_sebifera
Dalbergia retusa <- Dalbergia_nigra

# add the rest to the global tank.tree as congeners using Brody's code
Celtis biondii
Elaeocarpus chinensis
Phoebe bournei
Quercus fabrei
Quercus phillyreoides
Sapindus mukorossi
Dipterocarpus conformis
Hopea sangal
Albizia adinocephala
Colubrina glandulosa
Albizia saman
Parashorea malaanonan (only one sister taxa in tank tree:
Parashorea_lucida)
Parashorea tomentella (only one sister taxa in tank tree:
Parashorea_lucida)

# create names vector and add to tank.tree

###################
library(ape)
library(geiger)

######################################################
#Takes a tree and species list, each containing "Genus_species"
#formatted names. For each species in the list, if it has a congener
#on the tree but is not itself on the tree, add it next to a 
#randomly selected congener at a random position along the edge
#returns a larger tree

# Written by Brody, Dec 2, 2014

addCongeners = function(tree,speciesToAdd)
  {
	resample <- function(x, ...) x[sample.int(length(x), ...)]
	staGenus =
unlist(lapply(strsplit(speciesToAdd,"_"),function(i){i[[1]]}))
	gtree = tree
	for(i in
sample(1:length(speciesToAdd),length(speciesToAdd),replace = F))
		{	

		gtreeGenera =
unlist(lapply(strsplit(gtree$tip,"_"),function(i){i[[1]]}))
		
		#If the species isn't on the tree but a congener is
		if(!speciesToAdd[i] %in% tree$tip.label & staGenus[i]
%in% gtreeGenera)
			{
			branchName =
gtree$tip[resample(which(gtreeGenera == staGenus[i]),1)]
			newtree = sim.bdtree(n=2)
			newtree$tip.label =
c(branchName,speciesToAdd[i])

			edgeL =
gtree$edge.length[which.edge(gtree,branchName)]

			#Splice in at a random depth between 0 and 1
			depth = runif(1,0,1)
			newtree$edge.length =
depth*newtree$edge.length*edgeL/max(newtree$edge.length)

			whereToGraft = which(gtree$tip == branchName)
			gtree = bind.tree(gtree,newtree,where =
whereToGraft,position = edgeL*depth)

			#The grafting process duplicates the
branchName tip. Drop one of them.
			gtree = drop.tip(gtree, which(gtree$tip ==
branchName)[1])
			}
		}
	return(gtree)
	}


## add species to the tank tree:

tank.tree.simone.2 <- addCongeners(tank.tree.simone, missing)
spec.simone[,1][which(spec.simone[,1] %in%
tank.tree.simone.2$tip.label == F)]

#rename the following
Larix eurolepis - added to Larix decidua (Die Europäische Lärche
(Larix decidua) und die Japanische Lärche (Larix kaempferi) 
bastardisiert gelegentlich zu Larix eurolepis (Syn. Larix ×
marschlinsii)) 
# done

# prune tank tree
dat <- rbind(spec.simone[,1], spec.simone[,1])
colnames(dat) <- dat[1,]
tank.tree.simone.pruned <- prune.sample(dat, tank.tree.simone.2)

pdf("Phylo_Simone.pdf", height = 15, width = 9)
plot(tank.tree.simone.pruned, type = "p", cex = .7)
dev.off()

write.tree(tank.tree.simone.pruned, file = "phylo_simone.tre")

##############################
# calculate diversity indices #
###############################

# read in community data
spec.simone <-
read.csv("/home/oliver/Dokumente/PhD/PostPhD/Projects/Simone/Community_matrix2.csv",
head = T)
str(spec.simone)
spec.simone[1:5,1:5]
rownames(spec.simone) <- spec.simone[,1]
# give rownames according to the site names
spec.simone2 <- spec.simone[,-1]

# remove species that do not occur in any site:
miss.spec <- apply(spec.simone2, 2, FUN = function (x)
{sum(is.na(x))})!=1008
spec.simone3 <- spec.simone2[,miss.spec]
# only contains 87 of the 107 species
spec.simone3[1:5,1:5]
# convert Nas into 0
spec.simone3[is.na(spec.simone3)] <- 0
str(spec.simone3)


colnames(spec.simone3) <- gsub("\\.", "_", colnames(spec.simone3))

colnames(spec.simone3)[which(colnames(spec.simone3)=="Parashorea__malaanonan")]
<- "Parashorea_malaanonan"

colnames(spec.simone3)[which(colnames(spec.simone3) %in%
colnames(mat$comm)==F)]

# match phylogeny and community data
mat <- match.phylo.comm(tank.tree.simone.pruned, spec.simone3)
phylodiv <- pd(mat$comm, mat$phy, include.root=TRUE)

library(PhyloMeasures)

pd.phylo <- pd.query(mat$phy, mat$comm)
pd.phylo.stand <- pd.query(mat$phy, mat$comm,TRUE)

mpd.phylo <- mpd.query(mat$phy, mat$comm)
mpd.phylo.stand <- mpd.query(mat$phy, mat$comm, TRUE)

mntd.phylo <- mntd.query(mat$phy, mat$comm)
mntd.phylo.stand <- mntd.query(mat$phy, mat$comm, TRUE)

plot(phylodiv$PD, phylodiv$SR)
plot(phylodiv$PD, pd.phylo)
cor(phylodiv$SR, pd.phylo.stand)
plot(phylodiv$PD, pd.phylo.stand)
plot(pd.phylo, pd.phylo.stand)

phylodiversity <- cbind(phylodiv$SR, pd.phylo, pd.phylo.stand,
mpd.phylo, mpd.phylo.stand, mntd.phylo, mntd.phylo.stand)
colnames(phylodiversity) <-
c("S","PD","PD.stand","MPD","MPD.stand","MNTD","MNTD.stand")

save(phylodiversity, file = "phylodiversity.Rdata")
write.csv(phylodiversity, file = "phylodiversity.csv")

com87 <- mat$comm
save(com87, file = "com87.Rdata")

phy87 <- mat$phy
save(phy87, file = "phy87.Rdata")

#################

## code Maddy:
Nem_Sp <-
read.csv("/home/oliver/Dokumente/PhD/PostPhD/Projects/Maddy/Nem_Sps.csv")
Nem.taxon <-
read.csv("/home/oliver/Dokumente/PhD/PostPhD/Projects/Maddy/Nem.taxon.csv")
colnames(Nem_Sp) <- paste("Spec", 1:50, sep=".")


library(vegan)
taxdis <- taxa2dist(Nem.taxon, varstep=TRUE)
taxdismat <- as.matrix(taxdis)

colnames(taxdismat) <- colnames(Nem_Sp)
rownames(taxdismat) <- colnames(Nem_Sp)

c1<-hclust(as.dist(taxdismat), "aver")

nem.tree <- as.phylo(c1)
plot(nem.tree)

Nem.Sp.49 <- Nem_Sp[,-38]

mat <- match.comm.dist(Nem.Sp.49, taxdismat)

mat2 <- match.phylo.comm(nem.tree, Nem.Sp.49)

library(picante)
library(FD)
library(spacodiR)

dbFDNull <- function(traits, com, value, nullmod, runs){
FD.shuff <- function(com, runs){
  Res = NA
  for (r in 1:runs) {     
    Res <- cbind(Res, dbFD(x = traits, a =
t(eval(parse(text=paste("resamp.", nullmod, sep = "")))(t(com))), corr
= "lingoes", m = 10, calc.CWM = F, stand.FRic = TRUE)[[value]])
  }
  return(Res)
}
obs <- dbFD(x = traits, a = com, corr = "lingoes", m = 10, calc.CWM =
F, stand.FRic = TRUE)[[value]]
resamp <- FD.shuff(com = com, runs = runs)
rand.mean <- apply(resamp, MARGIN = 1, FUN = mean, na.rm = TRUE)
rand.sd <- apply(resamp, MARGIN = 1, FUN = sd, na.rm = TRUE)
ses <- (obs - rand.mean)/rand.sd
data.frame(obs, ses)
}

# example FRic:
dbFD.FRic.Nullmod.SES <- dbFDNull(traits = as.dist(mat$dist), com =
mat$comm, value = 3, nullmod = "1s", runs = 20)
dbFD.FRic.Nullmod.SES

# example FDiv:
dbFD.FDiv.Nullmod.SES <- dbFDNull(traits = mat$dist, com = mat$comm,
value = 6, nullmod = "1s", runs = 9)
dbFD.FDiv.Nullmod.SES


res <- ses.mpd(mat$comm, mat$dist,null.model="taxa.labels", runs =
999, abundance.weighted = TRUE)
res

 
res.2 <- ses.mpd(mat$comm, mat$dist,null.model="taxa.labels", runs =
999, abundance.weighted = FALSE)
res.2   

res.3 <- ses.pd(mat2$comm, mat2$phy, null.model="taxa.labels", runs =
99)
res.3   

res.4 <- ses.pd(mat2$comm, mat2$phy, null.model="taxa.labels", runs =
99, include.root=TRUE)
res.4  

# treatment data:
Trt_Order <-
read.csv("/home/oliver/Dokumente/PhD/PostPhD/Projects/Maddy/Trt_Order.csv")

phylodiv <- cbind(res[,c(1,2,6)],res.2[,c(2,6)],res.3[,c(2,6)])
colnames(phylodiv) <- c("S", "mpd.abu", "ses.mpd.abu", "mpd.pa",
"ses.mpd.pa", "pd", "ses.pd")

phylodiv.trt <- cbind(Trt_Order,phylodiv)
str(phylodiv.trt)

write.csv(phylodiv.trt, file = "phylodiv.trt.csv")

#######################################################

# try to match tiff's:

 nam <- c("Pentacme_siamensis"     ,             "Anemonella_thalictroides"    ,
 "Cyclopogon_cranichoides"   ,          "Myrosmodes_cochleare"          ,     
 "Pyrostegia_venusta"         ,         "Lophocereus_schottii"          ,     
 "Chelonanthus_alatus"         ,        "Diplusodon_hirsutus"           ,     
 "Diplusodon_orbicularis"       ,       "Merostachys_riedeliana"        ,     
 "Calibrachoa_elegans"           ,      "Argyroxiphium_sandwicense"     ,     
 "Dicerandra_frutescens"          ,     "Alicia_anisopetala",
"Gastrodia_cunninghamii"              ,"Serapias_vomeracea"                 ,
 "Caulokaempferia_coenobialis"        , "Melocactus_glaucescens"   ,          
 "Melocactus_paucispinus"             , "Ledum_palustre_subsp._groenlandicum",
 "Rhaphiodon_echinus"              ,    "Anisodus_tanguticus"  ,              
 "Vellozia_declinans"              ,    "Vellozia_epidendroides"         ,    
 "Amasonia_campestris"             ,    "Psilochilus_modestus"             ,  
 "Flourensia_cernua"               ,    "Nastanthus_scapigerus"              ,
 "Anisodus_carniolicoides"         ,    "Anisodus_luridus"                  , 
 "Eremosparton_songoricum"         ,    "Bryophyllum_pinnatum"              , 
 "Crepidiastrum_grandicollum"      ,    "Leptopetalum_grayi"                , 
 "Luisia_boninensis"               ,    "Platypholis_boninsimae"            , 
"Acanthorrhinum_rivas-martinezii"  ,   "Ponerorchis_chusua"                , 
"Dayaoshania_cotinifolia"          ,   "Psilopeganum_sinense"              , 
"Kaempferia_rotunda"               ,   "Cipocereus_laniflorus"             , 
 "Macairea_radula"                 ,    "Svitramia_hatschbachii"           ,  
 "Svitramia_minor"                 ,    "Svitramia_spp."                   ,  
 "Trembleya_neopyrenaica"          ,    "Trembleya_parviflora"             ,  
"Schizocalyx_cuspidatus"           ,   "Stenostephanus_lobeliiformis"      , 
 "Geissomeria_pubescens"           ,    "Amasonia_obovata"                 ,  
 "Ameroglossum_pernambucense"      ,    "Camissoniopsis_cheiranthifolia"   ,  
 "Pteroglossa_glazioviana"         ,    "Pteroglossa_roseoalba"            ,  
 "Senghasiella_glaucifolia"  )

 nam2 <- gsub("_", " ", nam) 

nam2[is.na(match(nam2, backbone.splot.try3.small$names.sPlot.TRY))==F]

match(nam2, backbone.splot.try3.small$name.short.correct)

backbone.splot.try3.small nam2[is.na(match(nam2, backbone.splot.try3.small$names.sPlot.TRY))]

non.match <- nam2[is.na(match(nam2, backbone.splot.try3.small$names.sPlot.TRY))]
match <- nam2[is.na(match(nam2, backbone.splot.try3.small$names.sPlot.TRY))==F]

index <- which(backbone.splot.try3.small$name.short.correct %in% nam2)
backbone.splot.try3.match <- backbone.splot.try3.small[index,]
dim(backbone.splot.try3.match)
write.csv(backbone.splot.try3.match, file = "backbone.splot.try3.match.csv")
